{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next-reloaded/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"d2c60bbed26b416aa25e432f7084f4e38212261a","modified":1543384242655},{"_id":"themes/next-reloaded/LICENSE.md","hash":"fc7227c508af3351120181cbf2f9b99dc41f063e","modified":1541037363000},{"_id":"themes/next-reloaded/README.md","hash":"ee7119baf976616a84d3c9c10fcab567995dc98e","modified":1541037363000},{"_id":"themes/next-reloaded/_config.yml","hash":"4b251a4155ccb6689ea44403d100ab70d91a8335","modified":1543545419474},{"_id":"themes/next-reloaded/bower.json","hash":"087eb7b81c0aa77a2b07c2ecf411ceb5ee00386d","modified":1541037363000},{"_id":"themes/next-reloaded/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1541037363000},{"_id":"themes/next-reloaded/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1541037363000},{"_id":"themes/next-reloaded/package.json","hash":"cf079447c126a9ad760f1457441f31803ef0470b","modified":1541037363000},{"_id":"source/_data/recommended_posts.json","hash":"2f21a11fd4b1bccdf08056ac50d4d26fc8748c34","modified":1543820749373},{"_id":"source/_drafts/medical-news-190945.md","hash":"41e9143d5d15a90eb9d89184651188f84e9fe105","modified":1543378424702},{"_id":"source/_drafts/medical-news-191008.md","hash":"9c6500817e773229d7ca7ad658011c49025431ec","modified":1543378446606},{"_id":"source/_posts/An-Easy-To-Use-Analyzer-Tool-AnjSeq.md","hash":"9cb83ef70031cb00990d8849d9263026ef986d59","modified":1543814181374},{"_id":"source/_posts/How-To-GitHub.md","hash":"808eb8dc1ec6085b782477450cdea3ffe6b2515b","modified":1543820457883},{"_id":"source/_posts/How-To-Hexo.md","hash":"6b48366c3bc7dd0a65075af7c102daa4b199d2f5","modified":1543820653003},{"_id":"source/_posts/How-To-Next.md","hash":"83c0afe57079202590dc61cae3252af31fd98377","modified":1543820670023},{"_id":"source/_posts/Japanese-Analyzer-Tool-Kuromoji.md","hash":"a732fccb5a106f292ae07f695d8e168f6537d029","modified":1543814201856},{"_id":"source/_posts/The-Beauty-Of-Maths-02.md","hash":"cae1e15e20af46cc04cdc62ba128e774e4066bab","modified":1543820706429},{"_id":"source/categories/index.md","hash":"3e713bb05bb7130092ae7c9d21164e30629eaf46","modified":1543378978216},{"_id":"source/tags/index.md","hash":"92b4ca222ac4ade1a06991df9b9e3c1e3d79a7cc","modified":1543378323512},{"_id":"themes/next-reloaded/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1541037363000},{"_id":"themes/next-reloaded/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1541037363000},{"_id":"themes/next-reloaded/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1541037363000},{"_id":"themes/next-reloaded/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1541037363000},{"_id":"themes/next-reloaded/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1541037363000},{"_id":"themes/next-reloaded/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"120750c03ec30ccaa470b113bbe39f3d423c67f0","modified":1541037363000},{"_id":"themes/next-reloaded/docs/LICENSE","hash":"fe607fe22fc9308f6434b892a7f2d2c5514b8f0d","modified":1541037363000},{"_id":"themes/next-reloaded/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1541037363000},{"_id":"themes/next-reloaded/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1541037363000},{"_id":"themes/next-reloaded/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1541037363000},{"_id":"themes/next-reloaded/languages/default.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1541037363000},{"_id":"themes/next-reloaded/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1541037363000},{"_id":"themes/next-reloaded/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1541037363000},{"_id":"themes/next-reloaded/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1541037363000},{"_id":"themes/next-reloaded/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1541037363000},{"_id":"themes/next-reloaded/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1541037363000},{"_id":"themes/next-reloaded/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1541037363000},{"_id":"themes/next-reloaded/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1541037363000},{"_id":"themes/next-reloaded/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1541037363000},{"_id":"themes/next-reloaded/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1541037363000},{"_id":"themes/next-reloaded/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1541037363000},{"_id":"themes/next-reloaded/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1541037363000},{"_id":"themes/next-reloaded/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1541037363000},{"_id":"themes/next-reloaded/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1541037363000},{"_id":"themes/next-reloaded/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1541037363000},{"_id":"themes/next-reloaded/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_layout.swig","hash":"85de0662a1b136277a72f8d8b4b1425a006f377e","modified":1541037363000},{"_id":"themes/next-reloaded/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1541037363000},{"_id":"themes/next-reloaded/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1541037363000},{"_id":"themes/next-reloaded/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1541037363000},{"_id":"themes/next-reloaded/layout/page.swig","hash":"862b361852fb6d7a95bfb6077922410a33cd3126","modified":1541037363000},{"_id":"themes/next-reloaded/layout/post.swig","hash":"318249db246a57e9422875a2457c6acfce974ba5","modified":1541037363000},{"_id":"themes/next-reloaded/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1541037363000},{"_id":"themes/next-reloaded/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/helpers.js","hash":"a70bfad3efda76738dab12e28e8b75e3989ee3da","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1541037363000},{"_id":"themes/next-reloaded/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1541037363000},{"_id":"themes/next-reloaded/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1541037363000},{"_id":"themes/next-reloaded/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1541037363000},{"_id":"source/_drafts/The-Beauty-Of-Maths.md","hash":"4802edc47e3b10051a973ecb11290da7f8854029","modified":1543552707181},{"_id":"source/_posts/The-Beauty-Of-Maths-01.md","hash":"a3d2d7d67dee23b5d551e8a66a4064accf3de7c8","modified":1543820693379},{"_id":"themes/next-reloaded/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"source/_posts/How-To-Next/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543391955574},{"_id":"source/_posts/How-To-Next/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543391955575},{"_id":"themes/next-reloaded/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1541037363000},{"_id":"themes/next-reloaded/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1541037363000},{"_id":"themes/next-reloaded/docs/ru/README.md","hash":"c54e256ed11a84ee38f755d6f35a3e6e29a91dbc","modified":1541037363000},{"_id":"themes/next-reloaded/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"24cf2618d164440b047bb9396263de83bee5b993","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/MATH.md","hash":"8ac2f5d2a023211d8d8ea626cbf6b8dea67ac201","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/post-copyright.swig","hash":"0790ddbc349508d7ece45a9a4391d0a1cd7263cc","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/post-related.swig","hash":"08fe30ce8909b920540231e36c97e28cfbce62b6","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/post.swig","hash":"5767eccaf3951151e01c61189016932e9516c8b9","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/reward.swig","hash":"bd5778d509c51f4b1d8da3a2bc35462929f08c75","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/sidebar.swig","hash":"1f3121ef66a4698fd78f34bf2594ef79a407c92c","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/wechat-subscriber.swig","hash":"a9e1346b83cf99e06bed59a53fc069279751e52a","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/breadcrumb.swig","hash":"6994d891e064f10607bce23f6e2997db7994010e","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/comments.swig","hash":"eafff2d623af8991844f34819a60e37ac11ef245","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/footer.swig","hash":"d15a983de60d4c0bdd23cd31cd49de876ed2310c","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/page-header.swig","hash":"1aaf32bed57b976c4c1913fd801be34d4838cc72","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/boostrap.swig","hash":"0a0129e926c27fffc6e7ef87fe370016bc7a4564","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/commons.swig","hash":"6fc63d5da49cb6157b8792f39c7305b55a0d1593","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/noscript.swig","hash":"ac3ad2c0eccdf16edaa48816d111aaf51200a54b","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/vendors.swig","hash":"f380a10c792411eff82204305b097a288ed0b423","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/bookmark.swig","hash":"60001c8e08b21bf3a7afaf029839e1455340e95d","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/copy-code.swig","hash":"a8ab2035654dd06d94faf11a35750529e922d719","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/exturl.swig","hash":"f532ce257fca6108e84b8f35329c53f272c2ce84","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/github-banner.swig","hash":"cabd9640dc3027a0b3ac06f5ebce777e50754065","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/needsharebutton.swig","hash":"927f19160ae14e7030df306fc7114ba777476282","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/pangu.swig","hash":"6b75c5fd76ae7cf0a7b04024510bd5221607eab3","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/scroll-cookie.swig","hash":"b0ca46e0d1ff4c08cb0a3a8c1994f20d0260cef9","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/button.js","hash":"4b12c376bea894d23cca0f9fcb3d6518b6db279d","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/exturl.js","hash":"1412ce2ef59fa4137b697a507fd759ff067a2398","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/full-image.js","hash":"e282bf5a7c70b3d354001e8f66d3bef1a4fbb79e","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/group-pictures.js","hash":"981e01aaf45a1f0f23ce0796d03134f9e437aaca","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/label.js","hash":"f0ecd3b5773b19a6bd93a819dfe0c49ee418e4de","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/note.js","hash":"adb945ba93ac487d46b969ca4e59d3681b8f8d1c","modified":1541037363000},{"_id":"themes/next-reloaded/scripts/tags/tabs.js","hash":"e37761253d68a29593fe9ed2fe403f49b6e971de","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/main.styl","hash":"c26ca6e7b5bd910b9046d6722c8e00be672890e0","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1541037363000},{"_id":"themes/next-reloaded/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1541037363000},{"_id":"themes/next-reloaded/docs/zh-CN/README.md","hash":"aa6808f4f587c1a97205fa9427ba96a366bcb288","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_macro/menu/menu-item.swig","hash":"d1b73c926109145e52605929b75914cc8b60fb89","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/head/head-unique.swig","hash":"a7e376b087ae77f2e2a61ba6af81cde5af693174","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/head/head.swig","hash":"00bf33b3c557b8f7e9faf49b226ea6ff7df5cda0","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/header/brand.swig","hash":"fd780171713aada5eb4f4ffed8e714617c8ae6be","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/header/menu.swig","hash":"3db735d0cd2d449edf2674310ac1e7c0043cb357","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/header/sub-menu.swig","hash":"88b4b6051592d26bff59788acb76346ce4e398c2","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/search/index.swig","hash":"a33b29ccbdc2248aedff23b04e0627f435824406","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/pages/post-details.swig","hash":"cc865af4a3cb6d25a0be171b7fc919ade306bb50","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/schemes/gemini.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_scripts/schemes/pisces.swig","hash":"ea03fe9c98ddcfcc0ecfdbe5a2b622f9cde3b3a1","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/busuanzi-counter.swig","hash":"07307f1f0e0e9858f2c7143cbdfcb2a9a92149ab","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/google-analytics.swig","hash":"beb53371c035b62e1a2c7bb76c63afbb595fe6e5","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/growingio.swig","hash":"5dbeb640707a9c91357e373b9063a48c8e78f439","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/lean-analytics.swig","hash":"c28f3f4aa31d7f996d26a97df6cd7ffa9bfd2cec","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/comments/disqus.swig","hash":"03ef008bc95e8e83232e5464a6c63d6157d33a5e","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/comments/gitment.swig","hash":"fe8177e4698df764e470354b6acde8292a3515e0","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/comments/index.swig","hash":"03e83f1311faafb7dddc2899042ed1cacd5c995e","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/comments/livere.swig","hash":"2c74a96dd314e804d801f8773ac1b2e0a970fce3","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/comments/valine.swig","hash":"34421679cae6581697cd3ab7c3729eb220e3e3f5","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/math/index.swig","hash":"a6fc00ec7f5642aabd66aa1cf51c6acc5b10e012","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/math/katex.swig","hash":"97dbc2035bcb5aa7eafb80a4202dc827cce34983","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/math/mathjax.swig","hash":"9b9ff4cc6d5474ab03f09835a2be80e0dba9fe89","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/search/localsearch.swig","hash":"b15e10abe85b4270860a56c970b559baa258b2a8","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_mixins/base.styl","hash":"59961fb806a39c367fd19ad37268eee112be6729","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_variables/Gemini.styl","hash":"e1f6f59ad6e562dfe640ee4ed5d1ac9b6aba4114","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_variables/Pisces.styl","hash":"c167eeb6b736f7b021fba98c38c2c21032ee1255","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_variables/base.styl","hash":"f9b83d0385529e52ce7ba95ed5ed6b3d4e2419bb","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/assets.swig","hash":"6958a97fde63e03983ec2394a4f8e408860fb42b","modified":1541037363000},{"_id":"themes/next-reloaded/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top-sidebar.styl","hash":"b4a2f1d031fe44452cf55ded8211cf018235073a","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/outline/outline.styl","hash":"aebbd86500d819c4532ab290c62b6f432bc2f878","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/base.styl","hash":"b75256fe3768b1a37b6ff6dd7f9f0ff135a42067","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/mobile.styl","hash":"efc40a32487e0ac7b94b1ca81bdbdcc4ec8f2924","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/tables.styl","hash":"02d138ed65060e98f20bc5b1dd59a791222b7156","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Gemini/index.styl","hash":"665b1813a1d6fbc3c5549a76e4f26cd62a804dde","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_menu.styl","hash":"f43c821ea272f80703862260b140932fe4aa0e1f","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_posts-expanded.styl","hash":"2212511ae14258d93bec57993c0385e5ffbb382b","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/index.styl","hash":"5e12572b18846250e016a872a738026478ceef37","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_menu.styl","hash":"35f093fe4c1861661ac1542d6e8ea5a9bbfeb659","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_layout.styl","hash":"876b5d99061025cf485a3cac440624ded5734319","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_menu.styl","hash":"05a5abf02e84ba8f639b6f9533418359f0ae4ecb","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sidebar.styl","hash":"41f9cdafa00e256561c50ae0b97ab7fcd7c1d6a2","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/_sub-menu.styl","hash":"ffa870c3fa37a48b01dc6f967e66f5df508d02bf","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1541037363000},{"_id":"themes/next-reloaded/source/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/footer/footer.styl","hash":"39dee82d481dd9d44e33658960ec63e47cd0a715","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/header/github-banner.styl","hash":"ee37e6c465b9b2a7e39175fccfcbed14f2db039b","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/highlight.styl","hash":"a6dc3c7eb81ef5117c28fa2245fff1adc02d0292","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pages/breadcrumb.styl","hash":"7dd9a0378ccff3e4a2003f486b1a34e74c20dac6","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/pages/schedule.styl","hash":"f2911a048e5c20ca2a059bd1087d98ac1c51681c","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-expand.styl","hash":"ca89b167d368eac50a4f808fa53ba67e69cbef94","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-meta.styl","hash":"417f05ff12a2aaca6ceeac8b7e7eb26e9440c4c3","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reading_progress.styl","hash":"f4e9f870baa56eae423a123062f00e24cc780be1","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-reward.styl","hash":"549a8a0b5301d32acd86a97f17340cdfcd46fb63","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-title.styl","hash":"fcbbf06b546c366d70b7d2ba5880b0be3ca1e8ea","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post-widgets.styl","hash":"578bb2d5f24cad39205bbafb4c39c7e9962b9fa9","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/post/post.styl","hash":"6089cbf4c907fe198b6501e40dc937480d0be175","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-author.styl","hash":"e18b90c97aaff027e795f5a0cb10476a71bf1c3a","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"4427ed3250483ed5b7baad74fa93474bd1eda729","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/sidebar.styl","hash":"43bc58daa8d35d5d515dc787ceb21dd77633fe49","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/algolia-search.styl","hash":"10e9bb3392826a5a8f4cabfc14c6d81645f33fe6","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/related-posts.styl","hash":"76937db9702053d772f6758d9cea4088c2a6e2a3","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_common/components/third-party/third-party.styl","hash":"1c18c91ab3c60169ebe654c80c968fd8458786a3","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541037363000},{"_id":"themes/next-reloaded/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1541037363000},{"_id":"themes/next-reloaded/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1541037363000},{"_id":"public/atom.xml","hash":"8147fa1f1411908a108dcc73bb00a41c3fe96cb6","modified":1543820760567},{"_id":"public/404.html","hash":"bf59b9d5734a8e757cd3376c06f62206b43547ff","modified":1543820760598},{"_id":"public/tags/index.html","hash":"94f2dda652edd7c49567f4fc5e420ac34396c1ad","modified":1543820760599},{"_id":"public/archives/2015/index.html","hash":"ecc0801c4dfa6a26f4165b88a709e1230dbe5532","modified":1543820760599},{"_id":"public/archives/2015/12/index.html","hash":"4a6572d6ac8baa6a0f18ed350a256e27fd51a748","modified":1543820760599},{"_id":"public/archives/2016/index.html","hash":"a266b1a879f3c490258d28f432373630d960f10a","modified":1543820760599},{"_id":"public/archives/2016/11/index.html","hash":"05d50cf0cab28cefa620434b4506b5412b7bb0e9","modified":1543820760599},{"_id":"public/archives/2017/index.html","hash":"c3c3d06165ddd641fc6fbf7581068f1a32f040df","modified":1543820760599},{"_id":"public/archives/2017/11/index.html","hash":"b77b17cc8abd405f83c4912bc7bd9d28ace421cf","modified":1543820760599},{"_id":"public/archives/2018/index.html","hash":"f66501933e03838a6a47742854e15dbce2d2c32e","modified":1543820760599},{"_id":"public/archives/2018/11/index.html","hash":"e3fb88da87cd673dab6556d2acd916ef64b48d09","modified":1543820760600},{"_id":"public/archives/2018/12/index.html","hash":"35352feeb4fe5f40072cf00013be5ec8fab9663d","modified":1543820760600},{"_id":"public/categories/GitHub/index.html","hash":"50455ecd6ff2b9390fa22af4b128bbf02a9bf193","modified":1543820760600},{"_id":"public/categories/hexo/index.html","hash":"375711df7d987191850f89c9580a08742979e97d","modified":1543820760600},{"_id":"public/categories/日语/index.html","hash":"2f034a73cb88d29c3a3de671e6ac44e7c9506d59","modified":1543820760600},{"_id":"public/categories/GitHub/How-To/index.html","hash":"9ccba874b59e1dc5bd5cac5d662cb492f5454e6d","modified":1543820760600},{"_id":"public/categories/日语/Kuromoji/index.html","hash":"fe9756215fa663d8f8ae96b70d73681f51b3af26","modified":1543820760600},{"_id":"public/categories/日语/Kuromoji/Word-Analyzer/index.html","hash":"0658e00a68e1b8b141b8bfd1e7f76440479ae5cf","modified":1543820760600},{"_id":"public/categories/日语/Kuromoji/Word-Analyzer/Java/index.html","hash":"99dc7a32b0661869ae9599160920d699e6c7dc99","modified":1543820760601},{"_id":"public/categories/AnsjSeq/index.html","hash":"fbd10cdd880f894c9c75b4098c945b920265f26c","modified":1543820760601},{"_id":"public/categories/next/index.html","hash":"47c16608c3d40b979211a2c0f9e536f5cd12828b","modified":1543820760601},{"_id":"public/categories/AnsjSeq/Word-Analyzer/index.html","hash":"ac5cefe3529f43e30e579993d827860fe0d646a5","modified":1543820760601},{"_id":"public/categories/next/hexo/index.html","hash":"c2df11f699dcbafb1c066648322c2ddf3c73b7ef","modified":1543820760601},{"_id":"public/categories/AnsjSeq/Word-Analyzer/Java/index.html","hash":"99288ce5b1716322d86ba123a695425dbb5869a8","modified":1543820760601},{"_id":"public/categories/Maths/index.html","hash":"640084622f1d3002b915f6c69c836e08889a3955","modified":1543820760601},{"_id":"public/categories/Maths/Algorithm/index.html","hash":"6fe2affa642591d54542d71fbf3b207376078ed9","modified":1543820760601},{"_id":"public/tags/GitHub/index.html","hash":"f4a7ce8f7db9035b8ac0d17620300d10ad0850bf","modified":1543820760601},{"_id":"public/tags/How-To/index.html","hash":"f19a72df179177898ce0d5151608397c3c392f0f","modified":1543820760601},{"_id":"public/tags/hexo/index.html","hash":"c56de23c15e6b983ac887f82008c0c2de5f085cc","modified":1543820760602},{"_id":"public/tags/日语/index.html","hash":"9b63365121ed0aaf78d8efe7de9eb953c3945f06","modified":1543820760602},{"_id":"public/tags/分词/index.html","hash":"024169bea7c514c6609fb30c81e9753d2533cfe0","modified":1543820760602},{"_id":"public/tags/Java/index.html","hash":"79a84027c3aa801339c1fe3911dd59f2bb06d6c9","modified":1543820760602},{"_id":"public/tags/Kuromoji/index.html","hash":"322fbe4cc824cb65c76aa82eabcefd2eaa7e73d9","modified":1543820760602},{"_id":"public/tags/Word-Analyzer/index.html","hash":"aa37f6a8493680c8f32c69e29e2e716eb313cc5b","modified":1543820760602},{"_id":"public/tags/AnsjSeq/index.html","hash":"67bce65b6fea0c7118c9a2620aff069ed23f1e89","modified":1543820760602},{"_id":"public/tags/next/index.html","hash":"64b50b31c8df8f7eed3855fe0c7811edc33507bc","modified":1543820760602},{"_id":"public/tags/吴军/index.html","hash":"c5f43bc205af2fd2443401eca2e228f8bc16c376","modified":1543820760603},{"_id":"public/tags/算法/index.html","hash":"bfde03ca20b04adc086c350097a0b5cf1a24e53e","modified":1543820760603},{"_id":"public/tags/数学/index.html","hash":"674fc8690f9c0a0396fe99221adf0154d2836238","modified":1543820760603},{"_id":"public/categories/index.html","hash":"eed080786bd42e8e44bc5830f3c5bff7aeaf848b","modified":1543820760603},{"_id":"public/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/index.html","hash":"fc2ce32bfc23639d48a780f00b07b857c6a8b567","modified":1543820760603},{"_id":"public/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/index.html","hash":"350e9106f2fd82fb09092ebeb1a860129bca98f7","modified":1543820760603},{"_id":"public/2017/11/30/The-Beauty-Of-Maths-02/index.html","hash":"7045281516c65ccb4ebf629e43511e8d262d7e81","modified":1543820760603},{"_id":"public/2017/11/30/The-Beauty-Of-Maths-01/index.html","hash":"0bcf2eda941c36e6d7f9a62547a2e1af83c6dbd9","modified":1543820760603},{"_id":"public/2016/11/28/How-To-Hexo/index.html","hash":"e0ef8a2de1197e6eb7fa0fefe60a0144b0fb474a","modified":1543820760604},{"_id":"public/2016/11/28/How-To-Next/index.html","hash":"220fda7bb07b68c8cde54820855ff72cb039768a","modified":1543820760604},{"_id":"public/2015/12/03/How-To-GitHub/index.html","hash":"36202aa5a636d7eb66332ee03caa7457f575dba1","modified":1543820760604},{"_id":"public/archives/index.html","hash":"e5d62be8c7361a5c829e513e741ac2e1b35f1fb8","modified":1543820760604},{"_id":"public/index.html","hash":"61e947b710e81955dbd6e9d5bff1faf26284fd54","modified":1543820760604},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1543820760614},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1543820760614},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1543820760615},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1543820760615},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1543820760615},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1543820760615},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1543820760615},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1543820760615},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1543820760615},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1543820760615},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1543820760616},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1543820760616},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543820760616},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543820760616},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1543820760616},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1543820760616},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1543820760616},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1543820760617},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1543820760617},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1543820760617},{"_id":"public/2016/11/28/How-To-Next/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1543820760617},{"_id":"public/2016/11/28/How-To-Next/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1543820760617},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1543820761395},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1543820761396},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1543820761411},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1543820761411},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1543820761412},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1543820761412},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1543820761412},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1543820761412},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1543820761412},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1543820761412},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1543820761412},{"_id":"public/js/src/schemes/pisces.js","hash":"89267bd16ecbedd1958af7f0fb3f4f654d24fffa","modified":1543820761412},{"_id":"public/css/main.css","hash":"6579134c8175ecf38588b81892312e249a41f5c0","modified":1543820761413},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1543820761413},{"_id":"public/js/src/motion.js","hash":"b45d2c0d48f2c8e6a0621b8063845f76b89476cc","modified":1543820761422},{"_id":"public/js/src/utils.js","hash":"66f2ac658d6110f70a86f784d0c5d891a97c14bd","modified":1543820761422},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1543820761423},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1543820761423},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1543820761423},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1543820761434},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1543820761443},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1543820761444},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1543820761444},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1543820761468},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1543820761473}],"Category":[{"name":"medical_news","_id":"cjp7z0mw10005rd4l2plmsksx"},{"name":"GitHub","_id":"cjp7z0mwg000drd4lbpd8rix5"},{"name":"hexo","_id":"cjp7z0mwi000ird4lilrmp8yi"},{"name":"日语","_id":"cjp7z0mwj000krd4l9jpzsrk7"},{"name":"How-To","parent":"cjp7z0mwg000drd4lbpd8rix5","_id":"cjp7z0mwl000prd4le7eynu9s"},{"name":"Kuromoji","parent":"cjp7z0mwj000krd4l9jpzsrk7","_id":"cjp7z0mwm000srd4ll7i7cr0o"},{"name":"Word Analyzer","parent":"cjp7z0mwm000srd4ll7i7cr0o","_id":"cjp7z0mwo000xrd4lqahux0n5"},{"name":"Java","parent":"cjp7z0mwo000xrd4lqahux0n5","_id":"cjp7z0mwp000zrd4lmwv1v0r6"},{"name":"AnsjSeq","_id":"cjp7z0my7001crd4lyxfa3laq"},{"name":"next","_id":"cjp7z0my8001erd4l3ytwqi02"},{"name":"Word Analyzer","parent":"cjp7z0my7001crd4lyxfa3laq","_id":"cjp7z0my9001ird4lfa8zha1a"},{"name":"hexo","parent":"cjp7z0my8001erd4l3ytwqi02","_id":"cjp7z0mya001lrd4luvxkaeu2"},{"name":"Java","parent":"cjp7z0my9001ird4lfa8zha1a","_id":"cjp7z0mya001ord4l26akqrdg"},{"name":"Maths","_id":"cjp7z0n5l001vrd4lfoqve4mh"},{"name":"Algorithm","parent":"cjp7z0n5l001vrd4lfoqve4mh","_id":"cjp7z0n5m001yrd4lznudc0qv"}],"Data":[{"_id":"recommended_posts","data":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n    <title>404</title>\n    <meta name=\"description\" content=\"404 not exists!\">\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <meta name=\"robots\" content=\"all\" />\n    <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到Blog\"></script>\n</body>\n</html>\n","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n    <title>404</title>\n    <meta name=\"description\" content=\"404 not exists!\">\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n    <meta name=\"robots\" content=\"all\" />\n    <meta name=\"robots\" content=\"index,follow\"/>\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到Blog\"></script>\n</body>\n</html>\n","date":"2018-11-28T05:50:42.655Z","updated":"2018-11-28T05:50:42.655Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cjp7z0mk10000rd4l9bi9ibkp","content":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <title>404</title>\n    <meta name=\"description\" content=\"404 not exists!\">\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"robots\" content=\"all\">\n    <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到Blog\"></script>\n</body>\n</html>\n","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head><meta name=\"generator\" content=\"Hexo 3.8.0\">\n    <title>404</title>\n    <meta name=\"description\" content=\"404 not exists!\">\n    <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n    <meta name=\"robots\" content=\"all\">\n    <meta name=\"robots\" content=\"index,follow\">\n</head>\n<body>\n<script type=\"text/javascript\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到Blog\"></script>\n</body>\n</html>\n"},{"title":"categories","date":"2018-11-28T04:09:10.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-11-28 13:09:10\ntype: categories\n---\n","updated":"2018-11-28T04:22:58.216Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjp7z0mvn0002rd4l1pp8pijg","content":"","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":""},{"title":"tags","date":"2018-11-28T04:08:40.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-11-28 13:08:40\ntype: \"tags\"\n---\n","updated":"2018-11-28T04:12:03.512Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjp7z0mvt0004rd4lbtobvrm8","content":"","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":""}],"Post":[{"title":"偏食が抑うつ招く","author":"Tim Zhang","date":"2016-11-27T01:41:00.000Z","_content":"\n## 偏食が抑うつ招く バランス良い食事を\n\n偏食が抑うつ招くバランス良い食事を厚生労働省の調べによると、うつ病などの気分障害の患者数は２０１４年には１１１万６０００人に上り、増加傾向にある。従来、人間関係や環境の変化といった外的要因が関係するとされてきたが、最近では、食事の偏りも原因の一つだと考えられるようになってきている。国立国際医療研究セ\n\n<div align=\"center\"><a href=\"https://medical.jiji.com/topics/790\">続き読む</a></div>\n","source":"_drafts/medical-news-190945.md","raw":"title: 偏食が抑うつ招く\nauthor: Tim Zhang\ntags:\n  [medical_news]\ncategories:\n  medical_news\ndate: 2016-11-27 10:41:00\n---\n\n## 偏食が抑うつ招く バランス良い食事を\n\n偏食が抑うつ招くバランス良い食事を厚生労働省の調べによると、うつ病などの気分障害の患者数は２０１４年には１１１万６０００人に上り、増加傾向にある。従来、人間関係や環境の変化といった外的要因が関係するとされてきたが、最近では、食事の偏りも原因の一つだと考えられるようになってきている。国立国際医療研究セ\n\n<div align=\"center\"><a href=\"https://medical.jiji.com/topics/790\">続き読む</a></div>\n","slug":"medical-news-190945","published":0,"updated":"2018-11-28T04:13:44.702Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0mvg0001rd4l9p985tca","content":"<h2 id=\"偏食が抑うつ招く-バランス良い食事を\"><a href=\"#偏食が抑うつ招く-バランス良い食事を\" class=\"headerlink\" title=\"偏食が抑うつ招く バランス良い食事を\"></a>偏食が抑うつ招く バランス良い食事を</h2><p>偏食が抑うつ招くバランス良い食事を厚生労働省の調べによると、うつ病などの気分障害の患者数は２０１４年には１１１万６０００人に上り、増加傾向にある。従来、人間関係や環境の変化といった外的要因が関係するとされてきたが、最近では、食事の偏りも原因の一つだと考えられるようになってきている。国立国際医療研究セ</p>\n<div align=\"center\"><a href=\"https://medical.jiji.com/topics/790\" target=\"_blank\" rel=\"noopener\">続き読む</a></div>\n","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"偏食が抑うつ招く-バランス良い食事を\"><a href=\"#偏食が抑うつ招く-バランス良い食事を\" class=\"headerlink\" title=\"偏食が抑うつ招く バランス良い食事を\"></a>偏食が抑うつ招く バランス良い食事を</h2><p>偏食が抑うつ招くバランス良い食事を厚生労働省の調べによると、うつ病などの気分障害の患者数は２０１４年には１１１万６０００人に上り、増加傾向にある。従来、人間関係や環境の変化といった外的要因が関係するとされてきたが、最近では、食事の偏りも原因の一つだと考えられるようになってきている。国立国際医療研究セ</p>\n<div align=\"center\"><a href=\"https://medical.jiji.com/topics/790\" target=\"_blank\" rel=\"noopener\">続き読む</a></div>\n"},{"title":"肺の除神経治療がCOPD患者の症状改善に有効","author":"Tim Zhang","date":"2018-11-28T02:20:00.000Z","_content":"## 肺の除神経治療がCOPD患者の症状改善に有効\n\n標的を定めた肺の除神経（TLD）治療により、慢性閉塞性肺疾患（COPD）患者の症状が50％以上軽減することが、欧州呼吸器学会（ERS 2018、9月28日～10月2日、パリ）で発表された。\n\nフローニンゲン大学医療センター（オランダ）のDirk-Jan Slebos氏らは、欧州6カ国のCOPD患者82人を対象にTLDまたは偽治療を実施。TLD群では、気管支鏡を用い肺にカテーテルを挿入し、カテーテルから気道の外側の神経に電気を送り、神経機能を変化させた。これで気道が弛緩して拡張し、粘液が減少して気道壁の炎症も軽減する。その後、カテーテルと気管支鏡は抜去された。\n\nその結果、治療開始から6週後までに、偽治療群の71％に深刻な急性増悪がみられたが、TLD群では32％であった。1年以内に呼吸器合併症で入院した患者数は、偽治療群に比べTLD群は半数未満。TLD群で死亡例はみられず、一部に副作用がみられたが6カ月以内に消失した。\n\n（HealthDay News 2018年9月18日）\n\nNews release：\n\n(https://www.ersnet.org/the-society/news/copd-patients-suffer-fewer-respiratory-related-problems-when-treated-with-targeted-lung-denervation)\n\nCopyright © 2018 HealthDay. All rights reserved.\n","source":"_drafts/medical-news-191008.md","raw":"title: 肺の除神経治療がCOPD患者の症状改善に有効\nauthor: Tim Zhang\ntags:\n  [medical_news]\ncategories:\n  medical_news\ndate: 2018-11-28 11:20:00\n---\n## 肺の除神経治療がCOPD患者の症状改善に有効\n\n標的を定めた肺の除神経（TLD）治療により、慢性閉塞性肺疾患（COPD）患者の症状が50％以上軽減することが、欧州呼吸器学会（ERS 2018、9月28日～10月2日、パリ）で発表された。\n\nフローニンゲン大学医療センター（オランダ）のDirk-Jan Slebos氏らは、欧州6カ国のCOPD患者82人を対象にTLDまたは偽治療を実施。TLD群では、気管支鏡を用い肺にカテーテルを挿入し、カテーテルから気道の外側の神経に電気を送り、神経機能を変化させた。これで気道が弛緩して拡張し、粘液が減少して気道壁の炎症も軽減する。その後、カテーテルと気管支鏡は抜去された。\n\nその結果、治療開始から6週後までに、偽治療群の71％に深刻な急性増悪がみられたが、TLD群では32％であった。1年以内に呼吸器合併症で入院した患者数は、偽治療群に比べTLD群は半数未満。TLD群で死亡例はみられず、一部に副作用がみられたが6カ月以内に消失した。\n\n（HealthDay News 2018年9月18日）\n\nNews release：\n\n(https://www.ersnet.org/the-society/news/copd-patients-suffer-fewer-respiratory-related-problems-when-treated-with-targeted-lung-denervation)\n\nCopyright © 2018 HealthDay. All rights reserved.\n","slug":"medical-news-191008","published":0,"updated":"2018-11-28T04:14:06.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0mvq0003rd4lyu5gu255","content":"<h2 id=\"肺の除神経治療がCOPD患者の症状改善に有効\"><a href=\"#肺の除神経治療がCOPD患者の症状改善に有効\" class=\"headerlink\" title=\"肺の除神経治療がCOPD患者の症状改善に有効\"></a>肺の除神経治療がCOPD患者の症状改善に有効</h2><p>標的を定めた肺の除神経（TLD）治療により、慢性閉塞性肺疾患（COPD）患者の症状が50％以上軽減することが、欧州呼吸器学会（ERS 2018、9月28日～10月2日、パリ）で発表された。</p>\n<p>フローニンゲン大学医療センター（オランダ）のDirk-Jan Slebos氏らは、欧州6カ国のCOPD患者82人を対象にTLDまたは偽治療を実施。TLD群では、気管支鏡を用い肺にカテーテルを挿入し、カテーテルから気道の外側の神経に電気を送り、神経機能を変化させた。これで気道が弛緩して拡張し、粘液が減少して気道壁の炎症も軽減する。その後、カテーテルと気管支鏡は抜去された。</p>\n<p>その結果、治療開始から6週後までに、偽治療群の71％に深刻な急性増悪がみられたが、TLD群では32％であった。1年以内に呼吸器合併症で入院した患者数は、偽治療群に比べTLD群は半数未満。TLD群で死亡例はみられず、一部に副作用がみられたが6カ月以内に消失した。</p>\n<p>（HealthDay News 2018年9月18日）</p>\n<p>News release：</p>\n<p>(<a href=\"https://www.ersnet.org/the-society/news/copd-patients-suffer-fewer-respiratory-related-problems-when-treated-with-targeted-lung-denervation\" target=\"_blank\" rel=\"noopener\">https://www.ersnet.org/the-society/news/copd-patients-suffer-fewer-respiratory-related-problems-when-treated-with-targeted-lung-denervation</a>)</p>\n<p>Copyright © 2018 HealthDay. All rights reserved.</p>\n","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"肺の除神経治療がCOPD患者の症状改善に有効\"><a href=\"#肺の除神経治療がCOPD患者の症状改善に有効\" class=\"headerlink\" title=\"肺の除神経治療がCOPD患者の症状改善に有効\"></a>肺の除神経治療がCOPD患者の症状改善に有効</h2><p>標的を定めた肺の除神経（TLD）治療により、慢性閉塞性肺疾患（COPD）患者の症状が50％以上軽減することが、欧州呼吸器学会（ERS 2018、9月28日～10月2日、パリ）で発表された。</p>\n<p>フローニンゲン大学医療センター（オランダ）のDirk-Jan Slebos氏らは、欧州6カ国のCOPD患者82人を対象にTLDまたは偽治療を実施。TLD群では、気管支鏡を用い肺にカテーテルを挿入し、カテーテルから気道の外側の神経に電気を送り、神経機能を変化させた。これで気道が弛緩して拡張し、粘液が減少して気道壁の炎症も軽減する。その後、カテーテルと気管支鏡は抜去された。</p>\n<p>その結果、治療開始から6週後までに、偽治療群の71％に深刻な急性増悪がみられたが、TLD群では32％であった。1年以内に呼吸器合併症で入院した患者数は、偽治療群に比べTLD群は半数未満。TLD群で死亡例はみられず、一部に副作用がみられたが6カ月以内に消失した。</p>\n<p>（HealthDay News 2018年9月18日）</p>\n<p>News release：</p>\n<p>(<a href=\"https://www.ersnet.org/the-society/news/copd-patients-suffer-fewer-respiratory-related-problems-when-treated-with-targeted-lung-denervation\" target=\"_blank\" rel=\"noopener\">https://www.ersnet.org/the-society/news/copd-patients-suffer-fewer-respiratory-related-problems-when-treated-with-targeted-lung-denervation</a>)</p>\n<p>Copyright © 2018 HealthDay. All rights reserved.</p>\n"},{"title":"How To GitHub","author":"Tim Zhang","date":"2015-12-03T06:57:00.000Z","_content":"### 第一步：在github上手动创建仓库[name of your repo]\n\nGitHub Url(https://www.github.com)\n\n### 第二步：本地建立git仓库操作\n\n```sh\ncd [name of your repo]\ngit init #初始化本地仓库\ngit add xxx #添加要push到远程仓库的文件或文件夹\ngit commit -m ‘first commit’\ngit remote add origin https://github.com/yourgithubID/gitRepo.git #建立github远程仓库信息\ngit pull --rebase origin master #通过如下命令将远程代码合并到本地仓库（注：pull=fetch+merge)\n```\n\n### 第三步：本地代码上传github仓库\n\n```sh\ngit push -u origin master #将本地仓库push到远程仓库\n```\n","source":"_posts/How-To-GitHub.md","raw":"title: How To GitHub\nauthor: Tim Zhang\ntags:\n  - GitHub\n  - How-To\ncategories:\n  - GitHub\n  - How-To\ndate: 2015-12-03 15:57:00\n---\n### 第一步：在github上手动创建仓库[name of your repo]\n\nGitHub Url(https://www.github.com)\n\n### 第二步：本地建立git仓库操作\n\n```sh\ncd [name of your repo]\ngit init #初始化本地仓库\ngit add xxx #添加要push到远程仓库的文件或文件夹\ngit commit -m ‘first commit’\ngit remote add origin https://github.com/yourgithubID/gitRepo.git #建立github远程仓库信息\ngit pull --rebase origin master #通过如下命令将远程代码合并到本地仓库（注：pull=fetch+merge)\n```\n\n### 第三步：本地代码上传github仓库\n\n```sh\ngit push -u origin master #将本地仓库push到远程仓库\n```\n","slug":"How-To-GitHub","published":1,"updated":"2018-12-03T07:00:57.883Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0mw40007rd4l846vvj3c","content":"<h3 id=\"第一步：在github上手动创建仓库-name-of-your-repo\"><a href=\"#第一步：在github上手动创建仓库-name-of-your-repo\" class=\"headerlink\" title=\"第一步：在github上手动创建仓库[name of your repo]\"></a>第一步：在github上手动创建仓库[name of your repo]</h3><p>GitHub Url(<a href=\"https://www.github.com\" target=\"_blank\" rel=\"noopener\">https://www.github.com</a>)</p>\n<h3 id=\"第二步：本地建立git仓库操作\"><a href=\"#第二步：本地建立git仓库操作\" class=\"headerlink\" title=\"第二步：本地建立git仓库操作\"></a>第二步：本地建立git仓库操作</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> [name of your repo]</span><br><span class=\"line\">git init <span class=\"comment\">#初始化本地仓库</span></span><br><span class=\"line\">git add xxx <span class=\"comment\">#添加要push到远程仓库的文件或文件夹</span></span><br><span class=\"line\">git commit -m ‘first commit’</span><br><span class=\"line\">git remote add origin https://github.com/yourgithubID/gitRepo.git <span class=\"comment\">#建立github远程仓库信息</span></span><br><span class=\"line\">git pull --rebase origin master <span class=\"comment\">#通过如下命令将远程代码合并到本地仓库（注：pull=fetch+merge)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步：本地代码上传github仓库\"><a href=\"#第三步：本地代码上传github仓库\" class=\"headerlink\" title=\"第三步：本地代码上传github仓库\"></a>第三步：本地代码上传github仓库</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master <span class=\"comment\">#将本地仓库push到远程仓库</span></span><br></pre></td></tr></table></figure>\n","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h3 id=\"第一步：在github上手动创建仓库-name-of-your-repo\"><a href=\"#第一步：在github上手动创建仓库-name-of-your-repo\" class=\"headerlink\" title=\"第一步：在github上手动创建仓库[name of your repo]\"></a>第一步：在github上手动创建仓库[name of your repo]</h3><p>GitHub Url(<a href=\"https://www.github.com\" target=\"_blank\" rel=\"noopener\">https://www.github.com</a>)</p>\n<h3 id=\"第二步：本地建立git仓库操作\"><a href=\"#第二步：本地建立git仓库操作\" class=\"headerlink\" title=\"第二步：本地建立git仓库操作\"></a>第二步：本地建立git仓库操作</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">cd</span> [name of your repo]</span><br><span class=\"line\">git init <span class=\"comment\">#初始化本地仓库</span></span><br><span class=\"line\">git add xxx <span class=\"comment\">#添加要push到远程仓库的文件或文件夹</span></span><br><span class=\"line\">git commit -m ‘first commit’</span><br><span class=\"line\">git remote add origin https://github.com/yourgithubID/gitRepo.git <span class=\"comment\">#建立github远程仓库信息</span></span><br><span class=\"line\">git pull --rebase origin master <span class=\"comment\">#通过如下命令将远程代码合并到本地仓库（注：pull=fetch+merge)</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"第三步：本地代码上传github仓库\"><a href=\"#第三步：本地代码上传github仓库\" class=\"headerlink\" title=\"第三步：本地代码上传github仓库\"></a>第三步：本地代码上传github仓库</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git push -u origin master <span class=\"comment\">#将本地仓库push到远程仓库</span></span><br></pre></td></tr></table></figure>\n"},{"title":"How To Hexo","date":"2016-11-28T07:59:00.000Z","_content":"\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Clean static files\n\n``` bash\n$ hexo clean\n```\n\n### Generate static files\n\n``` bash\n$ hexo g\n```\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to local server\n\n``` bash\n$ hexo d\n```\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n### Run local server\n\n``` bash\n$ hexo s\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n","source":"_posts/How-To-Hexo.md","raw":"title: How To Hexo\ntags:\n  - hexo\ncategories:\n  - hexo\ndate: 2016-11-28 16:59:00\n---\n\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Clean static files\n\n``` bash\n$ hexo clean\n```\n\n### Generate static files\n\n``` bash\n$ hexo g\n```\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to local server\n\n``` bash\n$ hexo d\n```\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n\n### Run local server\n\n``` bash\n$ hexo s\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n","slug":"How-To-Hexo","published":1,"updated":"2018-12-03T07:04:13.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0mw70008rd4lrywazq9i","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Clean-static-files\"><a href=\"#Clean-static-files\" class=\"headerlink\" title=\"Clean static files\"></a>Clean static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-local-server\"><a href=\"#Deploy-to-local-server\" class=\"headerlink\" title=\"Deploy to local server\"></a>Deploy to local server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<h3 id=\"Run-local-server\"><a href=\"#Run-local-server\" class=\"headerlink\" title=\"Run local server\"></a>Run local server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<div><h1>おススメ記事<span style=\"font-size:0.45em; color:gray\">（<a href=\"https://github.com/huiwang/hexo-recommended-posts\">hexo-recommend-posts</a>）</span></h1><ul><li><a href=\"https://cyouraku.github.io/2016/11/28/How-To-Next/\">How To Next</a></li></ul></div>","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Clean-static-files\"><a href=\"#Clean-static-files\" class=\"headerlink\" title=\"Clean static files\"></a>Clean static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo clean</span><br></pre></td></tr></table></figure>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo g</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-local-server\"><a href=\"#Deploy-to-local-server\" class=\"headerlink\" title=\"Deploy to local server\"></a>Deploy to local server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo d</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n<h3 id=\"Run-local-server\"><a href=\"#Run-local-server\" class=\"headerlink\" title=\"Run local server\"></a>Run local server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo s</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n"},{"title":"跟着日语分词器Kuromoji学习日语","author":"Tim Zhang","date":"2018-12-03T04:38:00.000Z","_content":"\n## Kuromoji简介\n\n> Kuromoji is an open source Japanese morphological analyzer written in Java.\n\n> Kuromoji has been donated to the Apache Software Foundation and provides the Japanese language support in Apache Lucene and Apache Solr 3.6 and 4.0 releases, but it can also be used separately.\n\n> Official Site Url(http://www.atilika.org/)\n\n\n\n## 下载Jar包\n\nKuromoji 0.7.7 (https://github.com/atilika/kuromoji/downloads)\n\n## 测试代码如下\n\n```java\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport org.atilika.kuromoji.Token;\nimport org.atilika.kuromoji.Tokenizer;\nimport org.atilika.kuromoji.Tokenizer.Builder;\n\n\n\npublic class KuromojiUtil {\n\n\tprivate static final Logger logger = Logger.getLogger(KuromojiUtil.class.getName());\n\n\tpublic static void main(String[] args) {\n\t\tlogger.info(\"testAnalyzerModeNormal start!\");\n\t\ttestAnalyzerModeNormal();\n\t}\n\n\t/**\n\t * 分词模式\n\t */\n\tpublic static void testAnalyzerModeNormal(){\n\t\tString word = \"日本経済新聞でモバゲーの記事を読んだ。\";\n\t\tBuilder builder = Tokenizer.builder();\n\n\t\t// Normal\n\t\tTokenizer normal = builder.build();\n\t\tList<Token> tokensNormal = normal.tokenize(word);\n\t\tdisp(tokensNormal);\n\t}\n\n\n\tpublic static void disp(List<Token> tokens){\n\t\tfor (Token token : tokens) {\n\t\t    System.out.println(\"==================================================\");\n\t\t    System.out.println(\"allFeatures : \" + token.getAllFeatures());\n\t\t    System.out.println(\"partOfSpeech : \" + token.getPartOfSpeech());\n\t\t    System.out.println(\"position : \" + token.getPosition());\n\t\t    System.out.println(\"reading : \" + token.getReading());\n\t\t    System.out.println(\"surfaceFrom : \" + token.getSurfaceForm());\n\t\t    System.out.println(\"allFeaturesArray : \" + Arrays.asList(token.getAllFeaturesArray()));\n\t\t    System.out.println(\"辞書にある言葉? : \" + token.isKnown());\n\t\t    System.out.println(\"未知語? : \" + token.isUnknown());\n\t\t    System.out.println(\"ユーザ定義? : \" + token.isUser());\n\t\t}\n\t}\n\n}\n```\n\n## 测试方法运行结果：\n\n```sh\n情報: testAnalyzerModeNormal start!\n==================================================\nallFeatures : 名詞,固有名詞,組織,*,*,*,日本経済新聞,ニホンケイザイシンブン,ニホンケイザイシンブン\npartOfSpeech : 名詞,固有名詞,組織,*\nposition : 0\nreading : ニホンケイザイシンブン\nsurfaceFrom : 日本経済新聞\nallFeaturesArray : [名詞, 固有名詞, 組織, *, *, *, 日本経済新聞, ニホンケイザイシンブン, ニホンケイザイシンブン]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 助詞,格助詞,一般,*,*,*,で,デ,デ\npartOfSpeech : 助詞,格助詞,一般,*\nposition : 6\nreading : デ\nsurfaceFrom : で\nallFeaturesArray : [助詞, 格助詞, 一般, *, *, *, で, デ, デ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 名詞,一般,*,*,*,*,*\npartOfSpeech : 名詞,一般,*,*\nposition : 7\nreading : null\nsurfaceFrom : モバゲー\nallFeaturesArray : [名詞, 一般, *, *, *, *, *]\n辞書にある言葉? : false\n未知語? : true\nユーザ定義? : false\n==================================================\nallFeatures : 助詞,連体化,*,*,*,*,の,ノ,ノ\npartOfSpeech : 助詞,連体化,*,*\nposition : 11\nreading : ノ\nsurfaceFrom : の\nallFeaturesArray : [助詞, 連体化, *, *, *, *, の, ノ, ノ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 名詞,一般,*,*,*,*,記事,キジ,キジ\npartOfSpeech : 名詞,一般,*,*\nposition : 12\nreading : キジ\nsurfaceFrom : 記事\nallFeaturesArray : [名詞, 一般, *, *, *, *, 記事, キジ, キジ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 助詞,格助詞,一般,*,*,*,を,ヲ,ヲ\npartOfSpeech : 助詞,格助詞,一般,*\nposition : 14\nreading : ヲ\nsurfaceFrom : を\nallFeaturesArray : [助詞, 格助詞, 一般, *, *, *, を, ヲ, ヲ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 動詞,自立,*,*,五段・マ行,連用タ接続,読む,ヨン,ヨン\npartOfSpeech : 動詞,自立,*,*\nposition : 15\nreading : ヨン\nsurfaceFrom : 読ん\nallFeaturesArray : [動詞, 自立, *, *, 五段・マ行, 連用タ接続, 読む, ヨン, ヨン]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 助動詞,*,*,*,特殊・タ,基本形,だ,ダ,ダ\npartOfSpeech : 助動詞,*,*,*\nposition : 17\nreading : ダ\nsurfaceFrom : だ\nallFeaturesArray : [助動詞, *, *, *, 特殊・タ, 基本形, だ, ダ, ダ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 記号,句点,*,*,*,*,。,。,。\npartOfSpeech : 記号,句点,*,*\nposition : 18\nreading : 。\nsurfaceFrom : 。\nallFeaturesArray : [記号, 句点, *, *, *, *, 。, 。, 。]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n```\n","source":"_posts/Japanese-Analyzer-Tool-Kuromoji.md","raw":"title: 跟着日语分词器Kuromoji学习日语\nauthor: Tim Zhang\ntags:\n  - 日语\n  - 分词\n  - Java\n  - Kuromoji\n  - Word Analyzer\ncategories:\n  - 日语\n  - Kuromoji\n  - Word Analyzer\n  - Java\ndate: 2018-12-03 13:38:00\n---\n\n## Kuromoji简介\n\n> Kuromoji is an open source Japanese morphological analyzer written in Java.\n\n> Kuromoji has been donated to the Apache Software Foundation and provides the Japanese language support in Apache Lucene and Apache Solr 3.6 and 4.0 releases, but it can also be used separately.\n\n> Official Site Url(http://www.atilika.org/)\n\n\n\n## 下载Jar包\n\nKuromoji 0.7.7 (https://github.com/atilika/kuromoji/downloads)\n\n## 测试代码如下\n\n```java\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.logging.Logger;\n\nimport org.atilika.kuromoji.Token;\nimport org.atilika.kuromoji.Tokenizer;\nimport org.atilika.kuromoji.Tokenizer.Builder;\n\n\n\npublic class KuromojiUtil {\n\n\tprivate static final Logger logger = Logger.getLogger(KuromojiUtil.class.getName());\n\n\tpublic static void main(String[] args) {\n\t\tlogger.info(\"testAnalyzerModeNormal start!\");\n\t\ttestAnalyzerModeNormal();\n\t}\n\n\t/**\n\t * 分词模式\n\t */\n\tpublic static void testAnalyzerModeNormal(){\n\t\tString word = \"日本経済新聞でモバゲーの記事を読んだ。\";\n\t\tBuilder builder = Tokenizer.builder();\n\n\t\t// Normal\n\t\tTokenizer normal = builder.build();\n\t\tList<Token> tokensNormal = normal.tokenize(word);\n\t\tdisp(tokensNormal);\n\t}\n\n\n\tpublic static void disp(List<Token> tokens){\n\t\tfor (Token token : tokens) {\n\t\t    System.out.println(\"==================================================\");\n\t\t    System.out.println(\"allFeatures : \" + token.getAllFeatures());\n\t\t    System.out.println(\"partOfSpeech : \" + token.getPartOfSpeech());\n\t\t    System.out.println(\"position : \" + token.getPosition());\n\t\t    System.out.println(\"reading : \" + token.getReading());\n\t\t    System.out.println(\"surfaceFrom : \" + token.getSurfaceForm());\n\t\t    System.out.println(\"allFeaturesArray : \" + Arrays.asList(token.getAllFeaturesArray()));\n\t\t    System.out.println(\"辞書にある言葉? : \" + token.isKnown());\n\t\t    System.out.println(\"未知語? : \" + token.isUnknown());\n\t\t    System.out.println(\"ユーザ定義? : \" + token.isUser());\n\t\t}\n\t}\n\n}\n```\n\n## 测试方法运行结果：\n\n```sh\n情報: testAnalyzerModeNormal start!\n==================================================\nallFeatures : 名詞,固有名詞,組織,*,*,*,日本経済新聞,ニホンケイザイシンブン,ニホンケイザイシンブン\npartOfSpeech : 名詞,固有名詞,組織,*\nposition : 0\nreading : ニホンケイザイシンブン\nsurfaceFrom : 日本経済新聞\nallFeaturesArray : [名詞, 固有名詞, 組織, *, *, *, 日本経済新聞, ニホンケイザイシンブン, ニホンケイザイシンブン]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 助詞,格助詞,一般,*,*,*,で,デ,デ\npartOfSpeech : 助詞,格助詞,一般,*\nposition : 6\nreading : デ\nsurfaceFrom : で\nallFeaturesArray : [助詞, 格助詞, 一般, *, *, *, で, デ, デ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 名詞,一般,*,*,*,*,*\npartOfSpeech : 名詞,一般,*,*\nposition : 7\nreading : null\nsurfaceFrom : モバゲー\nallFeaturesArray : [名詞, 一般, *, *, *, *, *]\n辞書にある言葉? : false\n未知語? : true\nユーザ定義? : false\n==================================================\nallFeatures : 助詞,連体化,*,*,*,*,の,ノ,ノ\npartOfSpeech : 助詞,連体化,*,*\nposition : 11\nreading : ノ\nsurfaceFrom : の\nallFeaturesArray : [助詞, 連体化, *, *, *, *, の, ノ, ノ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 名詞,一般,*,*,*,*,記事,キジ,キジ\npartOfSpeech : 名詞,一般,*,*\nposition : 12\nreading : キジ\nsurfaceFrom : 記事\nallFeaturesArray : [名詞, 一般, *, *, *, *, 記事, キジ, キジ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 助詞,格助詞,一般,*,*,*,を,ヲ,ヲ\npartOfSpeech : 助詞,格助詞,一般,*\nposition : 14\nreading : ヲ\nsurfaceFrom : を\nallFeaturesArray : [助詞, 格助詞, 一般, *, *, *, を, ヲ, ヲ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 動詞,自立,*,*,五段・マ行,連用タ接続,読む,ヨン,ヨン\npartOfSpeech : 動詞,自立,*,*\nposition : 15\nreading : ヨン\nsurfaceFrom : 読ん\nallFeaturesArray : [動詞, 自立, *, *, 五段・マ行, 連用タ接続, 読む, ヨン, ヨン]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 助動詞,*,*,*,特殊・タ,基本形,だ,ダ,ダ\npartOfSpeech : 助動詞,*,*,*\nposition : 17\nreading : ダ\nsurfaceFrom : だ\nallFeaturesArray : [助動詞, *, *, *, 特殊・タ, 基本形, だ, ダ, ダ]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n==================================================\nallFeatures : 記号,句点,*,*,*,*,。,。,。\npartOfSpeech : 記号,句点,*,*\nposition : 18\nreading : 。\nsurfaceFrom : 。\nallFeaturesArray : [記号, 句点, *, *, *, *, 。, 。, 。]\n辞書にある言葉? : true\n未知語? : false\nユーザ定義? : false\n```\n","slug":"Japanese-Analyzer-Tool-Kuromoji","published":1,"updated":"2018-12-03T05:16:41.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0mw90009rd4l4li1dp5s","content":"<h2 id=\"Kuromoji简介\"><a href=\"#Kuromoji简介\" class=\"headerlink\" title=\"Kuromoji简介\"></a>Kuromoji简介</h2><blockquote>\n<p>Kuromoji is an open source Japanese morphological analyzer written in Java.</p>\n</blockquote>\n<blockquote>\n<p>Kuromoji has been donated to the Apache Software Foundation and provides the Japanese language support in Apache Lucene and Apache Solr 3.6 and 4.0 releases, but it can also be used separately.</p>\n</blockquote>\n<blockquote>\n<p>Official Site Url(<a href=\"http://www.atilika.org/\" target=\"_blank\" rel=\"noopener\">http://www.atilika.org/</a>)</p>\n</blockquote>\n<h2 id=\"下载Jar包\"><a href=\"#下载Jar包\" class=\"headerlink\" title=\"下载Jar包\"></a>下载Jar包</h2><p>Kuromoji 0.7.7 (<a href=\"https://github.com/atilika/kuromoji/downloads\" target=\"_blank\" rel=\"noopener\">https://github.com/atilika/kuromoji/downloads</a>)</p>\n<h2 id=\"测试代码如下\"><a href=\"#测试代码如下\" class=\"headerlink\" title=\"测试代码如下\"></a>测试代码如下</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.atilika.kuromoji.Token;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.atilika.kuromoji.Tokenizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.atilika.kuromoji.Tokenizer.Builder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KuromojiUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(KuromojiUtil.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">\"testAnalyzerModeNormal start!\"</span>);</span><br><span class=\"line\">\t\ttestAnalyzerModeNormal();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 分词模式</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testAnalyzerModeNormal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tString word = <span class=\"string\">\"日本経済新聞でモバゲーの記事を読んだ。\"</span>;</span><br><span class=\"line\">\t\tBuilder builder = Tokenizer.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Normal</span></span><br><span class=\"line\">\t\tTokenizer normal = builder.build();</span><br><span class=\"line\">\t\tList&lt;Token&gt; tokensNormal = normal.tokenize(word);</span><br><span class=\"line\">\t\tdisp(tokensNormal);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">disp</span><span class=\"params\">(List&lt;Token&gt; tokens)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Token token : tokens) &#123;</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"==================================================\"</span>);</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"allFeatures : \"</span> + token.getAllFeatures());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"partOfSpeech : \"</span> + token.getPartOfSpeech());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"position : \"</span> + token.getPosition());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"reading : \"</span> + token.getReading());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"surfaceFrom : \"</span> + token.getSurfaceForm());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"allFeaturesArray : \"</span> + Arrays.asList(token.getAllFeaturesArray()));</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"辞書にある言葉? : \"</span> + token.isKnown());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"未知語? : \"</span> + token.isUnknown());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"ユーザ定義? : \"</span> + token.isUser());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试方法运行结果：\"><a href=\"#测试方法运行结果：\" class=\"headerlink\" title=\"测试方法运行结果：\"></a>测试方法运行结果：</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">情報: testAnalyzerModeNormal start!</span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 名詞,固有名詞,組織,*,*,*,日本経済新聞,ニホンケイザイシンブン,ニホンケイザイシンブン</span><br><span class=\"line\">partOfSpeech : 名詞,固有名詞,組織,*</span><br><span class=\"line\">position : 0</span><br><span class=\"line\">reading : ニホンケイザイシンブン</span><br><span class=\"line\">surfaceFrom : 日本経済新聞</span><br><span class=\"line\">allFeaturesArray : [名詞, 固有名詞, 組織, *, *, *, 日本経済新聞, ニホンケイザイシンブン, ニホンケイザイシンブン]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助詞,格助詞,一般,*,*,*,で,デ,デ</span><br><span class=\"line\">partOfSpeech : 助詞,格助詞,一般,*</span><br><span class=\"line\">position : 6</span><br><span class=\"line\">reading : デ</span><br><span class=\"line\">surfaceFrom : で</span><br><span class=\"line\">allFeaturesArray : [助詞, 格助詞, 一般, *, *, *, で, デ, デ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 名詞,一般,*,*,*,*,*</span><br><span class=\"line\">partOfSpeech : 名詞,一般,*,*</span><br><span class=\"line\">position : 7</span><br><span class=\"line\">reading : null</span><br><span class=\"line\">surfaceFrom : モバゲー</span><br><span class=\"line\">allFeaturesArray : [名詞, 一般, *, *, *, *, *]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">false</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">true</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助詞,連体化,*,*,*,*,の,ノ,ノ</span><br><span class=\"line\">partOfSpeech : 助詞,連体化,*,*</span><br><span class=\"line\">position : 11</span><br><span class=\"line\">reading : ノ</span><br><span class=\"line\">surfaceFrom : の</span><br><span class=\"line\">allFeaturesArray : [助詞, 連体化, *, *, *, *, の, ノ, ノ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 名詞,一般,*,*,*,*,記事,キジ,キジ</span><br><span class=\"line\">partOfSpeech : 名詞,一般,*,*</span><br><span class=\"line\">position : 12</span><br><span class=\"line\">reading : キジ</span><br><span class=\"line\">surfaceFrom : 記事</span><br><span class=\"line\">allFeaturesArray : [名詞, 一般, *, *, *, *, 記事, キジ, キジ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助詞,格助詞,一般,*,*,*,を,ヲ,ヲ</span><br><span class=\"line\">partOfSpeech : 助詞,格助詞,一般,*</span><br><span class=\"line\">position : 14</span><br><span class=\"line\">reading : ヲ</span><br><span class=\"line\">surfaceFrom : を</span><br><span class=\"line\">allFeaturesArray : [助詞, 格助詞, 一般, *, *, *, を, ヲ, ヲ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 動詞,自立,*,*,五段・マ行,連用タ接続,読む,ヨン,ヨン</span><br><span class=\"line\">partOfSpeech : 動詞,自立,*,*</span><br><span class=\"line\">position : 15</span><br><span class=\"line\">reading : ヨン</span><br><span class=\"line\">surfaceFrom : 読ん</span><br><span class=\"line\">allFeaturesArray : [動詞, 自立, *, *, 五段・マ行, 連用タ接続, 読む, ヨン, ヨン]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助動詞,*,*,*,特殊・タ,基本形,だ,ダ,ダ</span><br><span class=\"line\">partOfSpeech : 助動詞,*,*,*</span><br><span class=\"line\">position : 17</span><br><span class=\"line\">reading : ダ</span><br><span class=\"line\">surfaceFrom : だ</span><br><span class=\"line\">allFeaturesArray : [助動詞, *, *, *, 特殊・タ, 基本形, だ, ダ, ダ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 記号,句点,*,*,*,*,。,。,。</span><br><span class=\"line\">partOfSpeech : 記号,句点,*,*</span><br><span class=\"line\">position : 18</span><br><span class=\"line\">reading : 。</span><br><span class=\"line\">surfaceFrom : 。</span><br><span class=\"line\">allFeaturesArray : [記号, 句点, *, *, *, *, 。, 。, 。]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n<div><h1>おススメ記事<span style=\"font-size:0.45em; color:gray\">（<a href=\"https://github.com/huiwang/hexo-recommended-posts\">hexo-recommend-posts</a>）</span></h1><ul><li><a href=\"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/\">好用的中文分词工具AnsjSeq</a></li><li><a href=\"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/\">好用的中文分词工具AnsjSeq</a></li><li><a href=\"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/\">好用的中文分词工具AnsjSeq</a></li><li><a href=\"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/\">我要系列｜学习循环的必要基础</a></li></ul></div>","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"Kuromoji简介\"><a href=\"#Kuromoji简介\" class=\"headerlink\" title=\"Kuromoji简介\"></a>Kuromoji简介</h2><blockquote>\n<p>Kuromoji is an open source Japanese morphological analyzer written in Java.</p>\n</blockquote>\n<blockquote>\n<p>Kuromoji has been donated to the Apache Software Foundation and provides the Japanese language support in Apache Lucene and Apache Solr 3.6 and 4.0 releases, but it can also be used separately.</p>\n</blockquote>\n<blockquote>\n<p>Official Site Url(<a href=\"http://www.atilika.org/\" target=\"_blank\" rel=\"noopener\">http://www.atilika.org/</a>)</p>\n</blockquote>\n<h2 id=\"下载Jar包\"><a href=\"#下载Jar包\" class=\"headerlink\" title=\"下载Jar包\"></a>下载Jar包</h2><p>Kuromoji 0.7.7 (<a href=\"https://github.com/atilika/kuromoji/downloads\" target=\"_blank\" rel=\"noopener\">https://github.com/atilika/kuromoji/downloads</a>)</p>\n<h2 id=\"测试代码如下\"><a href=\"#测试代码如下\" class=\"headerlink\" title=\"测试代码如下\"></a>测试代码如下</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.atilika.kuromoji.Token;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.atilika.kuromoji.Tokenizer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.atilika.kuromoji.Tokenizer.Builder;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">KuromojiUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(KuromojiUtil.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">\t\tlogger.info(<span class=\"string\">\"testAnalyzerModeNormal start!\"</span>);</span><br><span class=\"line\">\t\ttestAnalyzerModeNormal();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * 分词模式</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testAnalyzerModeNormal</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tString word = <span class=\"string\">\"日本経済新聞でモバゲーの記事を読んだ。\"</span>;</span><br><span class=\"line\">\t\tBuilder builder = Tokenizer.builder();</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">// Normal</span></span><br><span class=\"line\">\t\tTokenizer normal = builder.build();</span><br><span class=\"line\">\t\tList&lt;Token&gt; tokensNormal = normal.tokenize(word);</span><br><span class=\"line\">\t\tdisp(tokensNormal);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">disp</span><span class=\"params\">(List&lt;Token&gt; tokens)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (Token token : tokens) &#123;</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"==================================================\"</span>);</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"allFeatures : \"</span> + token.getAllFeatures());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"partOfSpeech : \"</span> + token.getPartOfSpeech());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"position : \"</span> + token.getPosition());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"reading : \"</span> + token.getReading());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"surfaceFrom : \"</span> + token.getSurfaceForm());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"allFeaturesArray : \"</span> + Arrays.asList(token.getAllFeaturesArray()));</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"辞書にある言葉? : \"</span> + token.isKnown());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"未知語? : \"</span> + token.isUnknown());</span><br><span class=\"line\">\t\t    System.out.println(<span class=\"string\">\"ユーザ定義? : \"</span> + token.isUser());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试方法运行结果：\"><a href=\"#测试方法运行结果：\" class=\"headerlink\" title=\"测试方法运行结果：\"></a>测试方法运行结果：</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">情報: testAnalyzerModeNormal start!</span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 名詞,固有名詞,組織,*,*,*,日本経済新聞,ニホンケイザイシンブン,ニホンケイザイシンブン</span><br><span class=\"line\">partOfSpeech : 名詞,固有名詞,組織,*</span><br><span class=\"line\">position : 0</span><br><span class=\"line\">reading : ニホンケイザイシンブン</span><br><span class=\"line\">surfaceFrom : 日本経済新聞</span><br><span class=\"line\">allFeaturesArray : [名詞, 固有名詞, 組織, *, *, *, 日本経済新聞, ニホンケイザイシンブン, ニホンケイザイシンブン]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助詞,格助詞,一般,*,*,*,で,デ,デ</span><br><span class=\"line\">partOfSpeech : 助詞,格助詞,一般,*</span><br><span class=\"line\">position : 6</span><br><span class=\"line\">reading : デ</span><br><span class=\"line\">surfaceFrom : で</span><br><span class=\"line\">allFeaturesArray : [助詞, 格助詞, 一般, *, *, *, で, デ, デ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 名詞,一般,*,*,*,*,*</span><br><span class=\"line\">partOfSpeech : 名詞,一般,*,*</span><br><span class=\"line\">position : 7</span><br><span class=\"line\">reading : null</span><br><span class=\"line\">surfaceFrom : モバゲー</span><br><span class=\"line\">allFeaturesArray : [名詞, 一般, *, *, *, *, *]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">false</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">true</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助詞,連体化,*,*,*,*,の,ノ,ノ</span><br><span class=\"line\">partOfSpeech : 助詞,連体化,*,*</span><br><span class=\"line\">position : 11</span><br><span class=\"line\">reading : ノ</span><br><span class=\"line\">surfaceFrom : の</span><br><span class=\"line\">allFeaturesArray : [助詞, 連体化, *, *, *, *, の, ノ, ノ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 名詞,一般,*,*,*,*,記事,キジ,キジ</span><br><span class=\"line\">partOfSpeech : 名詞,一般,*,*</span><br><span class=\"line\">position : 12</span><br><span class=\"line\">reading : キジ</span><br><span class=\"line\">surfaceFrom : 記事</span><br><span class=\"line\">allFeaturesArray : [名詞, 一般, *, *, *, *, 記事, キジ, キジ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助詞,格助詞,一般,*,*,*,を,ヲ,ヲ</span><br><span class=\"line\">partOfSpeech : 助詞,格助詞,一般,*</span><br><span class=\"line\">position : 14</span><br><span class=\"line\">reading : ヲ</span><br><span class=\"line\">surfaceFrom : を</span><br><span class=\"line\">allFeaturesArray : [助詞, 格助詞, 一般, *, *, *, を, ヲ, ヲ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 動詞,自立,*,*,五段・マ行,連用タ接続,読む,ヨン,ヨン</span><br><span class=\"line\">partOfSpeech : 動詞,自立,*,*</span><br><span class=\"line\">position : 15</span><br><span class=\"line\">reading : ヨン</span><br><span class=\"line\">surfaceFrom : 読ん</span><br><span class=\"line\">allFeaturesArray : [動詞, 自立, *, *, 五段・マ行, 連用タ接続, 読む, ヨン, ヨン]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 助動詞,*,*,*,特殊・タ,基本形,だ,ダ,ダ</span><br><span class=\"line\">partOfSpeech : 助動詞,*,*,*</span><br><span class=\"line\">position : 17</span><br><span class=\"line\">reading : ダ</span><br><span class=\"line\">surfaceFrom : だ</span><br><span class=\"line\">allFeaturesArray : [助動詞, *, *, *, 特殊・タ, 基本形, だ, ダ, ダ]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br><span class=\"line\">==================================================</span><br><span class=\"line\">allFeatures : 記号,句点,*,*,*,*,。,。,。</span><br><span class=\"line\">partOfSpeech : 記号,句点,*,*</span><br><span class=\"line\">position : 18</span><br><span class=\"line\">reading : 。</span><br><span class=\"line\">surfaceFrom : 。</span><br><span class=\"line\">allFeaturesArray : [記号, 句点, *, *, *, *, 。, 。, 。]</span><br><span class=\"line\">辞書にある言葉? : <span class=\"literal\">true</span></span><br><span class=\"line\">未知語? : <span class=\"literal\">false</span></span><br><span class=\"line\">ユーザ定義? : <span class=\"literal\">false</span></span><br></pre></td></tr></table></figure>\n"},{"title":"好用的中文分词工具AnsjSeq","author":"Tim Zhang","date":"2018-11-30T08:37:00.000Z","_content":"## AnsjSeq简介\n\n> 这是一个基于n-Gram+CRF+HMM的中文分词的java实现.\n\n> 分词速度达到每秒钟大约200万字左右（mac air下测试），准确率能达到96%以上\n\n> 目前实现了.中文分词. 中文姓名识别 . 用户自定义词典,关键字提取，自动摘要，关键字标记等功能\n\n> 可以应用到自然语言处理等方面,适用于对分词效果要求高的各种项目.\n\n> Official Site Url(https://raw.githubusercontent.com/NLPchina/ansj_seg)\n\n## 加载Maven依赖：\n\n```xml \n<dependency>\n     <groupId>org.ansj</groupId>\n     <artifactId>ansj_seg</artifactId>\n     <version>5.1.1</version>\n</dependency>\n\n```\n\n## 测试代码如下：\n\n```java\nimport java.io.BufferedReader;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.logging.Logger;\n\nimport org.ansj.app.crf.Model;\nimport org.ansj.app.crf.model.CRFModel;\nimport org.ansj.app.keyword.KeyWordComputer;\nimport org.ansj.app.keyword.Keyword;\nimport org.ansj.dic.LearnTool;\nimport org.ansj.domain.Nature;\nimport org.ansj.domain.NewWord;\nimport org.ansj.domain.Result;\nimport org.ansj.splitWord.analysis.NlpAnalysis;\nimport org.ansj.splitWord.analysis.ToAnalysis;\nimport org.nlpcn.commons.lang.tire.GetWord;\nimport org.nlpcn.commons.lang.tire.domain.Forest;\nimport org.nlpcn.commons.lang.tire.library.Library;\nimport org.nlpcn.commons.lang.util.IOUtil;\n\npublic class AnsjSegUtil {\n\n\tprivate static final Logger logger = Logger.getLogger(AnsjSegUtil.class.getName());\n\n\tprivate static String testStr = \"欢迎使用ansj_seg,(ansj中文分词)在这里如果你遇到什么问题都可以联系我.我一定尽我所能.帮助大家.ansj_seg更快,更准,更自由!\";\n\n\tpublic static void main(String[] args) {\n\n\t\ttestFindKeyword();\n\n\t}\n\n\tprivate static void testTreeSplitDemo() throws Exception{\n        /**\n         * 词典的构造.一行一个词后面是参数.可以从文件读取.可以是read流.\n         */\n        String dic = \"中国\\t1\\tzg\\n人名\\t2\\n中国人民\\t4\\n人民\\t3\\n孙健\\t5\\nCSDN\\t6\\njava\\t7\\njava学习\\t10\\n\";\n        Forest forest = Library.makeForest(new BufferedReader(new StringReader(dic)));\n        /**\n         * 删除一个单词\n         */\n        Library.removeWord(forest, \"中国\");\n        /**\n         * 增加一个新词\n         */\n        Library.insertWord(forest, \"中国人\");\n        String content = \"中国人名识别是中国人民的一个骄傲.孙健人民在CSDN中学到了很多最早iteye是java学习笔记叫javaeye但是java123只是一部分\";\n        GetWord udg = forest.getWord(content);\n        String temp = null;\n        while ((temp = udg.getFrontWords()) != null)\n            System.out.println(temp + \"\\t\\t\" + udg.getParam(1) + \"\\t\\t\" + udg.getParam(2));\n\t}\n\n\tprivate static void testFindKeyword(){\n\t    String title = \"维基解密否认斯诺登接受委内瑞拉庇护\";\n\t    String content = \"有俄罗斯国会议员，9号在社交网站推特表示，美国中情局前雇员斯诺登，已经接受委内瑞拉的庇护，不过推文在发布几分钟后随即删除。俄罗斯当局拒绝发表评论，而一直协助斯诺登的维基解密否认他将投靠委内瑞拉。　　俄罗斯国会国际事务委员会主席普什科夫，在个人推特率先披露斯诺登已接受委内瑞拉的庇护建议，令外界以为斯诺登的动向终于有新进展。　　不过推文在几分钟内旋即被删除，普什科夫澄清他是看到俄罗斯国营电视台的新闻才这样说，而电视台已经作出否认，称普什科夫是误解了新闻内容。　　委内瑞拉驻莫斯科大使馆、俄罗斯总统府发言人、以及外交部都拒绝发表评论。而维基解密就否认斯诺登已正式接受委内瑞拉的庇护，说会在适当时间公布有关决定。　　斯诺登相信目前还在莫斯科谢列梅捷沃机场，已滞留两个多星期。他早前向约20个国家提交庇护申请，委内瑞拉、尼加拉瓜和玻利维亚，先后表示答应，不过斯诺登还没作出决定。　　而另一场外交风波，玻利维亚总统莫拉莱斯的专机上星期被欧洲多国以怀疑斯诺登在机上为由拒绝过境事件，涉事国家之一的西班牙突然转口风，外长马加略]号表示愿意就任何误解致歉，但强调当时当局没有关闭领空或不许专机降落。\";\n\t\tCollection<Keyword> result = findKeyWords(title,content);\n\t\tfor(Keyword kw : result){\n\t\t\tSystem.out.println(\"name = \" + kw.getName() + \" freq = \" + kw.getFreq() + \" score = \" + kw.getScore());\n\t\t}\n\t}\n\n\tprivate static void addNewWordDemo(){\n        // 增加新词,中间按照'\\t'隔开\n//        UserDefineLibrary.insertWord(\"ansj中文分词\", \"userDefine\", 1000);\n        Result terms = ToAnalysis.parse(\"我觉得Ansj中文分词是一个不错的系统!我是王婆!\");\n        System.out.println(\"增加新词例子:\" + terms);\n        // 删除词语,只能删除.用户自定义的词典.\n//        UserDefineLibrary.removeWord(\"ansj中文分词\");\n        terms = ToAnalysis.parse(\"我觉得ansj中文分词是一个不错的系统!我是王婆!\");\n        System.out.println(\"删除用户自定义词典例子:\" + terms);\n\t}\n\n\tprivate static void learnToolDemo(){\n        //构建一个新词学习的工具类。这个对象。保存了所有分词中出现的新词。出现次数越多。相对权重越大。\n        LearnTool learnTool = new LearnTool() ;\n        Forest forest = new Forest();\n        //进行词语分词。也就是nlp方式分词，这里可以分多篇文章\n//        NlpAnalysis.parse(\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\", learnTool) ;\n//        NlpAnalysis.parse(\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\", learnTool) ;\n//        NlpAnalysis.parse(\"张艺谋的卡宴，马明哲的戏\",learnTool) ;\n        NlpAnalysis.parse(\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\", forest) ;\n        NlpAnalysis.parse(\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\", forest) ;\n        NlpAnalysis.parse(\"张艺谋的卡宴，马明哲的戏\",forest) ;\n\t\tfor (String str : forest.getParams()) {\n\t\t\tlogger.info(str);\n\t\t}\n//        new NewWord(String,Nature,Double);\n        //取得学习到的topn新词,返回前10个。这里如果设置为0则返回全部\n        System.out.println(learnTool.getTopTree(10));\n\n        //只取得词性为Nature.NR的新词\n        System.out.println(learnTool.getTopTree(10,Nature.NR));\n\t}\n\n\tprivate static void testParse(){\n\t\tSystem.out.println(ToAnalysis.parse(testStr));\n\t\t// Expect as below:\n\t\t// 欢迎/v,使用/v,ansj/en,_,seg/en,,,(,ansj/en,中文/nz,分词/n,),在/p,这里/r,如果/c,你/r,遇到/v,什么/r,问题/n,都/d,可以/v,联系/v,我/r,./m,我/r,一定/d,尽我所能/l,./m,帮助/v,大家/r,./m,ansj/en,_,seg/en,更快/d,,,更/d,准/a,,,更/d,自由/a,!\n\n\t\t//parseString 2:\n\t\ttestStr = \"结婚的和尚未结婚的\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//parseString 2:\n\t\ttestStr = \"结合成分子时\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//交叉歧义（多种切分交织在一起）：内塔内亚胡说的/确实/在理\n\t\ttestStr = \"内塔内亚胡说的确实在理\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\t\ttestStr = \"内塔内亚说的确实在理\";\n\t\tSystem.out.println(parseNlp(testStr));\n\n\t\t//组合歧义（不同情况下切分不同）：这个人/手上有痣、我们公司人手\n\t\ttestStr = \"这个人手上有痣、我们公司人手\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//真歧义（几种切分都可以）：乒乓球拍/卖/完了、乒乓球/拍卖/完了\n\t\ttestStr = \"乒乓球拍卖完了、乒乓球拍卖完了\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//synonyms test\n\t\ttestStr = \"我家外戚和远房亲戚是一个意思吗？\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//亲家母亲家公\n\t\ttestStr = \"亲家母亲家公\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\t}\n\n\t/**\n\t * accurate parse with nature\n\t * @param str\n\t * @return\n\t */\n\tpublic static String parseStrInput(String str){\n\t\treturn ToAnalysis.parse(str).toString();\n\t}\n\n\t/**\n\t * accurate parse without nature\n\t * @param str\n\t * @return\n\t */\n\tpublic static String parseStrInputWithOutNature(String str){\n\t\treturn ToAnalysis.parse(str).toStringWithOutNature();\n\t}\n\n\t/**\n\t * nlp parse with nature\n\t * @param str\n\t * @return\n\t */\n\tpublic static String parseNlp(String str){\n\t\treturn NlpAnalysis.parse(str).toString();\n\t}\n\n\t/**\n\t * Write trained result to file\n\t * /home/ansj/temp/learnTool.snap\n\t * @param filePath\n\t * @param learnTool\n\t */\n\tpublic static void writeTrainedResultToFile(String filePath, LearnTool learnTool){\n\t\t  List<Entry<String, Double>> topTree = learnTool.getTopTree(0);\n\t\t  StringBuilder sb = new StringBuilder();\n\t\t  for (Entry<String, Double> entry : topTree) {\n\t\t      sb.append(entry.getKey() + \"\\t\" + entry.getValue()+\"\\n\");\n\t\t  }\n\t\t  IOUtil.Writer(filePath, IOUtil.UTF8, sb.toString());\n\t\t  sb = null;\n\t}\n\n\t/**\n\t * Read trained result from file\n\t * /home/ansj/temp/learnTool.snap\n\t * @param filePath\n\t * @throws UnsupportedEncodingException\n\t */\n\tpublic static LearnTool readTrainedResultFrFile(String filePath) throws UnsupportedEncodingException{\n\t\t  LearnTool learnTool = new LearnTool() ;\n\t\t  HashMap<String, Double> loadMap = IOUtil.loadMap(filePath, IOUtil.UTF8, String.class, Double.class);\n\t\t  for (Entry<String, Double> entry : loadMap.entrySet()) {\n\t\t      learnTool.addTerm(new NewWord(entry.getKey(), Nature.NW, entry.getValue())) ;\n\t\t      learnTool.active(entry.getKey()) ;\n\t\t  }\n\t\t  //Debug:\n\t\t  logger.info(String.format(\"Top 10 new words = %s\",learnTool.getTopTree(10).toString()));\n\t\t  return learnTool;\n\t}\n\n\n\t/**\n\t * Find keywords from title and content\n\t * @param title\n\t * @param content\n\t * @return\n\t */\n\tpublic static Collection<Keyword> findKeyWords(String title, String content){\n\t    KeyWordComputer kwc = new KeyWordComputer(5);\n\t\treturn kwc.computeArticleTfidf(title, content);\n\t}\n\n\n\tpublic static void trainCrfModel() throws Exception{\n\t\tModel model = CRFModel.load(\"D:/tmp/sn/model.txt\");\n\t\tmodel.writeModel(\"D:/tmp/sn/crf.model\");\n\t}\n}\n\n```\n\n## 测试方法运行结果：\n\n```sh\nname = 斯诺登 freq = 9 score = 211.83897497289786\nname = 维基 freq = 3 score = 163.46869316143392\nname = 委内瑞拉 freq = 7 score = 101.31414008144232\nname = 庇护 freq = 5 score = 46.05172894231714\nname = 普什科夫 freq = 3 score = 40.66920082459204\n\n```\n","source":"_posts/An-Easy-To-Use-Analyzer-Tool-AnjSeq.md","raw":"title: 好用的中文分词工具AnsjSeq\nauthor: Tim Zhang\ntags:\n  - AnsjSeq\n  - 分词\n  - Word Analyzer\n  - Java\ncategories:\n  - AnsjSeq\n  - Word Analyzer\n  - Java\ndate: 2018-11-30 17:37:00\n---\n## AnsjSeq简介\n\n> 这是一个基于n-Gram+CRF+HMM的中文分词的java实现.\n\n> 分词速度达到每秒钟大约200万字左右（mac air下测试），准确率能达到96%以上\n\n> 目前实现了.中文分词. 中文姓名识别 . 用户自定义词典,关键字提取，自动摘要，关键字标记等功能\n\n> 可以应用到自然语言处理等方面,适用于对分词效果要求高的各种项目.\n\n> Official Site Url(https://raw.githubusercontent.com/NLPchina/ansj_seg)\n\n## 加载Maven依赖：\n\n```xml \n<dependency>\n     <groupId>org.ansj</groupId>\n     <artifactId>ansj_seg</artifactId>\n     <version>5.1.1</version>\n</dependency>\n\n```\n\n## 测试代码如下：\n\n```java\nimport java.io.BufferedReader;\nimport java.io.StringReader;\nimport java.io.UnsupportedEncodingException;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.logging.Logger;\n\nimport org.ansj.app.crf.Model;\nimport org.ansj.app.crf.model.CRFModel;\nimport org.ansj.app.keyword.KeyWordComputer;\nimport org.ansj.app.keyword.Keyword;\nimport org.ansj.dic.LearnTool;\nimport org.ansj.domain.Nature;\nimport org.ansj.domain.NewWord;\nimport org.ansj.domain.Result;\nimport org.ansj.splitWord.analysis.NlpAnalysis;\nimport org.ansj.splitWord.analysis.ToAnalysis;\nimport org.nlpcn.commons.lang.tire.GetWord;\nimport org.nlpcn.commons.lang.tire.domain.Forest;\nimport org.nlpcn.commons.lang.tire.library.Library;\nimport org.nlpcn.commons.lang.util.IOUtil;\n\npublic class AnsjSegUtil {\n\n\tprivate static final Logger logger = Logger.getLogger(AnsjSegUtil.class.getName());\n\n\tprivate static String testStr = \"欢迎使用ansj_seg,(ansj中文分词)在这里如果你遇到什么问题都可以联系我.我一定尽我所能.帮助大家.ansj_seg更快,更准,更自由!\";\n\n\tpublic static void main(String[] args) {\n\n\t\ttestFindKeyword();\n\n\t}\n\n\tprivate static void testTreeSplitDemo() throws Exception{\n        /**\n         * 词典的构造.一行一个词后面是参数.可以从文件读取.可以是read流.\n         */\n        String dic = \"中国\\t1\\tzg\\n人名\\t2\\n中国人民\\t4\\n人民\\t3\\n孙健\\t5\\nCSDN\\t6\\njava\\t7\\njava学习\\t10\\n\";\n        Forest forest = Library.makeForest(new BufferedReader(new StringReader(dic)));\n        /**\n         * 删除一个单词\n         */\n        Library.removeWord(forest, \"中国\");\n        /**\n         * 增加一个新词\n         */\n        Library.insertWord(forest, \"中国人\");\n        String content = \"中国人名识别是中国人民的一个骄傲.孙健人民在CSDN中学到了很多最早iteye是java学习笔记叫javaeye但是java123只是一部分\";\n        GetWord udg = forest.getWord(content);\n        String temp = null;\n        while ((temp = udg.getFrontWords()) != null)\n            System.out.println(temp + \"\\t\\t\" + udg.getParam(1) + \"\\t\\t\" + udg.getParam(2));\n\t}\n\n\tprivate static void testFindKeyword(){\n\t    String title = \"维基解密否认斯诺登接受委内瑞拉庇护\";\n\t    String content = \"有俄罗斯国会议员，9号在社交网站推特表示，美国中情局前雇员斯诺登，已经接受委内瑞拉的庇护，不过推文在发布几分钟后随即删除。俄罗斯当局拒绝发表评论，而一直协助斯诺登的维基解密否认他将投靠委内瑞拉。　　俄罗斯国会国际事务委员会主席普什科夫，在个人推特率先披露斯诺登已接受委内瑞拉的庇护建议，令外界以为斯诺登的动向终于有新进展。　　不过推文在几分钟内旋即被删除，普什科夫澄清他是看到俄罗斯国营电视台的新闻才这样说，而电视台已经作出否认，称普什科夫是误解了新闻内容。　　委内瑞拉驻莫斯科大使馆、俄罗斯总统府发言人、以及外交部都拒绝发表评论。而维基解密就否认斯诺登已正式接受委内瑞拉的庇护，说会在适当时间公布有关决定。　　斯诺登相信目前还在莫斯科谢列梅捷沃机场，已滞留两个多星期。他早前向约20个国家提交庇护申请，委内瑞拉、尼加拉瓜和玻利维亚，先后表示答应，不过斯诺登还没作出决定。　　而另一场外交风波，玻利维亚总统莫拉莱斯的专机上星期被欧洲多国以怀疑斯诺登在机上为由拒绝过境事件，涉事国家之一的西班牙突然转口风，外长马加略]号表示愿意就任何误解致歉，但强调当时当局没有关闭领空或不许专机降落。\";\n\t\tCollection<Keyword> result = findKeyWords(title,content);\n\t\tfor(Keyword kw : result){\n\t\t\tSystem.out.println(\"name = \" + kw.getName() + \" freq = \" + kw.getFreq() + \" score = \" + kw.getScore());\n\t\t}\n\t}\n\n\tprivate static void addNewWordDemo(){\n        // 增加新词,中间按照'\\t'隔开\n//        UserDefineLibrary.insertWord(\"ansj中文分词\", \"userDefine\", 1000);\n        Result terms = ToAnalysis.parse(\"我觉得Ansj中文分词是一个不错的系统!我是王婆!\");\n        System.out.println(\"增加新词例子:\" + terms);\n        // 删除词语,只能删除.用户自定义的词典.\n//        UserDefineLibrary.removeWord(\"ansj中文分词\");\n        terms = ToAnalysis.parse(\"我觉得ansj中文分词是一个不错的系统!我是王婆!\");\n        System.out.println(\"删除用户自定义词典例子:\" + terms);\n\t}\n\n\tprivate static void learnToolDemo(){\n        //构建一个新词学习的工具类。这个对象。保存了所有分词中出现的新词。出现次数越多。相对权重越大。\n        LearnTool learnTool = new LearnTool() ;\n        Forest forest = new Forest();\n        //进行词语分词。也就是nlp方式分词，这里可以分多篇文章\n//        NlpAnalysis.parse(\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\", learnTool) ;\n//        NlpAnalysis.parse(\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\", learnTool) ;\n//        NlpAnalysis.parse(\"张艺谋的卡宴，马明哲的戏\",learnTool) ;\n        NlpAnalysis.parse(\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\", forest) ;\n        NlpAnalysis.parse(\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\", forest) ;\n        NlpAnalysis.parse(\"张艺谋的卡宴，马明哲的戏\",forest) ;\n\t\tfor (String str : forest.getParams()) {\n\t\t\tlogger.info(str);\n\t\t}\n//        new NewWord(String,Nature,Double);\n        //取得学习到的topn新词,返回前10个。这里如果设置为0则返回全部\n        System.out.println(learnTool.getTopTree(10));\n\n        //只取得词性为Nature.NR的新词\n        System.out.println(learnTool.getTopTree(10,Nature.NR));\n\t}\n\n\tprivate static void testParse(){\n\t\tSystem.out.println(ToAnalysis.parse(testStr));\n\t\t// Expect as below:\n\t\t// 欢迎/v,使用/v,ansj/en,_,seg/en,,,(,ansj/en,中文/nz,分词/n,),在/p,这里/r,如果/c,你/r,遇到/v,什么/r,问题/n,都/d,可以/v,联系/v,我/r,./m,我/r,一定/d,尽我所能/l,./m,帮助/v,大家/r,./m,ansj/en,_,seg/en,更快/d,,,更/d,准/a,,,更/d,自由/a,!\n\n\t\t//parseString 2:\n\t\ttestStr = \"结婚的和尚未结婚的\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//parseString 2:\n\t\ttestStr = \"结合成分子时\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//交叉歧义（多种切分交织在一起）：内塔内亚胡说的/确实/在理\n\t\ttestStr = \"内塔内亚胡说的确实在理\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\t\ttestStr = \"内塔内亚说的确实在理\";\n\t\tSystem.out.println(parseNlp(testStr));\n\n\t\t//组合歧义（不同情况下切分不同）：这个人/手上有痣、我们公司人手\n\t\ttestStr = \"这个人手上有痣、我们公司人手\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//真歧义（几种切分都可以）：乒乓球拍/卖/完了、乒乓球/拍卖/完了\n\t\ttestStr = \"乒乓球拍卖完了、乒乓球拍卖完了\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//synonyms test\n\t\ttestStr = \"我家外戚和远房亲戚是一个意思吗？\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\n\t\t//亲家母亲家公\n\t\ttestStr = \"亲家母亲家公\";\n\t\tSystem.out.println(parseStrInput(testStr));\n\t\tSystem.out.println(parseStrInputWithOutNature(testStr));\n\t}\n\n\t/**\n\t * accurate parse with nature\n\t * @param str\n\t * @return\n\t */\n\tpublic static String parseStrInput(String str){\n\t\treturn ToAnalysis.parse(str).toString();\n\t}\n\n\t/**\n\t * accurate parse without nature\n\t * @param str\n\t * @return\n\t */\n\tpublic static String parseStrInputWithOutNature(String str){\n\t\treturn ToAnalysis.parse(str).toStringWithOutNature();\n\t}\n\n\t/**\n\t * nlp parse with nature\n\t * @param str\n\t * @return\n\t */\n\tpublic static String parseNlp(String str){\n\t\treturn NlpAnalysis.parse(str).toString();\n\t}\n\n\t/**\n\t * Write trained result to file\n\t * /home/ansj/temp/learnTool.snap\n\t * @param filePath\n\t * @param learnTool\n\t */\n\tpublic static void writeTrainedResultToFile(String filePath, LearnTool learnTool){\n\t\t  List<Entry<String, Double>> topTree = learnTool.getTopTree(0);\n\t\t  StringBuilder sb = new StringBuilder();\n\t\t  for (Entry<String, Double> entry : topTree) {\n\t\t      sb.append(entry.getKey() + \"\\t\" + entry.getValue()+\"\\n\");\n\t\t  }\n\t\t  IOUtil.Writer(filePath, IOUtil.UTF8, sb.toString());\n\t\t  sb = null;\n\t}\n\n\t/**\n\t * Read trained result from file\n\t * /home/ansj/temp/learnTool.snap\n\t * @param filePath\n\t * @throws UnsupportedEncodingException\n\t */\n\tpublic static LearnTool readTrainedResultFrFile(String filePath) throws UnsupportedEncodingException{\n\t\t  LearnTool learnTool = new LearnTool() ;\n\t\t  HashMap<String, Double> loadMap = IOUtil.loadMap(filePath, IOUtil.UTF8, String.class, Double.class);\n\t\t  for (Entry<String, Double> entry : loadMap.entrySet()) {\n\t\t      learnTool.addTerm(new NewWord(entry.getKey(), Nature.NW, entry.getValue())) ;\n\t\t      learnTool.active(entry.getKey()) ;\n\t\t  }\n\t\t  //Debug:\n\t\t  logger.info(String.format(\"Top 10 new words = %s\",learnTool.getTopTree(10).toString()));\n\t\t  return learnTool;\n\t}\n\n\n\t/**\n\t * Find keywords from title and content\n\t * @param title\n\t * @param content\n\t * @return\n\t */\n\tpublic static Collection<Keyword> findKeyWords(String title, String content){\n\t    KeyWordComputer kwc = new KeyWordComputer(5);\n\t\treturn kwc.computeArticleTfidf(title, content);\n\t}\n\n\n\tpublic static void trainCrfModel() throws Exception{\n\t\tModel model = CRFModel.load(\"D:/tmp/sn/model.txt\");\n\t\tmodel.writeModel(\"D:/tmp/sn/crf.model\");\n\t}\n}\n\n```\n\n## 测试方法运行结果：\n\n```sh\nname = 斯诺登 freq = 9 score = 211.83897497289786\nname = 维基 freq = 3 score = 163.46869316143392\nname = 委内瑞拉 freq = 7 score = 101.31414008144232\nname = 庇护 freq = 5 score = 46.05172894231714\nname = 普什科夫 freq = 3 score = 40.66920082459204\n\n```\n","slug":"An-Easy-To-Use-Analyzer-Tool-AnjSeq","published":1,"updated":"2018-12-03T05:16:21.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0mxw001ard4lxq2i0vmu","content":"<h2 id=\"AnsjSeq简介\"><a href=\"#AnsjSeq简介\" class=\"headerlink\" title=\"AnsjSeq简介\"></a>AnsjSeq简介</h2><blockquote>\n<p>这是一个基于n-Gram+CRF+HMM的中文分词的java实现.</p>\n</blockquote>\n<blockquote>\n<p>分词速度达到每秒钟大约200万字左右（mac air下测试），准确率能达到96%以上</p>\n</blockquote>\n<blockquote>\n<p>目前实现了.中文分词. 中文姓名识别 . 用户自定义词典,关键字提取，自动摘要，关键字标记等功能</p>\n</blockquote>\n<blockquote>\n<p>可以应用到自然语言处理等方面,适用于对分词效果要求高的各种项目.</p>\n</blockquote>\n<blockquote>\n<p>Official Site Url(<a href=\"https://raw.githubusercontent.com/NLPchina/ansj_seg\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/NLPchina/ansj_seg</a>)</p>\n</blockquote>\n<h2 id=\"加载Maven依赖：\"><a href=\"#加载Maven依赖：\" class=\"headerlink\" title=\"加载Maven依赖：\"></a>加载Maven依赖：</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.ansj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ansj_seg<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"测试代码如下：\"><a href=\"#测试代码如下：\" class=\"headerlink\" title=\"测试代码如下：\"></a>测试代码如下：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StringReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map.Entry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.crf.Model;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.crf.model.CRFModel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.keyword.KeyWordComputer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.keyword.Keyword;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.dic.LearnTool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.domain.Nature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.domain.NewWord;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.domain.Result;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.splitWord.analysis.NlpAnalysis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.splitWord.analysis.ToAnalysis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.tire.GetWord;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.tire.domain.Forest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.tire.library.Library;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.util.IOUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnsjSegUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(AnsjSegUtil.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String testStr = <span class=\"string\">\"欢迎使用ansj_seg,(ansj中文分词)在这里如果你遇到什么问题都可以联系我.我一定尽我所能.帮助大家.ansj_seg更快,更准,更自由!\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttestFindKeyword();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testTreeSplitDemo</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 词典的构造.一行一个词后面是参数.可以从文件读取.可以是read流.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String dic = <span class=\"string\">\"中国\\t1\\tzg\\n人名\\t2\\n中国人民\\t4\\n人民\\t3\\n孙健\\t5\\nCSDN\\t6\\njava\\t7\\njava学习\\t10\\n\"</span>;</span><br><span class=\"line\">        Forest forest = Library.makeForest(<span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> StringReader(dic)));</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 删除一个单词</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Library.removeWord(forest, <span class=\"string\">\"中国\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 增加一个新词</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Library.insertWord(forest, <span class=\"string\">\"中国人\"</span>);</span><br><span class=\"line\">        String content = <span class=\"string\">\"中国人名识别是中国人民的一个骄傲.孙健人民在CSDN中学到了很多最早iteye是java学习笔记叫javaeye但是java123只是一部分\"</span>;</span><br><span class=\"line\">        GetWord udg = forest.getWord(content);</span><br><span class=\"line\">        String temp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((temp = udg.getFrontWords()) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            System.out.println(temp + <span class=\"string\">\"\\t\\t\"</span> + udg.getParam(<span class=\"number\">1</span>) + <span class=\"string\">\"\\t\\t\"</span> + udg.getParam(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testFindKeyword</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t    String title = <span class=\"string\">\"维基解密否认斯诺登接受委内瑞拉庇护\"</span>;</span><br><span class=\"line\">\t    String content = <span class=\"string\">\"有俄罗斯国会议员，9号在社交网站推特表示，美国中情局前雇员斯诺登，已经接受委内瑞拉的庇护，不过推文在发布几分钟后随即删除。俄罗斯当局拒绝发表评论，而一直协助斯诺登的维基解密否认他将投靠委内瑞拉。　　俄罗斯国会国际事务委员会主席普什科夫，在个人推特率先披露斯诺登已接受委内瑞拉的庇护建议，令外界以为斯诺登的动向终于有新进展。　　不过推文在几分钟内旋即被删除，普什科夫澄清他是看到俄罗斯国营电视台的新闻才这样说，而电视台已经作出否认，称普什科夫是误解了新闻内容。　　委内瑞拉驻莫斯科大使馆、俄罗斯总统府发言人、以及外交部都拒绝发表评论。而维基解密就否认斯诺登已正式接受委内瑞拉的庇护，说会在适当时间公布有关决定。　　斯诺登相信目前还在莫斯科谢列梅捷沃机场，已滞留两个多星期。他早前向约20个国家提交庇护申请，委内瑞拉、尼加拉瓜和玻利维亚，先后表示答应，不过斯诺登还没作出决定。　　而另一场外交风波，玻利维亚总统莫拉莱斯的专机上星期被欧洲多国以怀疑斯诺登在机上为由拒绝过境事件，涉事国家之一的西班牙突然转口风，外长马加略]号表示愿意就任何误解致歉，但强调当时当局没有关闭领空或不许专机降落。\"</span>;</span><br><span class=\"line\">\t\tCollection&lt;Keyword&gt; result = findKeyWords(title,content);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Keyword kw : result)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"name = \"</span> + kw.getName() + <span class=\"string\">\" freq = \"</span> + kw.getFreq() + <span class=\"string\">\" score = \"</span> + kw.getScore());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addNewWordDemo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 增加新词,中间按照'\\t'隔开</span></span><br><span class=\"line\"><span class=\"comment\">//        UserDefineLibrary.insertWord(\"ansj中文分词\", \"userDefine\", 1000);</span></span><br><span class=\"line\">        Result terms = ToAnalysis.parse(<span class=\"string\">\"我觉得Ansj中文分词是一个不错的系统!我是王婆!\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"增加新词例子:\"</span> + terms);</span><br><span class=\"line\">        <span class=\"comment\">// 删除词语,只能删除.用户自定义的词典.</span></span><br><span class=\"line\"><span class=\"comment\">//        UserDefineLibrary.removeWord(\"ansj中文分词\");</span></span><br><span class=\"line\">        terms = ToAnalysis.parse(<span class=\"string\">\"我觉得ansj中文分词是一个不错的系统!我是王婆!\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"删除用户自定义词典例子:\"</span> + terms);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">learnToolDemo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建一个新词学习的工具类。这个对象。保存了所有分词中出现的新词。出现次数越多。相对权重越大。</span></span><br><span class=\"line\">        LearnTool learnTool = <span class=\"keyword\">new</span> LearnTool() ;</span><br><span class=\"line\">        Forest forest = <span class=\"keyword\">new</span> Forest();</span><br><span class=\"line\">        <span class=\"comment\">//进行词语分词。也就是nlp方式分词，这里可以分多篇文章</span></span><br><span class=\"line\"><span class=\"comment\">//        NlpAnalysis.parse(\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\", learnTool) ;</span></span><br><span class=\"line\"><span class=\"comment\">//        NlpAnalysis.parse(\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\", learnTool) ;</span></span><br><span class=\"line\"><span class=\"comment\">//        NlpAnalysis.parse(\"张艺谋的卡宴，马明哲的戏\",learnTool) ;</span></span><br><span class=\"line\">        NlpAnalysis.parse(<span class=\"string\">\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\"</span>, forest) ;</span><br><span class=\"line\">        NlpAnalysis.parse(<span class=\"string\">\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\"</span>, forest) ;</span><br><span class=\"line\">        NlpAnalysis.parse(<span class=\"string\">\"张艺谋的卡宴，马明哲的戏\"</span>,forest) ;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String str : forest.getParams()) &#123;</span><br><span class=\"line\">\t\t\tlogger.info(str);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//        new NewWord(String,Nature,Double);</span></span><br><span class=\"line\">        <span class=\"comment\">//取得学习到的topn新词,返回前10个。这里如果设置为0则返回全部</span></span><br><span class=\"line\">        System.out.println(learnTool.getTopTree(<span class=\"number\">10</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只取得词性为Nature.NR的新词</span></span><br><span class=\"line\">        System.out.println(learnTool.getTopTree(<span class=\"number\">10</span>,Nature.NR));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testParse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(ToAnalysis.parse(testStr));</span><br><span class=\"line\">\t\t<span class=\"comment\">// Expect as below:</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 欢迎/v,使用/v,ansj/en,_,seg/en,,,(,ansj/en,中文/nz,分词/n,),在/p,这里/r,如果/c,你/r,遇到/v,什么/r,问题/n,都/d,可以/v,联系/v,我/r,./m,我/r,一定/d,尽我所能/l,./m,帮助/v,大家/r,./m,ansj/en,_,seg/en,更快/d,,,更/d,准/a,,,更/d,自由/a,!</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//parseString 2:</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"结婚的和尚未结婚的\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//parseString 2:</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"结合成分子时\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//交叉歧义（多种切分交织在一起）：内塔内亚胡说的/确实/在理</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"内塔内亚胡说的确实在理\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"内塔内亚说的确实在理\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseNlp(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//组合歧义（不同情况下切分不同）：这个人/手上有痣、我们公司人手</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"这个人手上有痣、我们公司人手\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//真歧义（几种切分都可以）：乒乓球拍/卖/完了、乒乓球/拍卖/完了</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"乒乓球拍卖完了、乒乓球拍卖完了\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//synonyms test</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"我家外戚和远房亲戚是一个意思吗？\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//亲家母亲家公</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"亲家母亲家公\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * accurate parse with nature</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseStrInput</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ToAnalysis.parse(str).toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * accurate parse without nature</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseStrInputWithOutNature</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ToAnalysis.parse(str).toStringWithOutNature();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * nlp parse with nature</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseNlp</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NlpAnalysis.parse(str).toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Write trained result to file</span></span><br><span class=\"line\"><span class=\"comment\">\t * /home/ansj/temp/learnTool.snap</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> filePath</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> learnTool</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">writeTrainedResultToFile</span><span class=\"params\">(String filePath, LearnTool learnTool)</span></span>&#123;</span><br><span class=\"line\">\t\t  List&lt;Entry&lt;String, Double&gt;&gt; topTree = learnTool.getTopTree(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t  StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t\t  <span class=\"keyword\">for</span> (Entry&lt;String, Double&gt; entry : topTree) &#123;</span><br><span class=\"line\">\t\t      sb.append(entry.getKey() + <span class=\"string\">\"\\t\"</span> + entry.getValue()+<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  IOUtil.Writer(filePath, IOUtil.UTF8, sb.toString());</span><br><span class=\"line\">\t\t  sb = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Read trained result from file</span></span><br><span class=\"line\"><span class=\"comment\">\t * /home/ansj/temp/learnTool.snap</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> filePath</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> UnsupportedEncodingException</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LearnTool <span class=\"title\">readTrainedResultFrFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException</span>&#123;</span><br><span class=\"line\">\t\t  LearnTool learnTool = <span class=\"keyword\">new</span> LearnTool() ;</span><br><span class=\"line\">\t\t  HashMap&lt;String, Double&gt; loadMap = IOUtil.loadMap(filePath, IOUtil.UTF8, String.class, Double.class);</span><br><span class=\"line\">\t\t  <span class=\"keyword\">for</span> (Entry&lt;String, Double&gt; entry : loadMap.entrySet()) &#123;</span><br><span class=\"line\">\t\t      learnTool.addTerm(<span class=\"keyword\">new</span> NewWord(entry.getKey(), Nature.NW, entry.getValue())) ;</span><br><span class=\"line\">\t\t      learnTool.active(entry.getKey()) ;</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  <span class=\"comment\">//Debug:</span></span><br><span class=\"line\">\t\t  logger.info(String.format(<span class=\"string\">\"Top 10 new words = %s\"</span>,learnTool.getTopTree(<span class=\"number\">10</span>).toString()));</span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> learnTool;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Find keywords from title and content</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> title</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> content</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Collection&lt;Keyword&gt; <span class=\"title\">findKeyWords</span><span class=\"params\">(String title, String content)</span></span>&#123;</span><br><span class=\"line\">\t    KeyWordComputer kwc = <span class=\"keyword\">new</span> KeyWordComputer(<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kwc.computeArticleTfidf(title, content);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">trainCrfModel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">\t\tModel model = CRFModel.load(<span class=\"string\">\"D:/tmp/sn/model.txt\"</span>);</span><br><span class=\"line\">\t\tmodel.writeModel(<span class=\"string\">\"D:/tmp/sn/crf.model\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试方法运行结果：\"><a href=\"#测试方法运行结果：\" class=\"headerlink\" title=\"测试方法运行结果：\"></a>测试方法运行结果：</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = 斯诺登 freq = 9 score = 211.83897497289786</span><br><span class=\"line\">name = 维基 freq = 3 score = 163.46869316143392</span><br><span class=\"line\">name = 委内瑞拉 freq = 7 score = 101.31414008144232</span><br><span class=\"line\">name = 庇护 freq = 5 score = 46.05172894231714</span><br><span class=\"line\">name = 普什科夫 freq = 3 score = 40.66920082459204</span><br></pre></td></tr></table></figure>\n<div><h1>おススメ記事<span style=\"font-size:0.45em; color:gray\">（<a href=\"https://github.com/huiwang/hexo-recommended-posts\">hexo-recommend-posts</a>）</span></h1><ul><li><a href=\"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/\">跟着日语分词器Kuromoji学习日语</a></li><li><a href=\"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/\">跟着日语分词器Kuromoji学习日语</a></li><li><a href=\"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/\">跟着日语分词器Kuromoji学习日语</a></li><li><a href=\"http://linfuyan.com/add-chinese-support-to-lunrjs/\">为 lunr.js 添加中文支持</a></li></ul></div>","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"AnsjSeq简介\"><a href=\"#AnsjSeq简介\" class=\"headerlink\" title=\"AnsjSeq简介\"></a>AnsjSeq简介</h2><blockquote>\n<p>这是一个基于n-Gram+CRF+HMM的中文分词的java实现.</p>\n</blockquote>\n<blockquote>\n<p>分词速度达到每秒钟大约200万字左右（mac air下测试），准确率能达到96%以上</p>\n</blockquote>\n<blockquote>\n<p>目前实现了.中文分词. 中文姓名识别 . 用户自定义词典,关键字提取，自动摘要，关键字标记等功能</p>\n</blockquote>\n<blockquote>\n<p>可以应用到自然语言处理等方面,适用于对分词效果要求高的各种项目.</p>\n</blockquote>\n<blockquote>\n<p>Official Site Url(<a href=\"https://raw.githubusercontent.com/NLPchina/ansj_seg\" target=\"_blank\" rel=\"noopener\">https://raw.githubusercontent.com/NLPchina/ansj_seg</a>)</p>\n</blockquote>\n<h2 id=\"加载Maven依赖：\"><a href=\"#加载Maven依赖：\" class=\"headerlink\" title=\"加载Maven依赖：\"></a>加载Maven依赖：</h2><figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.ansj<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>ansj_seg<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">     <span class=\"tag\">&lt;<span class=\"name\">version</span>&gt;</span>5.1.1<span class=\"tag\">&lt;/<span class=\"name\">version</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"测试代码如下：\"><a href=\"#测试代码如下：\" class=\"headerlink\" title=\"测试代码如下：\"></a>测试代码如下：</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.StringReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.UnsupportedEncodingException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Collection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.List;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map.Entry;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.logging.Logger;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.crf.Model;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.crf.model.CRFModel;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.keyword.KeyWordComputer;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.app.keyword.Keyword;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.dic.LearnTool;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.domain.Nature;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.domain.NewWord;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.domain.Result;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.splitWord.analysis.NlpAnalysis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.ansj.splitWord.analysis.ToAnalysis;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.tire.GetWord;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.tire.domain.Forest;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.tire.library.Library;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.nlpcn.commons.lang.util.IOUtil;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AnsjSegUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Logger logger = Logger.getLogger(AnsjSegUtil.class.getName());</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String testStr = <span class=\"string\">\"欢迎使用ansj_seg,(ansj中文分词)在这里如果你遇到什么问题都可以联系我.我一定尽我所能.帮助大家.ansj_seg更快,更准,更自由!\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t\ttestFindKeyword();</span><br><span class=\"line\"></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testTreeSplitDemo</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 词典的构造.一行一个词后面是参数.可以从文件读取.可以是read流.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        String dic = <span class=\"string\">\"中国\\t1\\tzg\\n人名\\t2\\n中国人民\\t4\\n人民\\t3\\n孙健\\t5\\nCSDN\\t6\\njava\\t7\\njava学习\\t10\\n\"</span>;</span><br><span class=\"line\">        Forest forest = Library.makeForest(<span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> StringReader(dic)));</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 删除一个单词</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Library.removeWord(forest, <span class=\"string\">\"中国\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * 增加一个新词</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        Library.insertWord(forest, <span class=\"string\">\"中国人\"</span>);</span><br><span class=\"line\">        String content = <span class=\"string\">\"中国人名识别是中国人民的一个骄傲.孙健人民在CSDN中学到了很多最早iteye是java学习笔记叫javaeye但是java123只是一部分\"</span>;</span><br><span class=\"line\">        GetWord udg = forest.getWord(content);</span><br><span class=\"line\">        String temp = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((temp = udg.getFrontWords()) != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            System.out.println(temp + <span class=\"string\">\"\\t\\t\"</span> + udg.getParam(<span class=\"number\">1</span>) + <span class=\"string\">\"\\t\\t\"</span> + udg.getParam(<span class=\"number\">2</span>));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testFindKeyword</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t    String title = <span class=\"string\">\"维基解密否认斯诺登接受委内瑞拉庇护\"</span>;</span><br><span class=\"line\">\t    String content = <span class=\"string\">\"有俄罗斯国会议员，9号在社交网站推特表示，美国中情局前雇员斯诺登，已经接受委内瑞拉的庇护，不过推文在发布几分钟后随即删除。俄罗斯当局拒绝发表评论，而一直协助斯诺登的维基解密否认他将投靠委内瑞拉。　　俄罗斯国会国际事务委员会主席普什科夫，在个人推特率先披露斯诺登已接受委内瑞拉的庇护建议，令外界以为斯诺登的动向终于有新进展。　　不过推文在几分钟内旋即被删除，普什科夫澄清他是看到俄罗斯国营电视台的新闻才这样说，而电视台已经作出否认，称普什科夫是误解了新闻内容。　　委内瑞拉驻莫斯科大使馆、俄罗斯总统府发言人、以及外交部都拒绝发表评论。而维基解密就否认斯诺登已正式接受委内瑞拉的庇护，说会在适当时间公布有关决定。　　斯诺登相信目前还在莫斯科谢列梅捷沃机场，已滞留两个多星期。他早前向约20个国家提交庇护申请，委内瑞拉、尼加拉瓜和玻利维亚，先后表示答应，不过斯诺登还没作出决定。　　而另一场外交风波，玻利维亚总统莫拉莱斯的专机上星期被欧洲多国以怀疑斯诺登在机上为由拒绝过境事件，涉事国家之一的西班牙突然转口风，外长马加略]号表示愿意就任何误解致歉，但强调当时当局没有关闭领空或不许专机降落。\"</span>;</span><br><span class=\"line\">\t\tCollection&lt;Keyword&gt; result = findKeyWords(title,content);</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(Keyword kw : result)&#123;</span><br><span class=\"line\">\t\t\tSystem.out.println(<span class=\"string\">\"name = \"</span> + kw.getName() + <span class=\"string\">\" freq = \"</span> + kw.getFreq() + <span class=\"string\">\" score = \"</span> + kw.getScore());</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">addNewWordDemo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// 增加新词,中间按照'\\t'隔开</span></span><br><span class=\"line\"><span class=\"comment\">//        UserDefineLibrary.insertWord(\"ansj中文分词\", \"userDefine\", 1000);</span></span><br><span class=\"line\">        Result terms = ToAnalysis.parse(<span class=\"string\">\"我觉得Ansj中文分词是一个不错的系统!我是王婆!\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"增加新词例子:\"</span> + terms);</span><br><span class=\"line\">        <span class=\"comment\">// 删除词语,只能删除.用户自定义的词典.</span></span><br><span class=\"line\"><span class=\"comment\">//        UserDefineLibrary.removeWord(\"ansj中文分词\");</span></span><br><span class=\"line\">        terms = ToAnalysis.parse(<span class=\"string\">\"我觉得ansj中文分词是一个不错的系统!我是王婆!\"</span>);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"删除用户自定义词典例子:\"</span> + terms);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">learnToolDemo</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//构建一个新词学习的工具类。这个对象。保存了所有分词中出现的新词。出现次数越多。相对权重越大。</span></span><br><span class=\"line\">        LearnTool learnTool = <span class=\"keyword\">new</span> LearnTool() ;</span><br><span class=\"line\">        Forest forest = <span class=\"keyword\">new</span> Forest();</span><br><span class=\"line\">        <span class=\"comment\">//进行词语分词。也就是nlp方式分词，这里可以分多篇文章</span></span><br><span class=\"line\"><span class=\"comment\">//        NlpAnalysis.parse(\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\", learnTool) ;</span></span><br><span class=\"line\"><span class=\"comment\">//        NlpAnalysis.parse(\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\", learnTool) ;</span></span><br><span class=\"line\"><span class=\"comment\">//        NlpAnalysis.parse(\"张艺谋的卡宴，马明哲的戏\",learnTool) ;</span></span><br><span class=\"line\">        NlpAnalysis.parse(<span class=\"string\">\"说过，社交软件也是打着沟通的平台，让无数寂寞男女有了肉体与精神的寄托。\"</span>, forest) ;</span><br><span class=\"line\">        NlpAnalysis.parse(<span class=\"string\">\"其实可以打着这个需求点去运作的互联网公司不应只是社交类软件与可穿戴设备，还有携程网，去哪儿网等等，订房订酒店多好的寓意\"</span>, forest) ;</span><br><span class=\"line\">        NlpAnalysis.parse(<span class=\"string\">\"张艺谋的卡宴，马明哲的戏\"</span>,forest) ;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> (String str : forest.getParams()) &#123;</span><br><span class=\"line\">\t\t\tlogger.info(str);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\"><span class=\"comment\">//        new NewWord(String,Nature,Double);</span></span><br><span class=\"line\">        <span class=\"comment\">//取得学习到的topn新词,返回前10个。这里如果设置为0则返回全部</span></span><br><span class=\"line\">        System.out.println(learnTool.getTopTree(<span class=\"number\">10</span>));</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//只取得词性为Nature.NR的新词</span></span><br><span class=\"line\">        System.out.println(learnTool.getTopTree(<span class=\"number\">10</span>,Nature.NR));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testParse</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t\tSystem.out.println(ToAnalysis.parse(testStr));</span><br><span class=\"line\">\t\t<span class=\"comment\">// Expect as below:</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 欢迎/v,使用/v,ansj/en,_,seg/en,,,(,ansj/en,中文/nz,分词/n,),在/p,这里/r,如果/c,你/r,遇到/v,什么/r,问题/n,都/d,可以/v,联系/v,我/r,./m,我/r,一定/d,尽我所能/l,./m,帮助/v,大家/r,./m,ansj/en,_,seg/en,更快/d,,,更/d,准/a,,,更/d,自由/a,!</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//parseString 2:</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"结婚的和尚未结婚的\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//parseString 2:</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"结合成分子时\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//交叉歧义（多种切分交织在一起）：内塔内亚胡说的/确实/在理</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"内塔内亚胡说的确实在理\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"内塔内亚说的确实在理\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseNlp(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//组合歧义（不同情况下切分不同）：这个人/手上有痣、我们公司人手</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"这个人手上有痣、我们公司人手\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//真歧义（几种切分都可以）：乒乓球拍/卖/完了、乒乓球/拍卖/完了</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"乒乓球拍卖完了、乒乓球拍卖完了\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//synonyms test</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"我家外戚和远房亲戚是一个意思吗？\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"comment\">//亲家母亲家公</span></span><br><span class=\"line\">\t\ttestStr = <span class=\"string\">\"亲家母亲家公\"</span>;</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInput(testStr));</span><br><span class=\"line\">\t\tSystem.out.println(parseStrInputWithOutNature(testStr));</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * accurate parse with nature</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseStrInput</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ToAnalysis.parse(str).toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * accurate parse without nature</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseStrInputWithOutNature</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ToAnalysis.parse(str).toStringWithOutNature();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * nlp parse with nature</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> str</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">parseNlp</span><span class=\"params\">(String str)</span></span>&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> NlpAnalysis.parse(str).toString();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Write trained result to file</span></span><br><span class=\"line\"><span class=\"comment\">\t * /home/ansj/temp/learnTool.snap</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> filePath</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> learnTool</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">writeTrainedResultToFile</span><span class=\"params\">(String filePath, LearnTool learnTool)</span></span>&#123;</span><br><span class=\"line\">\t\t  List&lt;Entry&lt;String, Double&gt;&gt; topTree = learnTool.getTopTree(<span class=\"number\">0</span>);</span><br><span class=\"line\">\t\t  StringBuilder sb = <span class=\"keyword\">new</span> StringBuilder();</span><br><span class=\"line\">\t\t  <span class=\"keyword\">for</span> (Entry&lt;String, Double&gt; entry : topTree) &#123;</span><br><span class=\"line\">\t\t      sb.append(entry.getKey() + <span class=\"string\">\"\\t\"</span> + entry.getValue()+<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  IOUtil.Writer(filePath, IOUtil.UTF8, sb.toString());</span><br><span class=\"line\">\t\t  sb = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Read trained result from file</span></span><br><span class=\"line\"><span class=\"comment\">\t * /home/ansj/temp/learnTool.snap</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> filePath</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@throws</span> UnsupportedEncodingException</span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> LearnTool <span class=\"title\">readTrainedResultFrFile</span><span class=\"params\">(String filePath)</span> <span class=\"keyword\">throws</span> UnsupportedEncodingException</span>&#123;</span><br><span class=\"line\">\t\t  LearnTool learnTool = <span class=\"keyword\">new</span> LearnTool() ;</span><br><span class=\"line\">\t\t  HashMap&lt;String, Double&gt; loadMap = IOUtil.loadMap(filePath, IOUtil.UTF8, String.class, Double.class);</span><br><span class=\"line\">\t\t  <span class=\"keyword\">for</span> (Entry&lt;String, Double&gt; entry : loadMap.entrySet()) &#123;</span><br><span class=\"line\">\t\t      learnTool.addTerm(<span class=\"keyword\">new</span> NewWord(entry.getKey(), Nature.NW, entry.getValue())) ;</span><br><span class=\"line\">\t\t      learnTool.active(entry.getKey()) ;</span><br><span class=\"line\">\t\t  &#125;</span><br><span class=\"line\">\t\t  <span class=\"comment\">//Debug:</span></span><br><span class=\"line\">\t\t  logger.info(String.format(<span class=\"string\">\"Top 10 new words = %s\"</span>,learnTool.getTopTree(<span class=\"number\">10</span>).toString()));</span><br><span class=\"line\">\t\t  <span class=\"keyword\">return</span> learnTool;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">\t * Find keywords from title and content</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> title</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@param</span> content</span></span><br><span class=\"line\"><span class=\"comment\">\t * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">\t */</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Collection&lt;Keyword&gt; <span class=\"title\">findKeyWords</span><span class=\"params\">(String title, String content)</span></span>&#123;</span><br><span class=\"line\">\t    KeyWordComputer kwc = <span class=\"keyword\">new</span> KeyWordComputer(<span class=\"number\">5</span>);</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> kwc.computeArticleTfidf(title, content);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">trainCrfModel</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>&#123;</span><br><span class=\"line\">\t\tModel model = CRFModel.load(<span class=\"string\">\"D:/tmp/sn/model.txt\"</span>);</span><br><span class=\"line\">\t\tmodel.writeModel(<span class=\"string\">\"D:/tmp/sn/crf.model\"</span>);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"测试方法运行结果：\"><a href=\"#测试方法运行结果：\" class=\"headerlink\" title=\"测试方法运行结果：\"></a>测试方法运行结果：</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name = 斯诺登 freq = 9 score = 211.83897497289786</span><br><span class=\"line\">name = 维基 freq = 3 score = 163.46869316143392</span><br><span class=\"line\">name = 委内瑞拉 freq = 7 score = 101.31414008144232</span><br><span class=\"line\">name = 庇护 freq = 5 score = 46.05172894231714</span><br><span class=\"line\">name = 普什科夫 freq = 3 score = 40.66920082459204</span><br></pre></td></tr></table></figure>\n"},{"title":"How To Next","date":"2016-11-28T07:59:00.000Z","_content":"\n\n# <div align=\"center\"><a href=\"https://github.com/iissnan/hexo-theme-next\"><img align=\"center\" width=\"56\" height=\"56\" src=\"/2018/11/26/How-To-Next/logo.svg\"></a> N e x T</div>\n\n<p align=\"center\">NexT 是一个高质量并且优雅的<a href=\"http://hexo.io\">Hexo</a> 主题。这是精心制作做出来的 hexo 主题。</p>\n\n![NexT Schemes](http://iissnan.com/nexus/next/next-schemes.jpg)\n\n[![Join the chat at https://gitter.im/iissnan/hexo-theme-next](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![mnt-image]][commits-url]\n[![travis-image]][travis-url]\n[![rel-image]][releases-url]\n[![hexo-image]][hexo-url]\n[![lic-image]](LICENSE)\n\n* <a href=\"http://theme-next.iissnan.com\" target=\"_blank\">NexT 使用文档</a> |  [English Documentation](README.md)\n\n## 实时预览 Live Preview\n\n\n* :heart_decoration: Muse 方案: [XiaMo](https://notes.wanghao.work) | [OAwan](https://oawan.me) | [Hui Wang](http://hui-wang.info)\n* :six_pointed_star: Mist 方案: [Jeff](https://blog.zzbd.org) | [uchuhimo](http://uchuhimo.me) | [xirong](http://www.ixirong.com)\n* :pisces: Pisces 方案: [Vi](http://notes.iissnan.com) | [Acris](https://acris.me) | [Rainy](https://rainylog.com)\n* :gemini: Gemini 方案: [Ivan.Nginx](https://almostover.ru) | [Alynx](http://sh.alynx.xyz) | [Raincal](https://raincal.top)\n\n\n更多 NexT 例子点击 [这里](https://github.com/iissnan/hexo-theme-next/issues/119).\n\n## 安装 Installation\n\n**1.** 在终端切换到**hexo 根**目录. 在hexo目录下一定有 `node_modules`, `source`, `themes` 和其他文件夹:\n   ```sh\n   $ cd hexo\n   $ ls\n   _config.yml  node_modules  package.json  public  scaffolds  source  themes\n   ```\n\n**2.** 从 github 上获取主题 。这里有几种方式来获取主题:\n\n### 下载[最新发布的版本][releases-latest-url]  Download tagged release version\n   在大多数情况下 **稳定**。 推荐用户下载这个。\n\n   [![curl-tar-wget-image]][curl-tar-wget-url]\n\n   ```sh\n   $ mkdir themes/next\n   $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '\"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1\n   ```\n\n### 下载[标签发布版本][releases-url]  Download tagged release version\n   您必须定义版本。从[标签列表][tags-url]里选择版本替换`v5.1.2`。\n\n   [![curl-tar-image]][curl-tar-url]\n\n   ```sh\n   $ mkdir themes/next\n   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1\n   ```\n\n   [![git-image]][git-url]\n\n   ```sh\n   $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next\n   ```\n\n### 下载[最新的 master 分支][download-latest-url]  Download latest master branch\n  可能会 **不稳定**, 但是包含最新的特色，推荐开发者下载.\n\n   [![curl-tar-image]][curl-tar-url]\n\n   ```sh\n   $ mkdir themes/next\n   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1\n   ```\n\n   [![git-image]][git-url]\n\n   ```sh\n   $ git clone https://github.com/iissnan/hexo-theme-next themes/next\n   ```\n\n  使用克隆命令，你将得到**整个存储库**。而且在任何时候你都可以切换到任何标签发布版本。\n  获取标签列表：\n\n   ```sh\n   $ cd themes/next\n   $ git tag -l\n   …\n   v5.0.0\n   v5.0.1\n   v5.1.0\n   v5.1.1\n   v5.1.2\n   ```\n\n   例如, 你想要切换到`v5.1.0` [标签发布版本][tags-url]. 输入以下命令:\n\n   ```sh\n   $ git checkout tags/v5.1.0\n   Note: checking out 'tags/v5.1.0'.\n   …\n   HEAD now on 1f72f68... CSS: Remove global list-style setting of ul\n   ```\n\n   如果你想切换回 [master 分支][commits-url]的话, 输入这个命令:\n\n   ```sh\n   $ git checkout master\n   ```\n\n**3.** 在 **hexo 根目录下** 的配置文件`_config.yml`里设置主题:\n\n    theme: next\n    \n### Bugs\n对于那些遇到 **Error: Cannot find module 'hexo-util'** [问题](https://github.com/iissnan/hexo-theme-next/issues/1490)的人, 请检查你的NPM 版本. \n\n- `版本 > 3`: 如果仍然不行的话，请移除 `node_modules` 文件 然后重新安装，使用 `npm install`命令。\n- `版本 < 3`: 请通过`npm install --save-dev hexo-util`命令添加`hexo-util`到你的站点包依赖里\n\n## 更新 Update\n\n```sh\n$ cd themes/next\n$ git pull\n```\n\n### Bugs\n\n> 提交您的更改或存储它们，然后才能合并。\n\n您必须提交，存储或放弃本地更改. 看 [here](https://stackoverflow.com/a/15745424/5861495) 是如何做的。\n\n### 使用Hexo data files([#328](https://github.com/iissnan/hexo-theme-next/issues/328))配置主题  Theme configurations using Hexo data files #328\n\n\n目前升级 NexT 主题的时候并不是非常的流畅。若使用 `git pull` 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 `_config.yml` 文件。\n\n在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点：\n\n1. 配置分离成了两个部分\n2. 用户可能会疑惑一些选项该放置在哪里比较合适\n\n为了解决这个问题， NexT 将会使用 Hexo 的 [Data Files](https://hexo.io/docs/data-files.html) 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。\n\n若你比较喜欢 Hexo 2.x 版本，可以继续使用原先的配置方式。 NexT 保持着向下兼容。\n\n\n#### 特性 Benefits\n\n通过这个特性，你可以将所有的主题配置放置在站点的 `source/_data/next.yml` 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 `next.yml` 中做相应调整即可\n\n\n#### 如何使用这个特性 How to use this feature\n\n1. 请先确保你所使用的 Hexo 版本在 3 以上\n2. 在站点的 `source/_data` 目录下新建 `next.yml` 文件（`_data`目录可能需要新建）\n3. 迁移站点配置文件和主题配置文件中的配置到 `next.yml` 中\n4. 使用 `--config source/_data/next.yml` 参数启动服务器, 生成或者部署。\\\n   例如: `hexo clean --config source/_data/next.yml && hexo g --config source/_data/next.yml`。\n\n## 特色 Features \n\n### 支持多国语言, 包括: \n:cn: 简体中文 & 繁体中文<br>\n:us: 英语<br>\n:ru: 俄语<br>\n:fr: 法语<br>\n:de: 德语<br>\n:jp: 日语<br>\n:indonesia: 印度尼西亚语<br>\n:portugal: 葡萄牙语 (巴西)<br>\n:kr: 朝鲜语<br>\n:it: 意大利语<br>\n:netherlands: 荷兰语\n\n默认语言是英语。\n\n```yml\nlanguage: en\n# language: zh-Hans\n# language: zh-hk\n# language: zh-tw\n# language: ru\n# language: fr-FR\n# language: de\n# language: ja\n# language: id\n# language: pt\n# language: pt-BR\n# language: ko\n# language: it\n# language: nl-NL\n```\n\n在站点配置文件`_config.yml`中可以将语言切换成中文\n\n```yml\nlanguage: zh-Hans\n```\n\n### 评论支持 Comment support\n\nNexT 已经原生支持 `多说` and `Disqus` 评论系统。\n\n添加以下代码到你的主题配置文件 `_config.yml`:\n\n```yml\nduoshuo:\n  enable: true\n  shortname: your-duoshuo-shortname\n```\n\n或者\n\n```yml\ndisqus_shortname: your-disqus-shortname\n```\n\n### 标签页 Tags page\n\n> 添加一个标签页面，里面包含您网站中的所有标签。\n\n- 创建一个名为 `tags` 页面\n\n        hexo new page \"tags\"\n\n- 编辑标签页, 设置页面类型为`tags`.\n\n        title: All tags\n        date: 2014-12-22 12:39:04\n        type: \"tags\"\n\n- 添加 `tags` 到主题配置文件 `_config.yml` 里:\n\n        menu:\n          home: /\n          archives: /archives\n          tags: /tags\n\n### 分类页 Categories page\n\n> 添加一个分类页面，里面包含您网站中的所有分类。\n\n- 创建一个名为 `categories` 页面\n\n        hexo new page \"categories\"\n\n- 编辑分类页, 设置页面类型为 `categories`.\n\n        title: All categories\n        date: 2014-12-22 12:39:04\n        type: \"categories\"\n\n- 添加 `categories` 到主题配置文件 `_config.yml` 里:\n\n        menu:\n          home: /\n          archives: /archives\n          categories: /categories\n\n### 社交媒体 Social Media\n\nNexT 可以自动添加链接到您的社交媒体帐户里:\n\n```yml\nsocial:\n  GitHub: your-github-url\n  Twitter: your-twitter-url\n  Weibo: your-weibo-url\n  DouBan: your-douban-url\n  ZhiHu: your-zhihu-url\n```\n\n### Feed 链接 Feed link\n\n> 显示 feed 链接。\n\n在主题配置文件`_config.yml`里设置`rss` , 如下所示:\n\n1. `rss: false` 会禁用 feed 链接。\n2. `rss:  ` 使用站点 feed 链接。这是默认的选项。\n\n    按照插件[hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)的README中的安装说明进行操作。在完成这个插件的配置后，Feed链接也生成好了\n\n3. `rss: http://your-feed-url` 设置你的 feed 链接.\n\n### 内置5种代码高亮主题 Up to 5 code highlight themes built-in\n\nNexT 使用的是 [Tomorrow 主题](https://github.com/chriskempson/tomorrow-theme) ，一共有5种主题供你选择。\nNext 默认使用 `normal`. 下面是 `normal` 和 `night` 主题的预览:\n\n![Tomorrow Normal Preview](http://iissnan.com/nexus/next/tomorrow-normal.png)\n![Tomorrow Night Preview](http://iissnan.com/nexus/next/tomorrow-night.png)\n\n查看更多信息点击[Tomorrow 主题](https://github.com/chriskempson/tomorrow-theme)。\n\n## 配置 Configuration\n\nNexT 的配置很少\n\n```yml\n\n# Menu configuration.\nmenu:\n  home: /\n  archives: /archives\n\n# Favicon\nfavicon: /favicon.ico\n\n# Avatar (put the image into next/source/images/)\n# can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)\navatar: /default_avatar.png\n\n# Code highlight theme\n# available: normal | night | night eighties | night blue | night bright\nhighlight_theme: normal\n\n# Fancybox for image gallery\nfancybox: true\n\n# Specify the date when the site was setup\nsince: 2013\n\n```\n\n\n## 浏览器支持 Browser support\n\n![Browser support](http://iissnan.com/nexus/next/browser-support.png)\n\n![Browser Stack](How-To-Next/browserstack_logo.png)(https://www.browserstack.com/)\n>**BrowserStack** is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.\n\n## 贡献 Contributing\n\n接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的`Pull Request`。\n\nAny types of contribution are welcome. Thanks.\n\n**ATTENTION! Contributors on Chinese docs needed!**\\\nNeed to translate from [English docs](README.md) to Chinese docs.\\\nAny help wanted!\\\nThank's a lot!\n\n## 开发 Development\n\nNexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。\n\nNexT is built for easily use with elegant appearance. First things first, always keep things simple.\n\n## [开发历史 Changelog](https://github.com/iissnan/hexo-theme-next/wiki/Changelog)\n\n\n\n[browser-image]: https://img.shields.io/badge/browser-%20chrome%20%7C%20firefox%20%7C%20opera%20%7C%20safari%20%7C%20ie%20%3E%3D%209-lightgrey.svg\n[browser-url]: https://www.browserstack.com\n\n[gitter-image]: https://badges.gitter.im/Join%20Chat.svg\n[gitter-url]: https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n\n[travis-image]: https://travis-ci.org/iissnan/hexo-theme-next.svg?branch=master\n[travis-url]: https://travis-ci.org/iissnan/hexo-theme-next?branch=master \"Travis CI\"\n\n[hexo-image]: https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg\n[hexo-url]: http://hexo.io\n\n[mnt-image]: https://img.shields.io/maintenance/yes/2017.svg\n[rel-image]: https://img.shields.io/github/release/iissnan/hexo-theme-next.svg\n<!--[lic-image]: https://img.shields.io/npm/l/hexo-theme-next.svg-->\n[lic-image]: https://img.shields.io/dub/l/vibe-d.svg\n\n[git-image]: https://img.shields.io/badge/install%20with%20-git-blue.svg\n[curl-tar-image]: https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg\n[curl-tar-wget-image]: https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar%20%7C%20wget-blue.svg\n[git-url]: http://lmgtfy.com/?q=linux+git+install\n[curl-tar-url]: http://lmgtfy.com/?q=linux+curl+tar+install\n[curl-tar-wget-url]: http://lmgtfy.com/?q=linux+curl+tar+wget+install\n\n[download-latest-url]: https://github.com/iissnan/hexo-theme-next/archive/master.zip\n[releases-latest-url]: https://github.com/iissnan/hexo-theme-next/releases/latest\n[releases-url]: https://github.com/iissnan/hexo-theme-next/releases\n[tags-url]: https://github.com/iissnan/hexo-theme-next/tags\n[commits-url]: https://github.com/iissnan/hexo-theme-next/commits/master\n","source":"_posts/How-To-Next.md","raw":"title: How To Next\ntags:\n  - hexo\n  - next\ncategories:\n  - next\n  - hexo\ndate: 2016-11-28 16:59:00\n---\n\n\n# <div align=\"center\"><a href=\"https://github.com/iissnan/hexo-theme-next\"><img align=\"center\" width=\"56\" height=\"56\" src=\"/2018/11/26/How-To-Next/logo.svg\"></a> N e x T</div>\n\n<p align=\"center\">NexT 是一个高质量并且优雅的<a href=\"http://hexo.io\">Hexo</a> 主题。这是精心制作做出来的 hexo 主题。</p>\n\n![NexT Schemes](http://iissnan.com/nexus/next/next-schemes.jpg)\n\n[![Join the chat at https://gitter.im/iissnan/hexo-theme-next](https://badges.gitter.im/Join%20Chat.svg)](https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge)\n[![mnt-image]][commits-url]\n[![travis-image]][travis-url]\n[![rel-image]][releases-url]\n[![hexo-image]][hexo-url]\n[![lic-image]](LICENSE)\n\n* <a href=\"http://theme-next.iissnan.com\" target=\"_blank\">NexT 使用文档</a> |  [English Documentation](README.md)\n\n## 实时预览 Live Preview\n\n\n* :heart_decoration: Muse 方案: [XiaMo](https://notes.wanghao.work) | [OAwan](https://oawan.me) | [Hui Wang](http://hui-wang.info)\n* :six_pointed_star: Mist 方案: [Jeff](https://blog.zzbd.org) | [uchuhimo](http://uchuhimo.me) | [xirong](http://www.ixirong.com)\n* :pisces: Pisces 方案: [Vi](http://notes.iissnan.com) | [Acris](https://acris.me) | [Rainy](https://rainylog.com)\n* :gemini: Gemini 方案: [Ivan.Nginx](https://almostover.ru) | [Alynx](http://sh.alynx.xyz) | [Raincal](https://raincal.top)\n\n\n更多 NexT 例子点击 [这里](https://github.com/iissnan/hexo-theme-next/issues/119).\n\n## 安装 Installation\n\n**1.** 在终端切换到**hexo 根**目录. 在hexo目录下一定有 `node_modules`, `source`, `themes` 和其他文件夹:\n   ```sh\n   $ cd hexo\n   $ ls\n   _config.yml  node_modules  package.json  public  scaffolds  source  themes\n   ```\n\n**2.** 从 github 上获取主题 。这里有几种方式来获取主题:\n\n### 下载[最新发布的版本][releases-latest-url]  Download tagged release version\n   在大多数情况下 **稳定**。 推荐用户下载这个。\n\n   [![curl-tar-wget-image]][curl-tar-wget-url]\n\n   ```sh\n   $ mkdir themes/next\n   $ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d '\"' -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1\n   ```\n\n### 下载[标签发布版本][releases-url]  Download tagged release version\n   您必须定义版本。从[标签列表][tags-url]里选择版本替换`v5.1.2`。\n\n   [![curl-tar-image]][curl-tar-url]\n\n   ```sh\n   $ mkdir themes/next\n   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1\n   ```\n\n   [![git-image]][git-url]\n\n   ```sh\n   $ git clone --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next\n   ```\n\n### 下载[最新的 master 分支][download-latest-url]  Download latest master branch\n  可能会 **不稳定**, 但是包含最新的特色，推荐开发者下载.\n\n   [![curl-tar-image]][curl-tar-url]\n\n   ```sh\n   $ mkdir themes/next\n   $ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1\n   ```\n\n   [![git-image]][git-url]\n\n   ```sh\n   $ git clone https://github.com/iissnan/hexo-theme-next themes/next\n   ```\n\n  使用克隆命令，你将得到**整个存储库**。而且在任何时候你都可以切换到任何标签发布版本。\n  获取标签列表：\n\n   ```sh\n   $ cd themes/next\n   $ git tag -l\n   …\n   v5.0.0\n   v5.0.1\n   v5.1.0\n   v5.1.1\n   v5.1.2\n   ```\n\n   例如, 你想要切换到`v5.1.0` [标签发布版本][tags-url]. 输入以下命令:\n\n   ```sh\n   $ git checkout tags/v5.1.0\n   Note: checking out 'tags/v5.1.0'.\n   …\n   HEAD now on 1f72f68... CSS: Remove global list-style setting of ul\n   ```\n\n   如果你想切换回 [master 分支][commits-url]的话, 输入这个命令:\n\n   ```sh\n   $ git checkout master\n   ```\n\n**3.** 在 **hexo 根目录下** 的配置文件`_config.yml`里设置主题:\n\n    theme: next\n    \n### Bugs\n对于那些遇到 **Error: Cannot find module 'hexo-util'** [问题](https://github.com/iissnan/hexo-theme-next/issues/1490)的人, 请检查你的NPM 版本. \n\n- `版本 > 3`: 如果仍然不行的话，请移除 `node_modules` 文件 然后重新安装，使用 `npm install`命令。\n- `版本 < 3`: 请通过`npm install --save-dev hexo-util`命令添加`hexo-util`到你的站点包依赖里\n\n## 更新 Update\n\n```sh\n$ cd themes/next\n$ git pull\n```\n\n### Bugs\n\n> 提交您的更改或存储它们，然后才能合并。\n\n您必须提交，存储或放弃本地更改. 看 [here](https://stackoverflow.com/a/15745424/5861495) 是如何做的。\n\n### 使用Hexo data files([#328](https://github.com/iissnan/hexo-theme-next/issues/328))配置主题  Theme configurations using Hexo data files #328\n\n\n目前升级 NexT 主题的时候并不是非常的流畅。若使用 `git pull` 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 `_config.yml` 文件。\n\n在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点：\n\n1. 配置分离成了两个部分\n2. 用户可能会疑惑一些选项该放置在哪里比较合适\n\n为了解决这个问题， NexT 将会使用 Hexo 的 [Data Files](https://hexo.io/docs/data-files.html) 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。\n\n若你比较喜欢 Hexo 2.x 版本，可以继续使用原先的配置方式。 NexT 保持着向下兼容。\n\n\n#### 特性 Benefits\n\n通过这个特性，你可以将所有的主题配置放置在站点的 `source/_data/next.yml` 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 `next.yml` 中做相应调整即可\n\n\n#### 如何使用这个特性 How to use this feature\n\n1. 请先确保你所使用的 Hexo 版本在 3 以上\n2. 在站点的 `source/_data` 目录下新建 `next.yml` 文件（`_data`目录可能需要新建）\n3. 迁移站点配置文件和主题配置文件中的配置到 `next.yml` 中\n4. 使用 `--config source/_data/next.yml` 参数启动服务器, 生成或者部署。\\\n   例如: `hexo clean --config source/_data/next.yml && hexo g --config source/_data/next.yml`。\n\n## 特色 Features \n\n### 支持多国语言, 包括: \n:cn: 简体中文 & 繁体中文<br>\n:us: 英语<br>\n:ru: 俄语<br>\n:fr: 法语<br>\n:de: 德语<br>\n:jp: 日语<br>\n:indonesia: 印度尼西亚语<br>\n:portugal: 葡萄牙语 (巴西)<br>\n:kr: 朝鲜语<br>\n:it: 意大利语<br>\n:netherlands: 荷兰语\n\n默认语言是英语。\n\n```yml\nlanguage: en\n# language: zh-Hans\n# language: zh-hk\n# language: zh-tw\n# language: ru\n# language: fr-FR\n# language: de\n# language: ja\n# language: id\n# language: pt\n# language: pt-BR\n# language: ko\n# language: it\n# language: nl-NL\n```\n\n在站点配置文件`_config.yml`中可以将语言切换成中文\n\n```yml\nlanguage: zh-Hans\n```\n\n### 评论支持 Comment support\n\nNexT 已经原生支持 `多说` and `Disqus` 评论系统。\n\n添加以下代码到你的主题配置文件 `_config.yml`:\n\n```yml\nduoshuo:\n  enable: true\n  shortname: your-duoshuo-shortname\n```\n\n或者\n\n```yml\ndisqus_shortname: your-disqus-shortname\n```\n\n### 标签页 Tags page\n\n> 添加一个标签页面，里面包含您网站中的所有标签。\n\n- 创建一个名为 `tags` 页面\n\n        hexo new page \"tags\"\n\n- 编辑标签页, 设置页面类型为`tags`.\n\n        title: All tags\n        date: 2014-12-22 12:39:04\n        type: \"tags\"\n\n- 添加 `tags` 到主题配置文件 `_config.yml` 里:\n\n        menu:\n          home: /\n          archives: /archives\n          tags: /tags\n\n### 分类页 Categories page\n\n> 添加一个分类页面，里面包含您网站中的所有分类。\n\n- 创建一个名为 `categories` 页面\n\n        hexo new page \"categories\"\n\n- 编辑分类页, 设置页面类型为 `categories`.\n\n        title: All categories\n        date: 2014-12-22 12:39:04\n        type: \"categories\"\n\n- 添加 `categories` 到主题配置文件 `_config.yml` 里:\n\n        menu:\n          home: /\n          archives: /archives\n          categories: /categories\n\n### 社交媒体 Social Media\n\nNexT 可以自动添加链接到您的社交媒体帐户里:\n\n```yml\nsocial:\n  GitHub: your-github-url\n  Twitter: your-twitter-url\n  Weibo: your-weibo-url\n  DouBan: your-douban-url\n  ZhiHu: your-zhihu-url\n```\n\n### Feed 链接 Feed link\n\n> 显示 feed 链接。\n\n在主题配置文件`_config.yml`里设置`rss` , 如下所示:\n\n1. `rss: false` 会禁用 feed 链接。\n2. `rss:  ` 使用站点 feed 链接。这是默认的选项。\n\n    按照插件[hexo-generator-feed](https://github.com/hexojs/hexo-generator-feed)的README中的安装说明进行操作。在完成这个插件的配置后，Feed链接也生成好了\n\n3. `rss: http://your-feed-url` 设置你的 feed 链接.\n\n### 内置5种代码高亮主题 Up to 5 code highlight themes built-in\n\nNexT 使用的是 [Tomorrow 主题](https://github.com/chriskempson/tomorrow-theme) ，一共有5种主题供你选择。\nNext 默认使用 `normal`. 下面是 `normal` 和 `night` 主题的预览:\n\n![Tomorrow Normal Preview](http://iissnan.com/nexus/next/tomorrow-normal.png)\n![Tomorrow Night Preview](http://iissnan.com/nexus/next/tomorrow-night.png)\n\n查看更多信息点击[Tomorrow 主题](https://github.com/chriskempson/tomorrow-theme)。\n\n## 配置 Configuration\n\nNexT 的配置很少\n\n```yml\n\n# Menu configuration.\nmenu:\n  home: /\n  archives: /archives\n\n# Favicon\nfavicon: /favicon.ico\n\n# Avatar (put the image into next/source/images/)\n# can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)\navatar: /default_avatar.png\n\n# Code highlight theme\n# available: normal | night | night eighties | night blue | night bright\nhighlight_theme: normal\n\n# Fancybox for image gallery\nfancybox: true\n\n# Specify the date when the site was setup\nsince: 2013\n\n```\n\n\n## 浏览器支持 Browser support\n\n![Browser support](http://iissnan.com/nexus/next/browser-support.png)\n\n![Browser Stack](How-To-Next/browserstack_logo.png)(https://www.browserstack.com/)\n>**BrowserStack** is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.\n\n## 贡献 Contributing\n\n接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的`Pull Request`。\n\nAny types of contribution are welcome. Thanks.\n\n**ATTENTION! Contributors on Chinese docs needed!**\\\nNeed to translate from [English docs](README.md) to Chinese docs.\\\nAny help wanted!\\\nThank's a lot!\n\n## 开发 Development\n\nNexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。\n\nNexT is built for easily use with elegant appearance. First things first, always keep things simple.\n\n## [开发历史 Changelog](https://github.com/iissnan/hexo-theme-next/wiki/Changelog)\n\n\n\n[browser-image]: https://img.shields.io/badge/browser-%20chrome%20%7C%20firefox%20%7C%20opera%20%7C%20safari%20%7C%20ie%20%3E%3D%209-lightgrey.svg\n[browser-url]: https://www.browserstack.com\n\n[gitter-image]: https://badges.gitter.im/Join%20Chat.svg\n[gitter-url]: https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&utm_medium=badge&utm_campaign=pr-badge&utm_content=badge\n\n[travis-image]: https://travis-ci.org/iissnan/hexo-theme-next.svg?branch=master\n[travis-url]: https://travis-ci.org/iissnan/hexo-theme-next?branch=master \"Travis CI\"\n\n[hexo-image]: https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg\n[hexo-url]: http://hexo.io\n\n[mnt-image]: https://img.shields.io/maintenance/yes/2017.svg\n[rel-image]: https://img.shields.io/github/release/iissnan/hexo-theme-next.svg\n<!--[lic-image]: https://img.shields.io/npm/l/hexo-theme-next.svg-->\n[lic-image]: https://img.shields.io/dub/l/vibe-d.svg\n\n[git-image]: https://img.shields.io/badge/install%20with%20-git-blue.svg\n[curl-tar-image]: https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg\n[curl-tar-wget-image]: https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar%20%7C%20wget-blue.svg\n[git-url]: http://lmgtfy.com/?q=linux+git+install\n[curl-tar-url]: http://lmgtfy.com/?q=linux+curl+tar+install\n[curl-tar-wget-url]: http://lmgtfy.com/?q=linux+curl+tar+wget+install\n\n[download-latest-url]: https://github.com/iissnan/hexo-theme-next/archive/master.zip\n[releases-latest-url]: https://github.com/iissnan/hexo-theme-next/releases/latest\n[releases-url]: https://github.com/iissnan/hexo-theme-next/releases\n[tags-url]: https://github.com/iissnan/hexo-theme-next/tags\n[commits-url]: https://github.com/iissnan/hexo-theme-next/commits/master\n","slug":"How-To-Next","published":1,"updated":"2018-12-03T07:04:30.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0my6001brd4l6phzah9i","content":"<h1 id=\"N-e-x-T\"><a href=\"#N-e-x-T\" class=\"headerlink\" title=\" N e x T\"></a><div align=\"center\"><a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\"><img align=\"center\" width=\"56\" height=\"56\" src=\"/2018/11/26/How-To-Next/logo.svg\"></a> N e x T</div></h1><p align=\"center\">NexT 是一个高质量并且优雅的<a href=\"http://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a> 主题。这是精心制作做出来的 hexo 主题。</p>\n\n<p><img src=\"http://iissnan.com/nexus/next/next-schemes.jpg\" alt=\"NexT Schemes\"></p>\n<p><a href=\"https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\" target=\"_blank\" rel=\"noopener\"><img src=\"https://badges.gitter.im/Join%20Chat.svg\" alt=\"Join the chat at https://gitter.im/iissnan/hexo-theme-next\"></a><br><a href=\"https://github.com/iissnan/hexo-theme-next/commits/master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/maintenance/yes/2017.svg\" alt=\"mnt-image\"></a><br><a href=\"https://travis-ci.org/iissnan/hexo-theme-next?branch=master\" title=\"Travis CI\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/iissnan/hexo-theme-next.svg?branch=master\" alt=\"travis-image\"></a><br><a href=\"https://github.com/iissnan/hexo-theme-next/releases\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/release/iissnan/hexo-theme-next.svg\" alt=\"rel-image\"></a><br><a href=\"http://hexo.io\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg\" alt=\"hexo-image\"></a><br><a href=\"LICENSE\"><img src=\"https://img.shields.io/dub/l/vibe-d.svg\" alt=\"lic-image\"></a></p>\n<ul>\n<li><a href=\"http://theme-next.iissnan.com\" target=\"_blank\">NexT 使用文档</a> |  <a href=\"README.md\">English Documentation</a></li>\n</ul>\n<h2 id=\"实时预览-Live-Preview\"><a href=\"#实时预览-Live-Preview\" class=\"headerlink\" title=\"实时预览 Live Preview\"></a>实时预览 Live Preview</h2><ul>\n<li>:heart_decoration: Muse 方案: <a href=\"https://notes.wanghao.work\" target=\"_blank\" rel=\"noopener\">XiaMo</a> | <a href=\"https://oawan.me\" target=\"_blank\" rel=\"noopener\">OAwan</a> | <a href=\"http://hui-wang.info\" target=\"_blank\" rel=\"noopener\">Hui Wang</a></li>\n<li>:six_pointed_star: Mist 方案: <a href=\"https://blog.zzbd.org\" target=\"_blank\" rel=\"noopener\">Jeff</a> | <a href=\"http://uchuhimo.me\" target=\"_blank\" rel=\"noopener\">uchuhimo</a> | <a href=\"http://www.ixirong.com\" target=\"_blank\" rel=\"noopener\">xirong</a></li>\n<li>:pisces: Pisces 方案: <a href=\"http://notes.iissnan.com\" target=\"_blank\" rel=\"noopener\">Vi</a> | <a href=\"https://acris.me\" target=\"_blank\" rel=\"noopener\">Acris</a> | <a href=\"https://rainylog.com\" target=\"_blank\" rel=\"noopener\">Rainy</a></li>\n<li>:gemini: Gemini 方案: <a href=\"https://almostover.ru\" target=\"_blank\" rel=\"noopener\">Ivan.Nginx</a> | <a href=\"http://sh.alynx.xyz\" target=\"_blank\" rel=\"noopener\">Alynx</a> | <a href=\"https://raincal.top\" target=\"_blank\" rel=\"noopener\">Raincal</a></li>\n</ul>\n<p>更多 NexT 例子点击 <a href=\"https://github.com/iissnan/hexo-theme-next/issues/119\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"安装-Installation\"><a href=\"#安装-Installation\" class=\"headerlink\" title=\"安装 Installation\"></a>安装 Installation</h2><p><strong>1.</strong> 在终端切换到<strong>hexo 根</strong>目录. 在hexo目录下一定有 <code>node_modules</code>, <code>source</code>, <code>themes</code> 和其他文件夹:<br>   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> hexo</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">_config.yml  node_modules  package.json  public  scaffolds  <span class=\"built_in\">source</span>  themes</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.</strong> 从 github 上获取主题 。这里有几种方式来获取主题:</p>\n<h3 id=\"下载最新发布的版本-Download-tagged-release-version\"><a href=\"#下载最新发布的版本-Download-tagged-release-version\" class=\"headerlink\" title=\"下载最新发布的版本  Download tagged release version\"></a>下载<a href=\"https://github.com/iissnan/hexo-theme-next/releases/latest\" target=\"_blank\" rel=\"noopener\">最新发布的版本</a>  Download tagged release version</h3><p>   在大多数情况下 <strong>稳定</strong>。 推荐用户下载这个。</p>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+curl+tar+wget+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar%20%7C%20wget-blue.svg\" alt=\"curl-tar-wget-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir themes/next</span><br><span class=\"line\">$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class=\"string\">'\"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载标签发布版本-Download-tagged-release-version\"><a href=\"#下载标签发布版本-Download-tagged-release-version\" class=\"headerlink\" title=\"下载标签发布版本  Download tagged release version\"></a>下载<a href=\"https://github.com/iissnan/hexo-theme-next/releases\" target=\"_blank\" rel=\"noopener\">标签发布版本</a>  Download tagged release version</h3><p>   您必须定义版本。从<a href=\"https://github.com/iissnan/hexo-theme-next/tags\" target=\"_blank\" rel=\"noopener\">标签列表</a>里选择版本替换<code>v5.1.2</code>。</p>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+curl+tar+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg\" alt=\"curl-tar-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir themes/next</span><br><span class=\"line\">$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+git+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-git-blue.svg\" alt=\"git-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载最新的-master-分支-Download-latest-master-branch\"><a href=\"#下载最新的-master-分支-Download-latest-master-branch\" class=\"headerlink\" title=\"下载最新的 master 分支  Download latest master branch\"></a>下载<a href=\"https://github.com/iissnan/hexo-theme-next/archive/master.zip\" target=\"_blank\" rel=\"noopener\">最新的 master 分支</a>  Download latest master branch</h3><p>  可能会 <strong>不稳定</strong>, 但是包含最新的特色，推荐开发者下载.</p>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+curl+tar+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg\" alt=\"curl-tar-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir themes/next</span><br><span class=\"line\">$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+git+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-git-blue.svg\" alt=\"git-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>  使用克隆命令，你将得到<strong>整个存储库</strong>。而且在任何时候你都可以切换到任何标签发布版本。<br>  获取标签列表：</p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> themes/next</span><br><span class=\"line\">$ git tag -l</span><br><span class=\"line\">…</span><br><span class=\"line\">v5.0.0</span><br><span class=\"line\">v5.0.1</span><br><span class=\"line\">v5.1.0</span><br><span class=\"line\">v5.1.1</span><br><span class=\"line\">v5.1.2</span><br></pre></td></tr></table></figure>\n<p>   例如, 你想要切换到<code>v5.1.0</code> <a href=\"https://github.com/iissnan/hexo-theme-next/tags\" target=\"_blank\" rel=\"noopener\">标签发布版本</a>. 输入以下命令:</p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout tags/v5.1.0</span><br><span class=\"line\">Note: checking out <span class=\"string\">'tags/v5.1.0'</span>.</span><br><span class=\"line\">…</span><br><span class=\"line\">HEAD now on 1f72f68... CSS: Remove global list-style setting of ul</span><br></pre></td></tr></table></figure>\n<p>   如果你想切换回 <a href=\"https://github.com/iissnan/hexo-theme-next/commits/master\" target=\"_blank\" rel=\"noopener\">master 分支</a>的话, 输入这个命令:</p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p><strong>3.</strong> 在 <strong>hexo 根目录下</strong> 的配置文件<code>_config.yml</code>里设置主题:</p>\n<pre><code>theme: next\n</code></pre><h3 id=\"Bugs\"><a href=\"#Bugs\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h3><p>对于那些遇到 <strong>Error: Cannot find module ‘hexo-util’</strong> <a href=\"https://github.com/iissnan/hexo-theme-next/issues/1490\" target=\"_blank\" rel=\"noopener\">问题</a>的人, 请检查你的NPM 版本. </p>\n<ul>\n<li><code>版本 &gt; 3</code>: 如果仍然不行的话，请移除 <code>node_modules</code> 文件 然后重新安装，使用 <code>npm install</code>命令。</li>\n<li><code>版本 &lt; 3</code>: 请通过<code>npm install --save-dev hexo-util</code>命令添加<code>hexo-util</code>到你的站点包依赖里</li>\n</ul>\n<h2 id=\"更新-Update\"><a href=\"#更新-Update\" class=\"headerlink\" title=\"更新 Update\"></a>更新 Update</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> themes/next</span><br><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<h3 id=\"Bugs-1\"><a href=\"#Bugs-1\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h3><blockquote>\n<p>提交您的更改或存储它们，然后才能合并。</p>\n</blockquote>\n<p>您必须提交，存储或放弃本地更改. 看 <a href=\"https://stackoverflow.com/a/15745424/5861495\" target=\"_blank\" rel=\"noopener\">here</a> 是如何做的。</p>\n<h3 id=\"使用Hexo-data-files-328-配置主题-Theme-configurations-using-Hexo-data-files-328\"><a href=\"#使用Hexo-data-files-328-配置主题-Theme-configurations-using-Hexo-data-files-328\" class=\"headerlink\" title=\"使用Hexo data files(#328)配置主题  Theme configurations using Hexo data files #328\"></a>使用Hexo data files(<a href=\"https://github.com/iissnan/hexo-theme-next/issues/328\" target=\"_blank\" rel=\"noopener\">#328</a>)配置主题  Theme configurations using Hexo data files #328</h3><p>目前升级 NexT 主题的时候并不是非常的流畅。若使用 <code>git pull</code> 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 <code>_config.yml</code> 文件。</p>\n<p>在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点：</p>\n<ol>\n<li>配置分离成了两个部分</li>\n<li>用户可能会疑惑一些选项该放置在哪里比较合适</li>\n</ol>\n<p>为了解决这个问题， NexT 将会使用 Hexo 的 <a href=\"https://hexo.io/docs/data-files.html\" target=\"_blank\" rel=\"noopener\">Data Files</a> 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。</p>\n<p>若你比较喜欢 Hexo 2.x 版本，可以继续使用原先的配置方式。 NexT 保持着向下兼容。</p>\n<h4 id=\"特性-Benefits\"><a href=\"#特性-Benefits\" class=\"headerlink\" title=\"特性 Benefits\"></a>特性 Benefits</h4><p>通过这个特性，你可以将所有的主题配置放置在站点的 <code>source/_data/next.yml</code> 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 <code>next.yml</code> 中做相应调整即可</p>\n<h4 id=\"如何使用这个特性-How-to-use-this-feature\"><a href=\"#如何使用这个特性-How-to-use-this-feature\" class=\"headerlink\" title=\"如何使用这个特性 How to use this feature\"></a>如何使用这个特性 How to use this feature</h4><ol>\n<li>请先确保你所使用的 Hexo 版本在 3 以上</li>\n<li>在站点的 <code>source/_data</code> 目录下新建 <code>next.yml</code> 文件（<code>_data</code>目录可能需要新建）</li>\n<li>迁移站点配置文件和主题配置文件中的配置到 <code>next.yml</code> 中</li>\n<li>使用 <code>--config source/_data/next.yml</code> 参数启动服务器, 生成或者部署。\\<br>例如: <code>hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml</code>。</li>\n</ol>\n<h2 id=\"特色-Features\"><a href=\"#特色-Features\" class=\"headerlink\" title=\"特色 Features\"></a>特色 Features</h2><h3 id=\"支持多国语言-包括\"><a href=\"#支持多国语言-包括\" class=\"headerlink\" title=\"支持多国语言, 包括:\"></a>支持多国语言, 包括:</h3><p>:cn: 简体中文 &amp; 繁体中文<br><br>:us: 英语<br><br>:ru: 俄语<br><br>:fr: 法语<br><br>:de: 德语<br><br>:jp: 日语<br><br>:indonesia: 印度尼西亚语<br><br>:portugal: 葡萄牙语 (巴西)<br><br>:kr: 朝鲜语<br><br>:it: 意大利语<br><br>:netherlands: 荷兰语</p>\n<p>默认语言是英语。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">en</span></span><br><span class=\"line\"><span class=\"comment\"># language: zh-Hans</span></span><br><span class=\"line\"><span class=\"comment\"># language: zh-hk</span></span><br><span class=\"line\"><span class=\"comment\"># language: zh-tw</span></span><br><span class=\"line\"><span class=\"comment\"># language: ru</span></span><br><span class=\"line\"><span class=\"comment\"># language: fr-FR</span></span><br><span class=\"line\"><span class=\"comment\"># language: de</span></span><br><span class=\"line\"><span class=\"comment\"># language: ja</span></span><br><span class=\"line\"><span class=\"comment\"># language: id</span></span><br><span class=\"line\"><span class=\"comment\"># language: pt</span></span><br><span class=\"line\"><span class=\"comment\"># language: pt-BR</span></span><br><span class=\"line\"><span class=\"comment\"># language: ko</span></span><br><span class=\"line\"><span class=\"comment\"># language: it</span></span><br><span class=\"line\"><span class=\"comment\"># language: nl-NL</span></span><br></pre></td></tr></table></figure>\n<p>在站点配置文件<code>_config.yml</code>中可以将语言切换成中文</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-Hans</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"评论支持-Comment-support\"><a href=\"#评论支持-Comment-support\" class=\"headerlink\" title=\"评论支持 Comment support\"></a>评论支持 Comment support</h3><p>NexT 已经原生支持 <code>多说</code> and <code>Disqus</code> 评论系统。</p>\n<p>添加以下代码到你的主题配置文件 <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">duoshuo:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  shortname:</span> <span class=\"string\">your-duoshuo-shortname</span></span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">disqus_shortname:</span> <span class=\"string\">your-disqus-shortname</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"标签页-Tags-page\"><a href=\"#标签页-Tags-page\" class=\"headerlink\" title=\"标签页 Tags page\"></a>标签页 Tags page</h3><blockquote>\n<p>添加一个标签页面，里面包含您网站中的所有标签。</p>\n</blockquote>\n<ul>\n<li><p>创建一个名为 <code>tags</code> 页面</p>\n<pre><code>hexo new page &quot;tags&quot;\n</code></pre></li>\n<li><p>编辑标签页, 设置页面类型为<code>tags</code>.</p>\n<pre><code>title: All tags\ndate: 2014-12-22 12:39:04\ntype: &quot;tags&quot;\n</code></pre></li>\n<li><p>添加 <code>tags</code> 到主题配置文件 <code>_config.yml</code> 里:</p>\n<pre><code>menu:\n  home: /\n  archives: /archives\n  tags: /tags\n</code></pre></li>\n</ul>\n<h3 id=\"分类页-Categories-page\"><a href=\"#分类页-Categories-page\" class=\"headerlink\" title=\"分类页 Categories page\"></a>分类页 Categories page</h3><blockquote>\n<p>添加一个分类页面，里面包含您网站中的所有分类。</p>\n</blockquote>\n<ul>\n<li><p>创建一个名为 <code>categories</code> 页面</p>\n<pre><code>hexo new page &quot;categories&quot;\n</code></pre></li>\n<li><p>编辑分类页, 设置页面类型为 <code>categories</code>.</p>\n<pre><code>title: All categories\ndate: 2014-12-22 12:39:04\ntype: &quot;categories&quot;\n</code></pre></li>\n<li><p>添加 <code>categories</code> 到主题配置文件 <code>_config.yml</code> 里:</p>\n<pre><code>menu:\n  home: /\n  archives: /archives\n  categories: /categories\n</code></pre></li>\n</ul>\n<h3 id=\"社交媒体-Social-Media\"><a href=\"#社交媒体-Social-Media\" class=\"headerlink\" title=\"社交媒体 Social Media\"></a>社交媒体 Social Media</h3><p>NexT 可以自动添加链接到您的社交媒体帐户里:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">social:</span></span><br><span class=\"line\"><span class=\"attr\">  GitHub:</span> <span class=\"string\">your-github-url</span></span><br><span class=\"line\"><span class=\"attr\">  Twitter:</span> <span class=\"string\">your-twitter-url</span></span><br><span class=\"line\"><span class=\"attr\">  Weibo:</span> <span class=\"string\">your-weibo-url</span></span><br><span class=\"line\"><span class=\"attr\">  DouBan:</span> <span class=\"string\">your-douban-url</span></span><br><span class=\"line\"><span class=\"attr\">  ZhiHu:</span> <span class=\"string\">your-zhihu-url</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Feed-链接-Feed-link\"><a href=\"#Feed-链接-Feed-link\" class=\"headerlink\" title=\"Feed 链接 Feed link\"></a>Feed 链接 Feed link</h3><blockquote>\n<p>显示 feed 链接。</p>\n</blockquote>\n<p>在主题配置文件<code>_config.yml</code>里设置<code>rss</code> , 如下所示:</p>\n<ol>\n<li><code>rss: false</code> 会禁用 feed 链接。</li>\n<li><p><code>rss:</code> 使用站点 feed 链接。这是默认的选项。</p>\n<p> 按照插件<a href=\"https://github.com/hexojs/hexo-generator-feed\" target=\"_blank\" rel=\"noopener\">hexo-generator-feed</a>的README中的安装说明进行操作。在完成这个插件的配置后，Feed链接也生成好了</p>\n</li>\n<li><p><code>rss: http://your-feed-url</code> 设置你的 feed 链接.</p>\n</li>\n</ol>\n<h3 id=\"内置5种代码高亮主题-Up-to-5-code-highlight-themes-built-in\"><a href=\"#内置5种代码高亮主题-Up-to-5-code-highlight-themes-built-in\" class=\"headerlink\" title=\"内置5种代码高亮主题 Up to 5 code highlight themes built-in\"></a>内置5种代码高亮主题 Up to 5 code highlight themes built-in</h3><p>NexT 使用的是 <a href=\"https://github.com/chriskempson/tomorrow-theme\" target=\"_blank\" rel=\"noopener\">Tomorrow 主题</a> ，一共有5种主题供你选择。<br>Next 默认使用 <code>normal</code>. 下面是 <code>normal</code> 和 <code>night</code> 主题的预览:</p>\n<p><img src=\"http://iissnan.com/nexus/next/tomorrow-normal.png\" alt=\"Tomorrow Normal Preview\"><br><img src=\"http://iissnan.com/nexus/next/tomorrow-night.png\" alt=\"Tomorrow Night Preview\"></p>\n<p>查看更多信息点击<a href=\"https://github.com/chriskempson/tomorrow-theme\" target=\"_blank\" rel=\"noopener\">Tomorrow 主题</a>。</p>\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置 Configuration\"></a>配置 Configuration</h2><p>NexT 的配置很少</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Menu configuration.</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"attr\">  archives:</span> <span class=\"string\">/archives</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Favicon</span></span><br><span class=\"line\"><span class=\"attr\">favicon:</span> <span class=\"string\">/favicon.ico</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Avatar (put the image into next/source/images/)</span></span><br><span class=\"line\"><span class=\"comment\"># can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)</span></span><br><span class=\"line\"><span class=\"attr\">avatar:</span> <span class=\"string\">/default_avatar.png</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Code highlight theme</span></span><br><span class=\"line\"><span class=\"comment\"># available: normal | night | night eighties | night blue | night bright</span></span><br><span class=\"line\"><span class=\"attr\">highlight_theme:</span> <span class=\"string\">normal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Fancybox for image gallery</span></span><br><span class=\"line\"><span class=\"attr\">fancybox:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Specify the date when the site was setup</span></span><br><span class=\"line\"><span class=\"attr\">since:</span> <span class=\"number\">2013</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器支持-Browser-support\"><a href=\"#浏览器支持-Browser-support\" class=\"headerlink\" title=\"浏览器支持 Browser support\"></a>浏览器支持 Browser support</h2><p><img src=\"http://iissnan.com/nexus/next/browser-support.png\" alt=\"Browser support\"></p>\n<p><img src=\"/2016/11/28/How-To-Next/browserstack_logo.png\" alt=\"Browser Stack\">(<a href=\"https://www.browserstack.com/\" target=\"_blank\" rel=\"noopener\">https://www.browserstack.com/</a>)</p>\n<blockquote>\n<p><strong>BrowserStack</strong> is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.</p>\n</blockquote>\n<h2 id=\"贡献-Contributing\"><a href=\"#贡献-Contributing\" class=\"headerlink\" title=\"贡献 Contributing\"></a>贡献 Contributing</h2><p>接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的<code>Pull Request</code>。</p>\n<p>Any types of contribution are welcome. Thanks.</p>\n<p><strong>ATTENTION! Contributors on Chinese docs needed!</strong>\\<br>Need to translate from <a href=\"README.md\">English docs</a> to Chinese docs.\\<br>Any help wanted!\\<br>Thank’s a lot!</p>\n<h2 id=\"开发-Development\"><a href=\"#开发-Development\" class=\"headerlink\" title=\"开发 Development\"></a>开发 Development</h2><p>NexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。</p>\n<p>NexT is built for easily use with elegant appearance. First things first, always keep things simple.</p>\n<h2 id=\"开发历史-Changelog\"><a href=\"#开发历史-Changelog\" class=\"headerlink\" title=\"开发历史 Changelog\"></a><a href=\"https://github.com/iissnan/hexo-theme-next/wiki/Changelog\" target=\"_blank\" rel=\"noopener\">开发历史 Changelog</a></h2><!--[lic-image]: https://img.shields.io/npm/l/hexo-theme-next.svg-->\n<div><h1>おススメ記事<span style=\"font-size:0.45em; color:gray\">（<a href=\"https://github.com/huiwang/hexo-recommended-posts\">hexo-recommend-posts</a>）</span></h1><ul><li><a href=\"https://cyouraku.github.io/2016/11/28/How-To-Hexo/\">How To Hexo</a></li></ul></div>","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h1 id=\"N-e-x-T\"><a href=\"#N-e-x-T\" class=\"headerlink\" title=\" N e x T\"></a><div align=\"center\"><a href=\"https://github.com/iissnan/hexo-theme-next\" target=\"_blank\" rel=\"noopener\"><img align=\"center\" width=\"56\" height=\"56\" src=\"/2018/11/26/How-To-Next/logo.svg\"></a> N e x T</div></h1><p align=\"center\">NexT 是一个高质量并且优雅的<a href=\"http://hexo.io\" target=\"_blank\" rel=\"noopener\">Hexo</a> 主题。这是精心制作做出来的 hexo 主题。</p>\n\n<p><img src=\"http://iissnan.com/nexus/next/next-schemes.jpg\" alt=\"NexT Schemes\"></p>\n<p><a href=\"https://gitter.im/iissnan/hexo-theme-next?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge&amp;utm_content=badge\" target=\"_blank\" rel=\"noopener\"><img src=\"https://badges.gitter.im/Join%20Chat.svg\" alt=\"Join the chat at https://gitter.im/iissnan/hexo-theme-next\"></a><br><a href=\"https://github.com/iissnan/hexo-theme-next/commits/master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/maintenance/yes/2017.svg\" alt=\"mnt-image\"></a><br><a href=\"https://travis-ci.org/iissnan/hexo-theme-next?branch=master\" title=\"Travis CI\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/iissnan/hexo-theme-next.svg?branch=master\" alt=\"travis-image\"></a><br><a href=\"https://github.com/iissnan/hexo-theme-next/releases\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/github/release/iissnan/hexo-theme-next.svg\" alt=\"rel-image\"></a><br><a href=\"http://hexo.io\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/hexo-%3E%3D%203.0-blue.svg\" alt=\"hexo-image\"></a><br><a href=\"LICENSE\"><img src=\"https://img.shields.io/dub/l/vibe-d.svg\" alt=\"lic-image\"></a></p>\n<ul>\n<li><a href=\"http://theme-next.iissnan.com\" target=\"_blank\">NexT 使用文档</a> |  <a href=\"README.md\">English Documentation</a></li>\n</ul>\n<h2 id=\"实时预览-Live-Preview\"><a href=\"#实时预览-Live-Preview\" class=\"headerlink\" title=\"实时预览 Live Preview\"></a>实时预览 Live Preview</h2><ul>\n<li>:heart_decoration: Muse 方案: <a href=\"https://notes.wanghao.work\" target=\"_blank\" rel=\"noopener\">XiaMo</a> | <a href=\"https://oawan.me\" target=\"_blank\" rel=\"noopener\">OAwan</a> | <a href=\"http://hui-wang.info\" target=\"_blank\" rel=\"noopener\">Hui Wang</a></li>\n<li>:six_pointed_star: Mist 方案: <a href=\"https://blog.zzbd.org\" target=\"_blank\" rel=\"noopener\">Jeff</a> | <a href=\"http://uchuhimo.me\" target=\"_blank\" rel=\"noopener\">uchuhimo</a> | <a href=\"http://www.ixirong.com\" target=\"_blank\" rel=\"noopener\">xirong</a></li>\n<li>:pisces: Pisces 方案: <a href=\"http://notes.iissnan.com\" target=\"_blank\" rel=\"noopener\">Vi</a> | <a href=\"https://acris.me\" target=\"_blank\" rel=\"noopener\">Acris</a> | <a href=\"https://rainylog.com\" target=\"_blank\" rel=\"noopener\">Rainy</a></li>\n<li>:gemini: Gemini 方案: <a href=\"https://almostover.ru\" target=\"_blank\" rel=\"noopener\">Ivan.Nginx</a> | <a href=\"http://sh.alynx.xyz\" target=\"_blank\" rel=\"noopener\">Alynx</a> | <a href=\"https://raincal.top\" target=\"_blank\" rel=\"noopener\">Raincal</a></li>\n</ul>\n<p>更多 NexT 例子点击 <a href=\"https://github.com/iissnan/hexo-theme-next/issues/119\" target=\"_blank\" rel=\"noopener\">这里</a>.</p>\n<h2 id=\"安装-Installation\"><a href=\"#安装-Installation\" class=\"headerlink\" title=\"安装 Installation\"></a>安装 Installation</h2><p><strong>1.</strong> 在终端切换到<strong>hexo 根</strong>目录. 在hexo目录下一定有 <code>node_modules</code>, <code>source</code>, <code>themes</code> 和其他文件夹:<br>   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> hexo</span><br><span class=\"line\">$ ls</span><br><span class=\"line\">_config.yml  node_modules  package.json  public  scaffolds  <span class=\"built_in\">source</span>  themes</span><br></pre></td></tr></table></figure></p>\n<p><strong>2.</strong> 从 github 上获取主题 。这里有几种方式来获取主题:</p>\n<h3 id=\"下载最新发布的版本-Download-tagged-release-version\"><a href=\"#下载最新发布的版本-Download-tagged-release-version\" class=\"headerlink\" title=\"下载最新发布的版本  Download tagged release version\"></a>下载<a href=\"https://github.com/iissnan/hexo-theme-next/releases/latest\" target=\"_blank\" rel=\"noopener\">最新发布的版本</a>  Download tagged release version</h3><p>   在大多数情况下 <strong>稳定</strong>。 推荐用户下载这个。</p>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+curl+tar+wget+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar%20%7C%20wget-blue.svg\" alt=\"curl-tar-wget-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir themes/next</span><br><span class=\"line\">$ curl -s https://api.github.com/repos/iissnan/hexo-theme-next/releases/latest | grep tarball_url | cut -d <span class=\"string\">'\"'</span> -f 4 | wget -i - -O- | tar -zx -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载标签发布版本-Download-tagged-release-version\"><a href=\"#下载标签发布版本-Download-tagged-release-version\" class=\"headerlink\" title=\"下载标签发布版本  Download tagged release version\"></a>下载<a href=\"https://github.com/iissnan/hexo-theme-next/releases\" target=\"_blank\" rel=\"noopener\">标签发布版本</a>  Download tagged release version</h3><p>   您必须定义版本。从<a href=\"https://github.com/iissnan/hexo-theme-next/tags\" target=\"_blank\" rel=\"noopener\">标签列表</a>里选择版本替换<code>v5.1.2</code>。</p>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+curl+tar+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg\" alt=\"curl-tar-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir themes/next</span><br><span class=\"line\">$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball/v5.1.2 | tar -zxv -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+git+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-git-blue.svg\" alt=\"git-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> --branch v5.1.2 https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<h3 id=\"下载最新的-master-分支-Download-latest-master-branch\"><a href=\"#下载最新的-master-分支-Download-latest-master-branch\" class=\"headerlink\" title=\"下载最新的 master 分支  Download latest master branch\"></a>下载<a href=\"https://github.com/iissnan/hexo-theme-next/archive/master.zip\" target=\"_blank\" rel=\"noopener\">最新的 master 分支</a>  Download latest master branch</h3><p>  可能会 <strong>不稳定</strong>, 但是包含最新的特色，推荐开发者下载.</p>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+curl+tar+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-curl%20%7C%20tar-blue.svg\" alt=\"curl-tar-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ mkdir themes/next</span><br><span class=\"line\">$ curl -L https://api.github.com/repos/iissnan/hexo-theme-next/tarball | tar -zxv -C themes/next --strip-components=1</span><br></pre></td></tr></table></figure>\n<p>   <a href=\"http://lmgtfy.com/?q=linux+git+install\" target=\"_blank\" rel=\"noopener\"><img src=\"https://img.shields.io/badge/install%20with%20-git-blue.svg\" alt=\"git-image\"></a></p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>\n<p>  使用克隆命令，你将得到<strong>整个存储库</strong>。而且在任何时候你都可以切换到任何标签发布版本。<br>  获取标签列表：</p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> themes/next</span><br><span class=\"line\">$ git tag -l</span><br><span class=\"line\">…</span><br><span class=\"line\">v5.0.0</span><br><span class=\"line\">v5.0.1</span><br><span class=\"line\">v5.1.0</span><br><span class=\"line\">v5.1.1</span><br><span class=\"line\">v5.1.2</span><br></pre></td></tr></table></figure>\n<p>   例如, 你想要切换到<code>v5.1.0</code> <a href=\"https://github.com/iissnan/hexo-theme-next/tags\" target=\"_blank\" rel=\"noopener\">标签发布版本</a>. 输入以下命令:</p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout tags/v5.1.0</span><br><span class=\"line\">Note: checking out <span class=\"string\">'tags/v5.1.0'</span>.</span><br><span class=\"line\">…</span><br><span class=\"line\">HEAD now on 1f72f68... CSS: Remove global list-style setting of ul</span><br></pre></td></tr></table></figure>\n<p>   如果你想切换回 <a href=\"https://github.com/iissnan/hexo-theme-next/commits/master\" target=\"_blank\" rel=\"noopener\">master 分支</a>的话, 输入这个命令:</p>\n   <figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ git checkout master</span><br></pre></td></tr></table></figure>\n<p><strong>3.</strong> 在 <strong>hexo 根目录下</strong> 的配置文件<code>_config.yml</code>里设置主题:</p>\n<pre><code>theme: next\n</code></pre><h3 id=\"Bugs\"><a href=\"#Bugs\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h3><p>对于那些遇到 <strong>Error: Cannot find module ‘hexo-util’</strong> <a href=\"https://github.com/iissnan/hexo-theme-next/issues/1490\" target=\"_blank\" rel=\"noopener\">问题</a>的人, 请检查你的NPM 版本. </p>\n<ul>\n<li><code>版本 &gt; 3</code>: 如果仍然不行的话，请移除 <code>node_modules</code> 文件 然后重新安装，使用 <code>npm install</code>命令。</li>\n<li><code>版本 &lt; 3</code>: 请通过<code>npm install --save-dev hexo-util</code>命令添加<code>hexo-util</code>到你的站点包依赖里</li>\n</ul>\n<h2 id=\"更新-Update\"><a href=\"#更新-Update\" class=\"headerlink\" title=\"更新 Update\"></a>更新 Update</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ <span class=\"built_in\">cd</span> themes/next</span><br><span class=\"line\">$ git pull</span><br></pre></td></tr></table></figure>\n<h3 id=\"Bugs-1\"><a href=\"#Bugs-1\" class=\"headerlink\" title=\"Bugs\"></a>Bugs</h3><blockquote>\n<p>提交您的更改或存储它们，然后才能合并。</p>\n</blockquote>\n<p>您必须提交，存储或放弃本地更改. 看 <a href=\"https://stackoverflow.com/a/15745424/5861495\" target=\"_blank\" rel=\"noopener\">here</a> 是如何做的。</p>\n<h3 id=\"使用Hexo-data-files-328-配置主题-Theme-configurations-using-Hexo-data-files-328\"><a href=\"#使用Hexo-data-files-328-配置主题-Theme-configurations-using-Hexo-data-files-328\" class=\"headerlink\" title=\"使用Hexo data files(#328)配置主题  Theme configurations using Hexo data files #328\"></a>使用Hexo data files(<a href=\"https://github.com/iissnan/hexo-theme-next/issues/328\" target=\"_blank\" rel=\"noopener\">#328</a>)配置主题  Theme configurations using Hexo data files #328</h3><p>目前升级 NexT 主题的时候并不是非常的流畅。若使用 <code>git pull</code> 的方式，很多时候可能会产生冲突；而下载新版本覆盖安装的方式又需要手动合并主题的 <code>_config.yml</code> 文件。</p>\n<p>在此修改之前， NexT 建议将配置分离，一部分在 站点的配置文件中，另外一部分在主题的配置文件中。将需要自定的选项放置在 站点配置文件中，从而脱离避免更新主题时可能遇到的麻烦。这种方式是可行，但是有一些缺点：</p>\n<ol>\n<li>配置分离成了两个部分</li>\n<li>用户可能会疑惑一些选项该放置在哪里比较合适</li>\n</ol>\n<p>为了解决这个问题， NexT 将会使用 Hexo 的 <a href=\"https://hexo.io/docs/data-files.html\" target=\"_blank\" rel=\"noopener\">Data Files</a> 。然而由于 Data Files 是在 Hexo 3 版本时引进的，所以要使用这个特性，需要 Hexo 的版本不低于 3。</p>\n<p>若你比较喜欢 Hexo 2.x 版本，可以继续使用原先的配置方式。 NexT 保持着向下兼容。</p>\n<h4 id=\"特性-Benefits\"><a href=\"#特性-Benefits\" class=\"headerlink\" title=\"特性 Benefits\"></a>特性 Benefits</h4><p>通过这个特性，你可以将所有的主题配置放置在站点的 <code>source/_data/next.yml</code> 文件中。原先放置在 站点配置文件 中的选项可以迁移到新的位置，同时，主题配置文件可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 <code>next.yml</code> 中做相应调整即可</p>\n<h4 id=\"如何使用这个特性-How-to-use-this-feature\"><a href=\"#如何使用这个特性-How-to-use-this-feature\" class=\"headerlink\" title=\"如何使用这个特性 How to use this feature\"></a>如何使用这个特性 How to use this feature</h4><ol>\n<li>请先确保你所使用的 Hexo 版本在 3 以上</li>\n<li>在站点的 <code>source/_data</code> 目录下新建 <code>next.yml</code> 文件（<code>_data</code>目录可能需要新建）</li>\n<li>迁移站点配置文件和主题配置文件中的配置到 <code>next.yml</code> 中</li>\n<li>使用 <code>--config source/_data/next.yml</code> 参数启动服务器, 生成或者部署。\\<br>例如: <code>hexo clean --config source/_data/next.yml &amp;&amp; hexo g --config source/_data/next.yml</code>。</li>\n</ol>\n<h2 id=\"特色-Features\"><a href=\"#特色-Features\" class=\"headerlink\" title=\"特色 Features\"></a>特色 Features</h2><h3 id=\"支持多国语言-包括\"><a href=\"#支持多国语言-包括\" class=\"headerlink\" title=\"支持多国语言, 包括:\"></a>支持多国语言, 包括:</h3><p>:cn: 简体中文 &amp; 繁体中文<br><br>:us: 英语<br><br>:ru: 俄语<br><br>:fr: 法语<br><br>:de: 德语<br><br>:jp: 日语<br><br>:indonesia: 印度尼西亚语<br><br>:portugal: 葡萄牙语 (巴西)<br><br>:kr: 朝鲜语<br><br>:it: 意大利语<br><br>:netherlands: 荷兰语</p>\n<p>默认语言是英语。</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">en</span></span><br><span class=\"line\"><span class=\"comment\"># language: zh-Hans</span></span><br><span class=\"line\"><span class=\"comment\"># language: zh-hk</span></span><br><span class=\"line\"><span class=\"comment\"># language: zh-tw</span></span><br><span class=\"line\"><span class=\"comment\"># language: ru</span></span><br><span class=\"line\"><span class=\"comment\"># language: fr-FR</span></span><br><span class=\"line\"><span class=\"comment\"># language: de</span></span><br><span class=\"line\"><span class=\"comment\"># language: ja</span></span><br><span class=\"line\"><span class=\"comment\"># language: id</span></span><br><span class=\"line\"><span class=\"comment\"># language: pt</span></span><br><span class=\"line\"><span class=\"comment\"># language: pt-BR</span></span><br><span class=\"line\"><span class=\"comment\"># language: ko</span></span><br><span class=\"line\"><span class=\"comment\"># language: it</span></span><br><span class=\"line\"><span class=\"comment\"># language: nl-NL</span></span><br></pre></td></tr></table></figure>\n<p>在站点配置文件<code>_config.yml</code>中可以将语言切换成中文</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">language:</span> <span class=\"string\">zh-Hans</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"评论支持-Comment-support\"><a href=\"#评论支持-Comment-support\" class=\"headerlink\" title=\"评论支持 Comment support\"></a>评论支持 Comment support</h3><p>NexT 已经原生支持 <code>多说</code> and <code>Disqus</code> 评论系统。</p>\n<p>添加以下代码到你的主题配置文件 <code>_config.yml</code>:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">duoshuo:</span></span><br><span class=\"line\"><span class=\"attr\">  enable:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">  shortname:</span> <span class=\"string\">your-duoshuo-shortname</span></span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">disqus_shortname:</span> <span class=\"string\">your-disqus-shortname</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"标签页-Tags-page\"><a href=\"#标签页-Tags-page\" class=\"headerlink\" title=\"标签页 Tags page\"></a>标签页 Tags page</h3><blockquote>\n<p>添加一个标签页面，里面包含您网站中的所有标签。</p>\n</blockquote>\n<ul>\n<li><p>创建一个名为 <code>tags</code> 页面</p>\n<pre><code>hexo new page &quot;tags&quot;\n</code></pre></li>\n<li><p>编辑标签页, 设置页面类型为<code>tags</code>.</p>\n<pre><code>title: All tags\ndate: 2014-12-22 12:39:04\ntype: &quot;tags&quot;\n</code></pre></li>\n<li><p>添加 <code>tags</code> 到主题配置文件 <code>_config.yml</code> 里:</p>\n<pre><code>menu:\n  home: /\n  archives: /archives\n  tags: /tags\n</code></pre></li>\n</ul>\n<h3 id=\"分类页-Categories-page\"><a href=\"#分类页-Categories-page\" class=\"headerlink\" title=\"分类页 Categories page\"></a>分类页 Categories page</h3><blockquote>\n<p>添加一个分类页面，里面包含您网站中的所有分类。</p>\n</blockquote>\n<ul>\n<li><p>创建一个名为 <code>categories</code> 页面</p>\n<pre><code>hexo new page &quot;categories&quot;\n</code></pre></li>\n<li><p>编辑分类页, 设置页面类型为 <code>categories</code>.</p>\n<pre><code>title: All categories\ndate: 2014-12-22 12:39:04\ntype: &quot;categories&quot;\n</code></pre></li>\n<li><p>添加 <code>categories</code> 到主题配置文件 <code>_config.yml</code> 里:</p>\n<pre><code>menu:\n  home: /\n  archives: /archives\n  categories: /categories\n</code></pre></li>\n</ul>\n<h3 id=\"社交媒体-Social-Media\"><a href=\"#社交媒体-Social-Media\" class=\"headerlink\" title=\"社交媒体 Social Media\"></a>社交媒体 Social Media</h3><p>NexT 可以自动添加链接到您的社交媒体帐户里:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">social:</span></span><br><span class=\"line\"><span class=\"attr\">  GitHub:</span> <span class=\"string\">your-github-url</span></span><br><span class=\"line\"><span class=\"attr\">  Twitter:</span> <span class=\"string\">your-twitter-url</span></span><br><span class=\"line\"><span class=\"attr\">  Weibo:</span> <span class=\"string\">your-weibo-url</span></span><br><span class=\"line\"><span class=\"attr\">  DouBan:</span> <span class=\"string\">your-douban-url</span></span><br><span class=\"line\"><span class=\"attr\">  ZhiHu:</span> <span class=\"string\">your-zhihu-url</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Feed-链接-Feed-link\"><a href=\"#Feed-链接-Feed-link\" class=\"headerlink\" title=\"Feed 链接 Feed link\"></a>Feed 链接 Feed link</h3><blockquote>\n<p>显示 feed 链接。</p>\n</blockquote>\n<p>在主题配置文件<code>_config.yml</code>里设置<code>rss</code> , 如下所示:</p>\n<ol>\n<li><code>rss: false</code> 会禁用 feed 链接。</li>\n<li><p><code>rss:</code> 使用站点 feed 链接。这是默认的选项。</p>\n<p> 按照插件<a href=\"https://github.com/hexojs/hexo-generator-feed\" target=\"_blank\" rel=\"noopener\">hexo-generator-feed</a>的README中的安装说明进行操作。在完成这个插件的配置后，Feed链接也生成好了</p>\n</li>\n<li><p><code>rss: http://your-feed-url</code> 设置你的 feed 链接.</p>\n</li>\n</ol>\n<h3 id=\"内置5种代码高亮主题-Up-to-5-code-highlight-themes-built-in\"><a href=\"#内置5种代码高亮主题-Up-to-5-code-highlight-themes-built-in\" class=\"headerlink\" title=\"内置5种代码高亮主题 Up to 5 code highlight themes built-in\"></a>内置5种代码高亮主题 Up to 5 code highlight themes built-in</h3><p>NexT 使用的是 <a href=\"https://github.com/chriskempson/tomorrow-theme\" target=\"_blank\" rel=\"noopener\">Tomorrow 主题</a> ，一共有5种主题供你选择。<br>Next 默认使用 <code>normal</code>. 下面是 <code>normal</code> 和 <code>night</code> 主题的预览:</p>\n<p><img src=\"http://iissnan.com/nexus/next/tomorrow-normal.png\" alt=\"Tomorrow Normal Preview\"><br><img src=\"http://iissnan.com/nexus/next/tomorrow-night.png\" alt=\"Tomorrow Night Preview\"></p>\n<p>查看更多信息点击<a href=\"https://github.com/chriskempson/tomorrow-theme\" target=\"_blank\" rel=\"noopener\">Tomorrow 主题</a>。</p>\n<h2 id=\"配置-Configuration\"><a href=\"#配置-Configuration\" class=\"headerlink\" title=\"配置 Configuration\"></a>配置 Configuration</h2><p>NexT 的配置很少</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Menu configuration.</span></span><br><span class=\"line\"><span class=\"attr\">menu:</span></span><br><span class=\"line\"><span class=\"attr\">  home:</span> <span class=\"string\">/</span></span><br><span class=\"line\"><span class=\"attr\">  archives:</span> <span class=\"string\">/archives</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Favicon</span></span><br><span class=\"line\"><span class=\"attr\">favicon:</span> <span class=\"string\">/favicon.ico</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Avatar (put the image into next/source/images/)</span></span><br><span class=\"line\"><span class=\"comment\"># can be any image format supported by web browsers (JPEG,PNG,GIF,SVG,..)</span></span><br><span class=\"line\"><span class=\"attr\">avatar:</span> <span class=\"string\">/default_avatar.png</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Code highlight theme</span></span><br><span class=\"line\"><span class=\"comment\"># available: normal | night | night eighties | night blue | night bright</span></span><br><span class=\"line\"><span class=\"attr\">highlight_theme:</span> <span class=\"string\">normal</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Fancybox for image gallery</span></span><br><span class=\"line\"><span class=\"attr\">fancybox:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Specify the date when the site was setup</span></span><br><span class=\"line\"><span class=\"attr\">since:</span> <span class=\"number\">2013</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"浏览器支持-Browser-support\"><a href=\"#浏览器支持-Browser-support\" class=\"headerlink\" title=\"浏览器支持 Browser support\"></a>浏览器支持 Browser support</h2><p><img src=\"http://iissnan.com/nexus/next/browser-support.png\" alt=\"Browser support\"></p>\n<p><img src=\"/2016/11/28/How-To-Next/browserstack_logo.png\" alt=\"Browser Stack\">(<a href=\"https://www.browserstack.com/\" target=\"_blank\" rel=\"noopener\">https://www.browserstack.com/</a>)</p>\n<blockquote>\n<p><strong>BrowserStack</strong> is a cloud-based cross-browser testing tool that enables developers to test their websites across various browsers on different operating systems and mobile devices, without requiring users to install virtual machines, devices or emulators.</p>\n</blockquote>\n<h2 id=\"贡献-Contributing\"><a href=\"#贡献-Contributing\" class=\"headerlink\" title=\"贡献 Contributing\"></a>贡献 Contributing</h2><p>接受各种形式的贡献，包括不限于提交问题与需求，修复代码。等待您的<code>Pull Request</code>。</p>\n<p>Any types of contribution are welcome. Thanks.</p>\n<p><strong>ATTENTION! Contributors on Chinese docs needed!</strong>\\<br>Need to translate from <a href=\"README.md\">English docs</a> to Chinese docs.\\<br>Any help wanted!\\<br>Thank’s a lot!</p>\n<h2 id=\"开发-Development\"><a href=\"#开发-Development\" class=\"headerlink\" title=\"开发 Development\"></a>开发 Development</h2><p>NexT 主旨在于简洁优雅且易于使用，所以首先要尽量确保 NexT 的简洁易用性。</p>\n<p>NexT is built for easily use with elegant appearance. First things first, always keep things simple.</p>\n<h2 id=\"开发历史-Changelog\"><a href=\"#开发历史-Changelog\" class=\"headerlink\" title=\"开发历史 Changelog\"></a><a href=\"https://github.com/iissnan/hexo-theme-next/wiki/Changelog\" target=\"_blank\" rel=\"noopener\">开发历史 Changelog</a></h2><!--[lic-image]: https://img.shields.io/npm/l/hexo-theme-next.svg-->\n"},{"title":"数学之美(13-24)","author":"Tim Zhang","mathjax":true,"date":"2017-11-30T02:20:00.000Z","_content":"## 十三、信息指纹及其应用 \n\n2006 年 8 月 3 日 上午 11:17:00\n\n发表者：吴军，Google 研究员\n\n任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。\n\n我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接\n\nm/s?ie=gb2312&bs=%CA%FD%D1%A7%D6%AE%C3%C0&sr=&amp; z=&cl=3&f=8\n\n&wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&ct=0\n\n假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:\n\n893249432984398432980545454543\n\n这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。\n\n产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。\n\n信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，\n\n比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。\n\n互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。\n\n信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。\n\n## 十四、谈谈数学模型的重要性\n\n2006 年 8 月 9 日 上午 09:12:00\n\n发表者：吴军，Google 研究员\n\n注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。\n\n在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）\n\n但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。\n\n当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。\n\n地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。\n\n纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。\n\n完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。\n\n故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。\n\n讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：\n\n１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。） \n２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）\n３. 大量准确的数据对研发很重要。\n４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。\n\n在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。\n\n## 十五、繁与简 自然语言处理的几位精英 \n\n2006 年 8 月 23 日 下午 11:22:00\n\n发表者：吴军，Google 研究员\n\n我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。\n\n柯林斯：追求完美\n\n柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。\n\n柯 林斯毕业后，在 AT&T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。\n\n布莱尔：简单才美\n\n在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：\n\n第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；\n\n第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；\n\n第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。\n\n布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。\n\n由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）\n\n在接下来了系列里，我们还会介绍一个繁与简结合的例子。\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 -- 谈谈最大熵模型 （上）\n\n2006 年 10 月 8 日 上午 07:27:00\n\n发表者：Google 研究员，吴军\n\n我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (\"the maximum entropy principle\")。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。\n\n前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。\n\n让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是\"wang-xiao-bo\"， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。\n\n数学上最漂亮的办法是最大熵(\"maximum entropy\")模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。\n\n有 一次，我去 AT&T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。\n\n最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。\n\n回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 -- 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。\n\n我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。\n\n最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。\n\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\n\n2006 年 11 月 16 日 上午 06:50:00\n\n发表者：Google 研究员，吴军\n\n我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。\n\n最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：\n\n1. 假定第零次迭代的初始模型为等概率的均匀分布。\n\n2. 用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。\n\nGIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。\n\n八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。\n\n由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。\n\n但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。\n\n最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。\n\n讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司----文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。\n\n值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。\n\n## 十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\n\n2006 年 11 月 28 日 上午 03:18:00\n\nGoogle 研究员 吴军\n\n自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。\n\n搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。\n\n在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。\n\n几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此\" 痛改前非\"，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。\n\n抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：\n\n在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）\n\n搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。\n\n还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。\n\n## 十八、矩阵运算和文本处理中的分类问题 \n\n2007 年 1 月 1 日 下午 03:10:00\n\n发表者：Google 研究员，吴军\n\n我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。\n\n在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。\n\n分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。\n\n在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。\n\n在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。\n\n奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。\n\n三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。\n\n现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。\n\n\n## 十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\n\n我们在前面的系列中多次提到 马尔可夫链 (Markov\n\nChain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。\n\n我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。\n\n和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。\n\n使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。\n\n值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。\n\n贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。\n\n## 二十、自然语言处理的教父 马库斯 \n\n2007 年 4 月 13 日 下午 07:03:00\n\n发表者：Google 研究员，吴军\n\n我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。\n\n马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree\n\nBank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。\n\n马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。\n\n作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。\n\n过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。\n\n\n## 二十一、布隆过滤器（ Bloom Filter ） \n\n2007 年 7 月 3 日 上午 09:35:00\n\n发表者：Google（谷歌）研究员 吴军\n\n在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的\n\n具体办法是将每一个\n email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹\n\nm/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。\n\n今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。\n\n布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。\n\n假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指 纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）\n\n现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, ..., F8）对这个地址产 生八个信息指纹 s1,s2,...,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,...,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。\n\n布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。\n\n布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。\n\n## 二十二、谈谈密码学的数学原理 \n\n2007 年 9 月 13 日 下午 09:00:00\n\n发表者：Google（谷歌）研究员 吴军\n\n前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）\n\n密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说\n\n这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。\n\n事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。\n\n公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。\n\n1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。\n\n2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。\n\n3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。\n\n现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。\n\n现在，我们用下面的公式对 X 加密，得到密码 Y。\n\n好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。\n\n这个过程大致可以概况如下：\n\n公开密钥的好处有：\n\n1.简单。\n\n2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。\n\n3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。\n\n最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的\n\n395058745832651445264197678006144819960207764603049364541393760515793 556265294\n\n506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =\n\n338849583746672139436839320467218152281583036860499304808492584055528 1177\n\n×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139\n\n现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。\n\n不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。\n\n## 二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\n\n2007 年 12 月 3 日 上午 10:05:00\n\n发表者：Google（谷歌）研究员 吴军\n\n今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。\n\n我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是\n\np1, p2, p3, ..., p6700 它们编码的长度是\n\nL1, L2, L3, ..., L6700 那么，平均编码长度是\n\np1×L1 + p2×L2 + ... + p6700×L6700\n\n香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - ... - p6700 log p6700。\n\n我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=\n\n4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。\n\n聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。\n\n但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。\n\n另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。\n\n另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。\n","source":"_posts/The-Beauty-Of-Maths-02.md","raw":"title: 数学之美(13-24)\nauthor: Tim Zhang\ntags:\n  - 吴军\n  - 算法\n  - 数学\ncategories:\n  - Maths\n  - Algorithm\nmathjax: true\ndate: 2017-11-30 11:20:00\n---\n## 十三、信息指纹及其应用 \n\n2006 年 8 月 3 日 上午 11:17:00\n\n发表者：吴军，Google 研究员\n\n任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。\n\n我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接\n\nm/s?ie=gb2312&bs=%CA%FD%D1%A7%D6%AE%C3%C0&sr=&amp; z=&cl=3&f=8\n\n&wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&ct=0\n\n假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:\n\n893249432984398432980545454543\n\n这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。\n\n产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。\n\n信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，\n\n比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。\n\n互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。\n\n信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。\n\n## 十四、谈谈数学模型的重要性\n\n2006 年 8 月 9 日 上午 09:12:00\n\n发表者：吴军，Google 研究员\n\n注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。\n\n在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）\n\n但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。\n\n当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。\n\n地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。\n\n纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。\n\n完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。\n\n故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。\n\n讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：\n\n１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。） \n２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）\n３. 大量准确的数据对研发很重要。\n４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。\n\n在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。\n\n## 十五、繁与简 自然语言处理的几位精英 \n\n2006 年 8 月 23 日 下午 11:22:00\n\n发表者：吴军，Google 研究员\n\n我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。\n\n柯林斯：追求完美\n\n柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。\n\n柯 林斯毕业后，在 AT&T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。\n\n布莱尔：简单才美\n\n在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：\n\n第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；\n\n第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；\n\n第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。\n\n布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。\n\n由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）\n\n在接下来了系列里，我们还会介绍一个繁与简结合的例子。\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 -- 谈谈最大熵模型 （上）\n\n2006 年 10 月 8 日 上午 07:27:00\n\n发表者：Google 研究员，吴军\n\n我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (\"the maximum entropy principle\")。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。\n\n前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。\n\n让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是\"wang-xiao-bo\"， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。\n\n数学上最漂亮的办法是最大熵(\"maximum entropy\")模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。\n\n有 一次，我去 AT&T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。\n\n最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。\n\n回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 -- 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。\n\n我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。\n\n最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。\n\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\n\n2006 年 11 月 16 日 上午 06:50:00\n\n发表者：Google 研究员，吴军\n\n我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。\n\n最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：\n\n1. 假定第零次迭代的初始模型为等概率的均匀分布。\n\n2. 用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。\n\nGIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。\n\n八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。\n\n由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。\n\n但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。\n\n最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。\n\n讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司----文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。\n\n值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。\n\n## 十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\n\n2006 年 11 月 28 日 上午 03:18:00\n\nGoogle 研究员 吴军\n\n自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。\n\n搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。\n\n在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。\n\n几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此\" 痛改前非\"，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。\n\n抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：\n\n在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）\n\n搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。\n\n还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。\n\n## 十八、矩阵运算和文本处理中的分类问题 \n\n2007 年 1 月 1 日 下午 03:10:00\n\n发表者：Google 研究员，吴军\n\n我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。\n\n在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。\n\n分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。\n\n在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。\n\n在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。\n\n奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。\n\n三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。\n\n现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。\n\n\n## 十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\n\n我们在前面的系列中多次提到 马尔可夫链 (Markov\n\nChain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。\n\n我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。\n\n和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。\n\n使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。\n\n值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。\n\n贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。\n\n## 二十、自然语言处理的教父 马库斯 \n\n2007 年 4 月 13 日 下午 07:03:00\n\n发表者：Google 研究员，吴军\n\n我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。\n\n马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree\n\nBank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。\n\n马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。\n\n作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。\n\n过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。\n\n\n## 二十一、布隆过滤器（ Bloom Filter ） \n\n2007 年 7 月 3 日 上午 09:35:00\n\n发表者：Google（谷歌）研究员 吴军\n\n在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的\n\n具体办法是将每一个\n email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹\n\nm/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。\n\n今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。\n\n布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。\n\n假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指 纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）\n\n现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, ..., F8）对这个地址产 生八个信息指纹 s1,s2,...,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,...,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。\n\n布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。\n\n布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。\n\n## 二十二、谈谈密码学的数学原理 \n\n2007 年 9 月 13 日 下午 09:00:00\n\n发表者：Google（谷歌）研究员 吴军\n\n前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）\n\n密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说\n\n这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。\n\n事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。\n\n公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。\n\n1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。\n\n2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。\n\n3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。\n\n现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。\n\n现在，我们用下面的公式对 X 加密，得到密码 Y。\n\n好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。\n\n这个过程大致可以概况如下：\n\n公开密钥的好处有：\n\n1.简单。\n\n2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。\n\n3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。\n\n最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的\n\n395058745832651445264197678006144819960207764603049364541393760515793 556265294\n\n506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =\n\n338849583746672139436839320467218152281583036860499304808492584055528 1177\n\n×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139\n\n现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。\n\n不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。\n\n## 二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\n\n2007 年 12 月 3 日 上午 10:05:00\n\n发表者：Google（谷歌）研究员 吴军\n\n今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。\n\n我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是\n\np1, p2, p3, ..., p6700 它们编码的长度是\n\nL1, L2, L3, ..., L6700 那么，平均编码长度是\n\np1×L1 + p2×L2 + ... + p6700×L6700\n\n香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - ... - p6700 log p6700。\n\n我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=\n\n4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。\n\n聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。\n\n但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。\n\n另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。\n\n另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。\n","slug":"The-Beauty-Of-Maths-02","published":1,"updated":"2018-12-03T07:05:06.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0n5k001urd4loqitzkay","content":"<h2 id=\"十三、信息指纹及其应用\"><a href=\"#十三、信息指纹及其应用\" class=\"headerlink\" title=\"十三、信息指纹及其应用\"></a>十三、信息指纹及其应用</h2><p>2006 年 8 月 3 日 上午 11:17:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。</p>\n<p>我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接</p>\n<p>m/s?ie=gb2312&amp;bs=%CA%FD%D1%A7%D6%AE%C3%C0&amp;sr=&amp; z=&amp;cl=3&amp;f=8</p>\n<p>&amp;wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&amp;ct=0</p>\n<p>假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:</p>\n<p>893249432984398432980545454543</p>\n<p>这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。</p>\n<p>产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。</p>\n<p>信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，</p>\n<p>比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。</p>\n<p>互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。</p>\n<p>信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。</p>\n<h2 id=\"十四、谈谈数学模型的重要性\"><a href=\"#十四、谈谈数学模型的重要性\" class=\"headerlink\" title=\"十四、谈谈数学模型的重要性\"></a>十四、谈谈数学模型的重要性</h2><p>2006 年 8 月 9 日 上午 09:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。</p>\n<p>在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）</p>\n<p>但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。</p>\n<p>当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。</p>\n<p>地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。</p>\n<p>纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。</p>\n<p>完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。</p>\n<p>故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。</p>\n<p>讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：</p>\n<p>１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。）<br>２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）<br>３. 大量准确的数据对研发很重要。<br>４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</p>\n<p>在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。</p>\n<h2 id=\"十五、繁与简-自然语言处理的几位精英\"><a href=\"#十五、繁与简-自然语言处理的几位精英\" class=\"headerlink\" title=\"十五、繁与简 自然语言处理的几位精英\"></a>十五、繁与简 自然语言处理的几位精英</h2><p>2006 年 8 月 23 日 下午 11:22:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。</p>\n<p>柯林斯：追求完美</p>\n<p>柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。</p>\n<p>柯 林斯毕业后，在 AT&amp;T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&amp;T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。</p>\n<p>布莱尔：简单才美</p>\n<p>在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：</p>\n<p>第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；</p>\n<p>第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；</p>\n<p>第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。</p>\n<p>布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。</p>\n<p>由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）</p>\n<p>在接下来了系列里，我们还会介绍一个繁与简结合的例子。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）</h2><p>2006 年 10 月 8 日 上午 07:27:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (“the maximum entropy principle”)。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。</p>\n<p>前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。</p>\n<p>让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是”wang-xiao-bo”， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。</p>\n<p>数学上最漂亮的办法是最大熵(“maximum entropy”)模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。</p>\n<p>有 一次，我去 AT&amp;T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。</p>\n<p>最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。</p>\n<p>回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 – 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。</p>\n<p>我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。</p>\n<p>最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）</h2><p>2006 年 11 月 16 日 上午 06:50:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。</p>\n<p>最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：</p>\n<ol>\n<li><p>假定第零次迭代的初始模型为等概率的均匀分布。</p>\n</li>\n<li><p>用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。</p>\n</li>\n</ol>\n<p>GIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。</p>\n<p>八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。</p>\n<p>由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。</p>\n<p>但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。</p>\n<p>最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。</p>\n<p>讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司—-文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。</p>\n<p>值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。</p>\n<h2 id=\"十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\"><a href=\"#十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\" class=\"headerlink\" title=\"十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\"></a>十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)</h2><p>2006 年 11 月 28 日 上午 03:18:00</p>\n<p>Google 研究员 吴军</p>\n<p>自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。</p>\n<p>搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。</p>\n<p>在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。</p>\n<p>几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此” 痛改前非”，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。</p>\n<p>抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：</p>\n<p>在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）</p>\n<p>搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。</p>\n<p>还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。</p>\n<h2 id=\"十八、矩阵运算和文本处理中的分类问题\"><a href=\"#十八、矩阵运算和文本处理中的分类问题\" class=\"headerlink\" title=\"十八、矩阵运算和文本处理中的分类问题\"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>2007 年 1 月 1 日 下午 03:10:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。</p>\n<p>在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。</p>\n<p>分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。</p>\n<p>在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。</p>\n<p>在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。</p>\n<p>奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。</p>\n<p>三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。</p>\n<p>现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。</p>\n<h2 id=\"十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\"><a href=\"#十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\" class=\"headerlink\" title=\"十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\"></a>十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)</h2><p>我们在前面的系列中多次提到 马尔可夫链 (Markov</p>\n<p>Chain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。</p>\n<p>我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。</p>\n<p>和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。</p>\n<p>使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。</p>\n<p>值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。</p>\n<p>贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。</p>\n<h2 id=\"二十、自然语言处理的教父-马库斯\"><a href=\"#二十、自然语言处理的教父-马库斯\" class=\"headerlink\" title=\"二十、自然语言处理的教父 马库斯\"></a>二十、自然语言处理的教父 马库斯</h2><p>2007 年 4 月 13 日 下午 07:03:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。</p>\n<p>马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&amp;T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree</p>\n<p>Bank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。</p>\n<p>马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。</p>\n<p>作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。</p>\n<p>过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。</p>\n<h2 id=\"二十一、布隆过滤器（-Bloom-Filter-）\"><a href=\"#二十一、布隆过滤器（-Bloom-Filter-）\" class=\"headerlink\" title=\"二十一、布隆过滤器（ Bloom Filter ）\"></a>二十一、布隆过滤器（ Bloom Filter ）</h2><p>2007 年 7 月 3 日 上午 09:35:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的</p>\n<p>具体办法是将每一个<br> email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹</p>\n<p>m/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。</p>\n<p>今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p>\n<p>布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。</p>\n<p>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指 纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）</p>\n<p>现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, …, F8）对这个地址产 生八个信息指纹 s1,s2,…,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,…,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。</p>\n<p>布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。</p>\n<p>布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。</p>\n<h2 id=\"二十二、谈谈密码学的数学原理\"><a href=\"#二十二、谈谈密码学的数学原理\" class=\"headerlink\" title=\"二十二、谈谈密码学的数学原理\"></a>二十二、谈谈密码学的数学原理</h2><p>2007 年 9 月 13 日 下午 09:00:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）</p>\n<p>密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说</p>\n<p>这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。</p>\n<p>事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。</p>\n<p>公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。</p>\n<p>1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。</p>\n<p>2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。</p>\n<p>3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。</p>\n<p>现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。</p>\n<p>现在，我们用下面的公式对 X 加密，得到密码 Y。</p>\n<p>好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。</p>\n<p>这个过程大致可以概况如下：</p>\n<p>公开密钥的好处有：</p>\n<p>1.简单。</p>\n<p>2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。</p>\n<p>3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。</p>\n<p>最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的</p>\n<p>395058745832651445264197678006144819960207764603049364541393760515793 556265294</p>\n<p>506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =</p>\n<p>338849583746672139436839320467218152281583036860499304808492584055528 1177</p>\n<p>×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139</p>\n<p>现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。</p>\n<p>不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。</p>\n<h2 id=\"二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\"><a href=\"#二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\" class=\"headerlink\" title=\"二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\"></a>二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律</h2><p>2007 年 12 月 3 日 上午 10:05:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。</p>\n<p>我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是</p>\n<p>p1, p2, p3, …, p6700 它们编码的长度是</p>\n<p>L1, L2, L3, …, L6700 那么，平均编码长度是</p>\n<p>p1×L1 + p2×L2 + … + p6700×L6700</p>\n<p>香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - … - p6700 log p6700。</p>\n<p>我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=</p>\n<p>4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。</p>\n<p>聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。</p>\n<p>但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。</p>\n<p>另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。</p>\n<p>另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。</p>\n<div><h1>おススメ記事<span style=\"font-size:0.45em; color:gray\">（<a href=\"https://github.com/huiwang/hexo-recommended-posts\">hexo-recommend-posts</a>）</span></h1><ul><li><a href=\"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/\">数学之美(1-12)</a></li><li><a href=\"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/\">数学之美(1-12)</a></li><li><a href=\"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/\">数学之美(1-12)</a></li><li><a href=\"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/\">区块链学习备忘录之共识算法</a></li></ul></div>","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"十三、信息指纹及其应用\"><a href=\"#十三、信息指纹及其应用\" class=\"headerlink\" title=\"十三、信息指纹及其应用\"></a>十三、信息指纹及其应用</h2><p>2006 年 8 月 3 日 上午 11:17:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。</p>\n<p>我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接</p>\n<p>m/s?ie=gb2312&amp;bs=%CA%FD%D1%A7%D6%AE%C3%C0&amp;sr=&amp; z=&amp;cl=3&amp;f=8</p>\n<p>&amp;wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&amp;ct=0</p>\n<p>假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:</p>\n<p>893249432984398432980545454543</p>\n<p>这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。</p>\n<p>产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。</p>\n<p>信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，</p>\n<p>比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。</p>\n<p>互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。</p>\n<p>信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。</p>\n<h2 id=\"十四、谈谈数学模型的重要性\"><a href=\"#十四、谈谈数学模型的重要性\" class=\"headerlink\" title=\"十四、谈谈数学模型的重要性\"></a>十四、谈谈数学模型的重要性</h2><p>2006 年 8 月 9 日 上午 09:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。</p>\n<p>在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）</p>\n<p>但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。</p>\n<p>当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。</p>\n<p>地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。</p>\n<p>纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。</p>\n<p>完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。</p>\n<p>故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。</p>\n<p>讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：</p>\n<p>１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。）<br>２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）<br>３. 大量准确的数据对研发很重要。<br>４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</p>\n<p>在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。</p>\n<h2 id=\"十五、繁与简-自然语言处理的几位精英\"><a href=\"#十五、繁与简-自然语言处理的几位精英\" class=\"headerlink\" title=\"十五、繁与简 自然语言处理的几位精英\"></a>十五、繁与简 自然语言处理的几位精英</h2><p>2006 年 8 月 23 日 下午 11:22:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。</p>\n<p>柯林斯：追求完美</p>\n<p>柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。</p>\n<p>柯 林斯毕业后，在 AT&amp;T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&amp;T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。</p>\n<p>布莱尔：简单才美</p>\n<p>在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：</p>\n<p>第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；</p>\n<p>第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；</p>\n<p>第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。</p>\n<p>布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。</p>\n<p>由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）</p>\n<p>在接下来了系列里，我们还会介绍一个繁与简结合的例子。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）</h2><p>2006 年 10 月 8 日 上午 07:27:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (“the maximum entropy principle”)。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。</p>\n<p>前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。</p>\n<p>让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是”wang-xiao-bo”， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。</p>\n<p>数学上最漂亮的办法是最大熵(“maximum entropy”)模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。</p>\n<p>有 一次，我去 AT&amp;T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。</p>\n<p>最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。</p>\n<p>回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 – 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。</p>\n<p>我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。</p>\n<p>最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）</h2><p>2006 年 11 月 16 日 上午 06:50:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。</p>\n<p>最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：</p>\n<ol>\n<li><p>假定第零次迭代的初始模型为等概率的均匀分布。</p>\n</li>\n<li><p>用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。</p>\n</li>\n</ol>\n<p>GIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。</p>\n<p>八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。</p>\n<p>由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。</p>\n<p>但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。</p>\n<p>最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。</p>\n<p>讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司—-文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。</p>\n<p>值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。</p>\n<h2 id=\"十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\"><a href=\"#十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\" class=\"headerlink\" title=\"十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\"></a>十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)</h2><p>2006 年 11 月 28 日 上午 03:18:00</p>\n<p>Google 研究员 吴军</p>\n<p>自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。</p>\n<p>搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。</p>\n<p>在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。</p>\n<p>几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此” 痛改前非”，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。</p>\n<p>抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：</p>\n<p>在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）</p>\n<p>搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。</p>\n<p>还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。</p>\n<h2 id=\"十八、矩阵运算和文本处理中的分类问题\"><a href=\"#十八、矩阵运算和文本处理中的分类问题\" class=\"headerlink\" title=\"十八、矩阵运算和文本处理中的分类问题\"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>2007 年 1 月 1 日 下午 03:10:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。</p>\n<p>在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。</p>\n<p>分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。</p>\n<p>在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。</p>\n<p>在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。</p>\n<p>奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。</p>\n<p>三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。</p>\n<p>现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。</p>\n<h2 id=\"十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\"><a href=\"#十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\" class=\"headerlink\" title=\"十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\"></a>十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)</h2><p>我们在前面的系列中多次提到 马尔可夫链 (Markov</p>\n<p>Chain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。</p>\n<p>我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。</p>\n<p>和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。</p>\n<p>使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。</p>\n<p>值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。</p>\n<p>贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。</p>\n<h2 id=\"二十、自然语言处理的教父-马库斯\"><a href=\"#二十、自然语言处理的教父-马库斯\" class=\"headerlink\" title=\"二十、自然语言处理的教父 马库斯\"></a>二十、自然语言处理的教父 马库斯</h2><p>2007 年 4 月 13 日 下午 07:03:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。</p>\n<p>马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&amp;T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree</p>\n<p>Bank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。</p>\n<p>马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。</p>\n<p>作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。</p>\n<p>过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。</p>\n<h2 id=\"二十一、布隆过滤器（-Bloom-Filter-）\"><a href=\"#二十一、布隆过滤器（-Bloom-Filter-）\" class=\"headerlink\" title=\"二十一、布隆过滤器（ Bloom Filter ）\"></a>二十一、布隆过滤器（ Bloom Filter ）</h2><p>2007 年 7 月 3 日 上午 09:35:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的</p>\n<p>具体办法是将每一个<br> email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹</p>\n<p>m/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。</p>\n<p>今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p>\n<p>布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。</p>\n<p>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指 纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）</p>\n<p>现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, …, F8）对这个地址产 生八个信息指纹 s1,s2,…,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,…,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。</p>\n<p>布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。</p>\n<p>布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。</p>\n<h2 id=\"二十二、谈谈密码学的数学原理\"><a href=\"#二十二、谈谈密码学的数学原理\" class=\"headerlink\" title=\"二十二、谈谈密码学的数学原理\"></a>二十二、谈谈密码学的数学原理</h2><p>2007 年 9 月 13 日 下午 09:00:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）</p>\n<p>密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说</p>\n<p>这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。</p>\n<p>事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。</p>\n<p>公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。</p>\n<p>1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。</p>\n<p>2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。</p>\n<p>3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。</p>\n<p>现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。</p>\n<p>现在，我们用下面的公式对 X 加密，得到密码 Y。</p>\n<p>好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。</p>\n<p>这个过程大致可以概况如下：</p>\n<p>公开密钥的好处有：</p>\n<p>1.简单。</p>\n<p>2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。</p>\n<p>3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。</p>\n<p>最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的</p>\n<p>395058745832651445264197678006144819960207764603049364541393760515793 556265294</p>\n<p>506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =</p>\n<p>338849583746672139436839320467218152281583036860499304808492584055528 1177</p>\n<p>×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139</p>\n<p>现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。</p>\n<p>不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。</p>\n<h2 id=\"二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\"><a href=\"#二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\" class=\"headerlink\" title=\"二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\"></a>二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律</h2><p>2007 年 12 月 3 日 上午 10:05:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。</p>\n<p>我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是</p>\n<p>p1, p2, p3, …, p6700 它们编码的长度是</p>\n<p>L1, L2, L3, …, L6700 那么，平均编码长度是</p>\n<p>p1×L1 + p2×L2 + … + p6700×L6700</p>\n<p>香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - … - p6700 log p6700。</p>\n<p>我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=</p>\n<p>4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。</p>\n<p>聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。</p>\n<p>但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。</p>\n<p>另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。</p>\n<p>另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。</p>\n"},{"title":"数学之美(1-12)","author":"Tim Zhang","mathjax":true,"date":"2017-11-30T02:20:00.000Z","_content":"## 一、统计语言模型\n\n2006 年 4 月 3 日 上午 08:15:00\n\n从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。\n\n发表者: 吴军, Google 研究员\n\n前言\n\n也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。\n\n系列一： 统计语言模型 (Statistical Language Models)\n\nGoogle 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。\n\n其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。\n\n首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。\n\n给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。\n\n如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：\n\nP(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)\n\n其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：\n\nP(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…\n\n(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）\n\n接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。\n\n也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。\n\n现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。\n\n我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦\n\n## 二、谈谈中文分词 \n\n2006 年 4 月 10 日 上午 08:10:00\n\n发表者: 吴军， Google 研究员\n\n谈谈中文分词\n\n----- 统计语言模型在中文处理中的一个应用\n\n上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”\n\n分成一串词：\n\n中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。\n\n最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。\n\n用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。\n\n九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。\n\n利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：\n\n我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, ..., Ak, B1, B2, B3, ..., Bm C1, C2, C3, ..., Cn\n\n其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,..., Ak 是\n\n最好的分法，那么 （P 表示概率）：\n\nP (A1, A2, A3, ..., Ak） 〉 P (B1, B2, B3, ..., Bm), 并且 P (A1, A2, A3, ..., Ak） 〉 P(C1, C2, C3, ..., Cn)\n\n因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。\n\n当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。\n\n在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。\n\n需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。\n\n一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。\n\n也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。\n\n对中文分词有兴趣的读者，可以阅读以下文献：\n\n1. 梁南元\n\n书面汉语自动分词系统\n\nm/demo/LiangNanyuan-JCIP-1987.pdf\n\n2. 郭进\n\n统计语言模型和汉语音字转换的一些新结果\n\nm/demo/GuoJin-JCIP-1993.pdf\n\n3. 郭进\n\nCritical Tokenization and its Properties u/J/J97/J97-4004.pdf\n\n4. 孙茂松\n\nChinese word segmentation without using lexicon and hand-crafted training data\n\ng/m?coll=GUIDE&dl=GUIDE&id=980775\n\n## 三、隐含马尔可夫模型在语言处理中的应用\n\n2006 年 4 月 17 日 上午 08:01:00\n\n发表者：吴军，Google 研究员\n\n前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。\n\n自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 -- 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：\n\n其中 s1，s2，s3...表示信息源发出的信号。o1, o2, o3 ... 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 ...还原出发送的信 号 s1，s2，s3...。\n\n其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。\n\n那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,...的情况下，求使得条件概率 P (s1,s2,s3,...|o1,o2,o3....) 达到最大值的那个句子 s1,s2,s3,...\n\n当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成\n\nP(o1,o2,o3,...|s1,s2,s3....) * P(s1,s2,s3,...) 其中\n\nP(o1,o2,o3,...|s1,s2,s3....) 表示某句话 s1,s2,s3...被读成 o1,o2,o3,...\n\n的可能性, 而\n\nP(s1,s2,s3,...) 表示字串 s1,s2,s3,...本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3...这个数列的可能性乘 以 s1,s2,s3...本身可以一个句子的可能性，得出概率。\n\n（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：\n\n第一，s1,s2,s3,... 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；\n\n第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,...|s1,s2,s3....) = P(o1|s1) * P(o2|s2)*P(o3|s3)...。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,...。\n\n满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,...是无法直接观测到的。\n\n隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,...当成中文，把 o1,o2,o3,...当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,...当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。\n\nP (o1,o2,o3,...|s1,s2,s3....) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,...) 就是我们在系列一中提到的语言模型。\n\n在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。\n\n我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。\n\n## 四、数学之美系列四 — 怎样度量信息\n\n2006 年 4 月 26 日 上午 08:11:00\n\n发表者：吴军，Google 研究员\n\n前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？\n\n信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。\n\n一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。\n\n那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。\n\n当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）\n\n有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是\n\n = -（$p1 *log p1 + p2 *log p2  + ．．．+ p32 *log p32$)，\n\n其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：\n\n变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。\n\n有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。\n\n不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。\n\n在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。\n\n对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章\n\n《语信息熵和语言模型的复杂度》\n\n## 五、简单之美：布尔代数和搜索引擎的索引 \n\n2006 年 5 月 10 日 上午 09:10:00\n\n发表者: 吴军，Google 研究员\n\n建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。\n\n世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。\n\n布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。\n\n布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。\n\nAND | 1 0\n\n----------------------- 1 | 1 0 0 | 0 0\n\n这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。\n\nOR | 1 0\n\n----------------------- 1 | 1 1 0 | 1 0\n\n这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。\n\nNOT |\n\n-------------- 1 | 0 0 | 1\n\n这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。\n\n读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。\n\n现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 -- 真（TRUE,或 1），否则，给一个逻辑值 -- 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用\n\n- 不包含原子弹\n\n一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。\n\n早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。\n\n最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001...，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001...。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001...。表示第五篇，第十六篇文献满足要求。\n\n注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一\n\n组数字，是包含该关键词 的文献序号。\n\n对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。\n\n不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。\n\n## 六、图论和网络爬虫 (Web Crawlers)\n\n2006 年 5 月 15 日 上午 07:15:00\n\n发表者: 吴军，Google 研究员\n\n离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。\n\n我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。\n\n图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。\n\n图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都\n访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。\n\n现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为\"机器人\" （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(\"www wanderer\")。以后的网络爬虫越写越复杂，但原理是一样的。\n\n我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。\n\n现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。\n\n## 七、信息论在信息处理中的应用\n\n我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。\n\n先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。\n\n信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。\n\n信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。\n\n“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 \" 爱尔兰的小母牛 \" ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。\n\n当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。\n\n信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。\n\n对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 \" 信息论基础 \"(Elements of Information Theory) ：\n\nm/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。\n\n## 八、贾里尼克的故事和现代语言处理\n\n2006 年 6 月 8 日 上午 09:15:00\n\n发表者：Google 研究员，吴军\n\n读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。\n\n弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。\n\n贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向--利用信息论解决语言问题产生的重要影 响。\n\n贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：\"我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。\" 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。\n\n贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ\n\nｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。\n\n七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。\n\n贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。\n\n贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。\n\n贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。\n\n贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。\n\n除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。\n\n贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。\n\n注释一：\n贾格布森的通信模型 \n1上下文 \n2信息\n3发送着\n4接收者\n5信道\n6编码\n\n## 九、如何确定网页和查询的相关性 \n\n2006 年 6 月 27 日 上午 09:53:00\n\n发表者：吴军，Google 研究员\n\n[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]\n\n我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。\n\n我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”\n\n相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,...,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, ..., TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + ... + TFN。\n\n读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。\n\n细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：\n\n1. 一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。\n\n2. 应删除词的权重应该是零。\n\n我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)\n\n则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1*IDF1 + TF2*IDF2 ＋... + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。\n\nＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。\n\n现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。\n\n如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。\n\n## 十、有限状态机和地址识别 \n\n2006 年 7 月 5 日 上午 09:09:00\n\n发表者：吴军，Google 研究员\n\n地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。\n\n一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。\n\n每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。\n\n使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。\n\n上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）\n\n为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。\n\n在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&T 实验 室风光不再，这三个人都离开了 AT&T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。\n\n\n## 十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士 \n\n2006 年 7 月 10 日 上午 09:52:00\n\n发表者：Google 研究员，吴军\n\n枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。\n\n我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。\n\n从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。\n\n后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。\n\n当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。\n\n辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，\n\n你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。\n\n辛格在 AT&T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。\n\n\n## 十二、余弦定理和新闻的分类 \n\n2006 年 7 月 20 日 上午 10:12:00\n\n发表者：吴军，Google 研究员\n\n余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。\n\nGoogle 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。\n\n我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为\n\n单 词编号 汉字词\n\n----------------- - 1 阿 2 啊\n\n3 阿斗 4 阿姨 ...\n\n789 服 装 ....\n\n64000 做作\n\n在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为\n\n单 词编号 TF/IDF 值 ============== 1 0\n\n2 0.0 034 3 0\n\n4 0.0 0052 5 0 ...\n\n789 0 .034 ...\n\n\n64000 0.075\n\n如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。\n\n学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。\n\n余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 --\n\n如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于\n\n其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,...,x64000 和 y1,y2,...,y64000,\n\n那么它们夹角的余弦等 于，\n\n当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。\n\n我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。\n\n","source":"_posts/The-Beauty-Of-Maths-01.md","raw":"title: 数学之美(1-12)\nauthor: Tim Zhang\ntags:\n  - 吴军\n  - 算法\n  - 数学\ncategories:\n  - Maths\n  - Algorithm\nmathjax: true\ndate: 2017-11-30 11:20:00\n---\n## 一、统计语言模型\n\n2006 年 4 月 3 日 上午 08:15:00\n\n从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。\n\n发表者: 吴军, Google 研究员\n\n前言\n\n也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。\n\n系列一： 统计语言模型 (Statistical Language Models)\n\nGoogle 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。\n\n其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。\n\n首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。\n\n给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。\n\n如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：\n\nP(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)\n\n其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：\n\nP(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…\n\n(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）\n\n接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。\n\n也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。\n\n现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。\n\n我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦\n\n## 二、谈谈中文分词 \n\n2006 年 4 月 10 日 上午 08:10:00\n\n发表者: 吴军， Google 研究员\n\n谈谈中文分词\n\n----- 统计语言模型在中文处理中的一个应用\n\n上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”\n\n分成一串词：\n\n中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。\n\n最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。\n\n用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。\n\n九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。\n\n利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：\n\n我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, ..., Ak, B1, B2, B3, ..., Bm C1, C2, C3, ..., Cn\n\n其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,..., Ak 是\n\n最好的分法，那么 （P 表示概率）：\n\nP (A1, A2, A3, ..., Ak） 〉 P (B1, B2, B3, ..., Bm), 并且 P (A1, A2, A3, ..., Ak） 〉 P(C1, C2, C3, ..., Cn)\n\n因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。\n\n当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。\n\n在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。\n\n需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。\n\n一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。\n\n也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。\n\n对中文分词有兴趣的读者，可以阅读以下文献：\n\n1. 梁南元\n\n书面汉语自动分词系统\n\nm/demo/LiangNanyuan-JCIP-1987.pdf\n\n2. 郭进\n\n统计语言模型和汉语音字转换的一些新结果\n\nm/demo/GuoJin-JCIP-1993.pdf\n\n3. 郭进\n\nCritical Tokenization and its Properties u/J/J97/J97-4004.pdf\n\n4. 孙茂松\n\nChinese word segmentation without using lexicon and hand-crafted training data\n\ng/m?coll=GUIDE&dl=GUIDE&id=980775\n\n## 三、隐含马尔可夫模型在语言处理中的应用\n\n2006 年 4 月 17 日 上午 08:01:00\n\n发表者：吴军，Google 研究员\n\n前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。\n\n自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 -- 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：\n\n其中 s1，s2，s3...表示信息源发出的信号。o1, o2, o3 ... 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 ...还原出发送的信 号 s1，s2，s3...。\n\n其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。\n\n那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,...的情况下，求使得条件概率 P (s1,s2,s3,...|o1,o2,o3....) 达到最大值的那个句子 s1,s2,s3,...\n\n当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成\n\nP(o1,o2,o3,...|s1,s2,s3....) * P(s1,s2,s3,...) 其中\n\nP(o1,o2,o3,...|s1,s2,s3....) 表示某句话 s1,s2,s3...被读成 o1,o2,o3,...\n\n的可能性, 而\n\nP(s1,s2,s3,...) 表示字串 s1,s2,s3,...本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3...这个数列的可能性乘 以 s1,s2,s3...本身可以一个句子的可能性，得出概率。\n\n（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：\n\n第一，s1,s2,s3,... 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；\n\n第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,...|s1,s2,s3....) = P(o1|s1) * P(o2|s2)*P(o3|s3)...。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,...。\n\n满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,...是无法直接观测到的。\n\n隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,...当成中文，把 o1,o2,o3,...当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,...当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。\n\nP (o1,o2,o3,...|s1,s2,s3....) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,...) 就是我们在系列一中提到的语言模型。\n\n在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。\n\n我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。\n\n## 四、数学之美系列四 — 怎样度量信息\n\n2006 年 4 月 26 日 上午 08:11:00\n\n发表者：吴军，Google 研究员\n\n前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？\n\n信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。\n\n一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。\n\n那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。\n\n当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）\n\n有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是\n\n = -（$p1 *log p1 + p2 *log p2  + ．．．+ p32 *log p32$)，\n\n其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：\n\n变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。\n\n有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。\n\n不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。\n\n在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。\n\n对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章\n\n《语信息熵和语言模型的复杂度》\n\n## 五、简单之美：布尔代数和搜索引擎的索引 \n\n2006 年 5 月 10 日 上午 09:10:00\n\n发表者: 吴军，Google 研究员\n\n建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。\n\n世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。\n\n布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。\n\n布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。\n\nAND | 1 0\n\n----------------------- 1 | 1 0 0 | 0 0\n\n这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。\n\nOR | 1 0\n\n----------------------- 1 | 1 1 0 | 1 0\n\n这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。\n\nNOT |\n\n-------------- 1 | 0 0 | 1\n\n这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。\n\n读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。\n\n现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 -- 真（TRUE,或 1），否则，给一个逻辑值 -- 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用\n\n- 不包含原子弹\n\n一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。\n\n早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。\n\n最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001...，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001...。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001...。表示第五篇，第十六篇文献满足要求。\n\n注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一\n\n组数字，是包含该关键词 的文献序号。\n\n对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。\n\n不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。\n\n## 六、图论和网络爬虫 (Web Crawlers)\n\n2006 年 5 月 15 日 上午 07:15:00\n\n发表者: 吴军，Google 研究员\n\n离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。\n\n我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。\n\n图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。\n\n图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都\n访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。\n\n现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为\"机器人\" （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(\"www wanderer\")。以后的网络爬虫越写越复杂，但原理是一样的。\n\n我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。\n\n现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。\n\n## 七、信息论在信息处理中的应用\n\n我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。\n\n先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。\n\n信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。\n\n信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。\n\n“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 \" 爱尔兰的小母牛 \" ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。\n\n当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。\n\n信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。\n\n对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 \" 信息论基础 \"(Elements of Information Theory) ：\n\nm/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。\n\n## 八、贾里尼克的故事和现代语言处理\n\n2006 年 6 月 8 日 上午 09:15:00\n\n发表者：Google 研究员，吴军\n\n读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。\n\n弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。\n\n贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向--利用信息论解决语言问题产生的重要影 响。\n\n贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：\"我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。\" 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。\n\n贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ\n\nｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。\n\n七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。\n\n贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。\n\n贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。\n\n贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。\n\n贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。\n\n除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。\n\n贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。\n\n注释一：\n贾格布森的通信模型 \n1上下文 \n2信息\n3发送着\n4接收者\n5信道\n6编码\n\n## 九、如何确定网页和查询的相关性 \n\n2006 年 6 月 27 日 上午 09:53:00\n\n发表者：吴军，Google 研究员\n\n[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]\n\n我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。\n\n我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”\n\n相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,...,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, ..., TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + ... + TFN。\n\n读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。\n\n细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：\n\n1. 一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。\n\n2. 应删除词的权重应该是零。\n\n我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)\n\n则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1*IDF1 + TF2*IDF2 ＋... + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。\n\nＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。\n\n现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。\n\n如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。\n\n## 十、有限状态机和地址识别 \n\n2006 年 7 月 5 日 上午 09:09:00\n\n发表者：吴军，Google 研究员\n\n地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。\n\n一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。\n\n每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。\n\n使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。\n\n上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）\n\n为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。\n\n在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&T 实验 室风光不再，这三个人都离开了 AT&T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。\n\n\n## 十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士 \n\n2006 年 7 月 10 日 上午 09:52:00\n\n发表者：Google 研究员，吴军\n\n枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。\n\n我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。\n\n从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。\n\n后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。\n\n当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。\n\n辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，\n\n你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。\n\n辛格在 AT&T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。\n\n\n## 十二、余弦定理和新闻的分类 \n\n2006 年 7 月 20 日 上午 10:12:00\n\n发表者：吴军，Google 研究员\n\n余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。\n\nGoogle 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。\n\n我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为\n\n单 词编号 汉字词\n\n----------------- - 1 阿 2 啊\n\n3 阿斗 4 阿姨 ...\n\n789 服 装 ....\n\n64000 做作\n\n在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为\n\n单 词编号 TF/IDF 值 ============== 1 0\n\n2 0.0 034 3 0\n\n4 0.0 0052 5 0 ...\n\n789 0 .034 ...\n\n\n64000 0.075\n\n如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。\n\n学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。\n\n余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 --\n\n如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于\n\n其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,...,x64000 和 y1,y2,...,y64000,\n\n那么它们夹角的余弦等 于，\n\n当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。\n\n我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。\n\n","slug":"The-Beauty-Of-Maths-01","published":1,"updated":"2018-12-03T07:04:53.379Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0n5o0025rd4lf41eqdj5","content":"<h2 id=\"一、统计语言模型\"><a href=\"#一、统计语言模型\" class=\"headerlink\" title=\"一、统计语言模型\"></a>一、统计语言模型</h2><p>2006 年 4 月 3 日 上午 08:15:00</p>\n<p>从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。</p>\n<p>发表者: 吴军, Google 研究员</p>\n<p>前言</p>\n<p>也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。</p>\n<p>系列一： 统计语言模型 (Statistical Language Models)</p>\n<p>Google 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。</p>\n<p>其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。</p>\n<p>首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。</p>\n<p>给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。</p>\n<p>如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)</p>\n<p>其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…</p>\n<p>(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）</p>\n<p>接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。</p>\n<p>也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。</p>\n<p>现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。</p>\n<p>我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦</p>\n<h2 id=\"二、谈谈中文分词\"><a href=\"#二、谈谈中文分词\" class=\"headerlink\" title=\"二、谈谈中文分词\"></a>二、谈谈中文分词</h2><p>2006 年 4 月 10 日 上午 08:10:00</p>\n<p>发表者: 吴军， Google 研究员</p>\n<p>谈谈中文分词</p>\n<p>—– 统计语言模型在中文处理中的一个应用</p>\n<p>上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”</p>\n<p>分成一串词：</p>\n<p>中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。</p>\n<p>最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。</p>\n<p>用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。</p>\n<p>九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。</p>\n<p>利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：</p>\n<p>我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, …, Ak, B1, B2, B3, …, Bm C1, C2, C3, …, Cn</p>\n<p>其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,…, Ak 是</p>\n<p>最好的分法，那么 （P 表示概率）：</p>\n<p>P (A1, A2, A3, …, Ak） 〉 P (B1, B2, B3, …, Bm), 并且 P (A1, A2, A3, …, Ak） 〉 P(C1, C2, C3, …, Cn)</p>\n<p>因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。</p>\n<p>当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。</p>\n<p>在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。</p>\n<p>需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。</p>\n<p>一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。</p>\n<p>也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。</p>\n<p>对中文分词有兴趣的读者，可以阅读以下文献：</p>\n<ol>\n<li>梁南元</li>\n</ol>\n<p>书面汉语自动分词系统</p>\n<p>m/demo/LiangNanyuan-JCIP-1987.pdf</p>\n<ol start=\"2\">\n<li>郭进</li>\n</ol>\n<p>统计语言模型和汉语音字转换的一些新结果</p>\n<p>m/demo/GuoJin-JCIP-1993.pdf</p>\n<ol start=\"3\">\n<li>郭进</li>\n</ol>\n<p>Critical Tokenization and its Properties u/J/J97/J97-4004.pdf</p>\n<ol start=\"4\">\n<li>孙茂松</li>\n</ol>\n<p>Chinese word segmentation without using lexicon and hand-crafted training data</p>\n<p>g/m?coll=GUIDE&amp;dl=GUIDE&amp;id=980775</p>\n<h2 id=\"三、隐含马尔可夫模型在语言处理中的应用\"><a href=\"#三、隐含马尔可夫模型在语言处理中的应用\" class=\"headerlink\" title=\"三、隐含马尔可夫模型在语言处理中的应用\"></a>三、隐含马尔可夫模型在语言处理中的应用</h2><p>2006 年 4 月 17 日 上午 08:01:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。</p>\n<p>自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 – 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：</p>\n<p>其中 s1，s2，s3…表示信息源发出的信号。o1, o2, o3 … 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 …还原出发送的信 号 s1，s2，s3…。</p>\n<p>其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。</p>\n<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>\n<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…) 其中</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…</p>\n<p>的可能性, 而</p>\n<p>P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘 以 s1,s2,s3…本身可以一个句子的可能性，得出概率。</p>\n<p>（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：</p>\n<p>第一，s1,s2,s3,… 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；</p>\n<p>第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,…|s1,s2,s3….) = P(o1|s1) <em> P(o2|s2)</em>P(o3|s3)…。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,…。</p>\n<p>满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,…是无法直接观测到的。</p>\n<p>隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,…当成中文，把 o1,o2,o3,…当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,…当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。</p>\n<p>P (o1,o2,o3,…|s1,s2,s3….) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,…) 就是我们在系列一中提到的语言模型。</p>\n<p>在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。</p>\n<p>我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。</p>\n<h2 id=\"四、数学之美系列四-—-怎样度量信息\"><a href=\"#四、数学之美系列四-—-怎样度量信息\" class=\"headerlink\" title=\"四、数学之美系列四 — 怎样度量信息\"></a>四、数学之美系列四 — 怎样度量信息</h2><p>2006 年 4 月 26 日 上午 08:11:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？</p>\n<p>信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。</p>\n<p>一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。</p>\n<p>那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。</p>\n<p>当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）</p>\n<p>有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是</p>\n<p> = -（$p1 <em>log p1 + p2 </em>log p2  + ．．．+ p32 *log p32$)，</p>\n<p>其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：</p>\n<p>变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。</p>\n<p>有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。</p>\n<p>不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。</p>\n<p>在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。</p>\n<p>对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章</p>\n<p>《语信息熵和语言模型的复杂度》</p>\n<h2 id=\"五、简单之美：布尔代数和搜索引擎的索引\"><a href=\"#五、简单之美：布尔代数和搜索引擎的索引\" class=\"headerlink\" title=\"五、简单之美：布尔代数和搜索引擎的索引\"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>2006 年 5 月 10 日 上午 09:10:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。</p>\n<p>世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。</p>\n<p>布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。</p>\n<p>布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。</p>\n<p>AND | 1 0</p>\n<p>———————– 1 | 1 0 0 | 0 0</p>\n<p>这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。</p>\n<p>OR | 1 0</p>\n<p>———————– 1 | 1 1 0 | 1 0</p>\n<p>这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。</p>\n<p>NOT |</p>\n<p>————– 1 | 0 0 | 1</p>\n<p>这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。</p>\n<p>读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。</p>\n<p>现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 – 真（TRUE,或 1），否则，给一个逻辑值 – 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用</p>\n<ul>\n<li>不包含原子弹</li>\n</ul>\n<p>一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。</p>\n<p>早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。</p>\n<p>最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001…，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001…。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001…。表示第五篇，第十六篇文献满足要求。</p>\n<p>注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一</p>\n<p>组数字，是包含该关键词 的文献序号。</p>\n<p>对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。</p>\n<p>不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。</p>\n<h2 id=\"六、图论和网络爬虫-Web-Crawlers\"><a href=\"#六、图论和网络爬虫-Web-Crawlers\" class=\"headerlink\" title=\"六、图论和网络爬虫 (Web Crawlers)\"></a>六、图论和网络爬虫 (Web Crawlers)</h2><p>2006 年 5 月 15 日 上午 07:15:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。</p>\n<p>我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。</p>\n<p>图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。</p>\n<p>图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都<br>访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。</p>\n<p>现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为”机器人” （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(“www wanderer”)。以后的网络爬虫越写越复杂，但原理是一样的。</p>\n<p>我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。</p>\n<p>现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。</p>\n<h2 id=\"七、信息论在信息处理中的应用\"><a href=\"#七、信息论在信息处理中的应用\" class=\"headerlink\" title=\"七、信息论在信息处理中的应用\"></a>七、信息论在信息处理中的应用</h2><p>我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。</p>\n<p>先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。</p>\n<p>信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。</p>\n<p>信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。</p>\n<p>“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 “ 爱尔兰的小母牛 “ ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。</p>\n<p>当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。</p>\n<p>信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。</p>\n<p>对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 “ 信息论基础 “(Elements of Information Theory) ：</p>\n<p>m/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。</p>\n<h2 id=\"八、贾里尼克的故事和现代语言处理\"><a href=\"#八、贾里尼克的故事和现代语言处理\" class=\"headerlink\" title=\"八、贾里尼克的故事和现代语言处理\"></a>八、贾里尼克的故事和现代语言处理</h2><p>2006 年 6 月 8 日 上午 09:15:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。</p>\n<p>弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。</p>\n<p>贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向–利用信息论解决语言问题产生的重要影 响。</p>\n<p>贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：”我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。” 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。</p>\n<p>贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ</p>\n<p>ｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。</p>\n<p>七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。</p>\n<p>贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。</p>\n<p>贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。</p>\n<p>贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&amp;T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。</p>\n<p>贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。</p>\n<p>除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。</p>\n<p>贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。</p>\n<p>注释一：<br>贾格布森的通信模型<br>1上下文<br>2信息<br>3发送着<br>4接收者<br>5信道<br>6编码</p>\n<h2 id=\"九、如何确定网页和查询的相关性\"><a href=\"#九、如何确定网页和查询的相关性\" class=\"headerlink\" title=\"九、如何确定网页和查询的相关性\"></a>九、如何确定网页和查询的相关性</h2><p>2006 年 6 月 27 日 上午 09:53:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]</p>\n<p>我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。</p>\n<p>我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”</p>\n<p>相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,…,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, …, TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + … + TFN。</p>\n<p>读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。</p>\n<p>细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p>\n<ol>\n<li><p>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</p>\n</li>\n<li><p>应删除词的权重应该是零。</p>\n</li>\n</ol>\n<p>我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)</p>\n<p>则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1<em>IDF1 + TF2</em>IDF2 ＋… + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。</p>\n<p>ＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。</p>\n<p>现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。</p>\n<p>如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。</p>\n<h2 id=\"十、有限状态机和地址识别\"><a href=\"#十、有限状态机和地址识别\" class=\"headerlink\" title=\"十、有限状态机和地址识别\"></a>十、有限状态机和地址识别</h2><p>2006 年 7 月 5 日 上午 09:09:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。</p>\n<p>一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。</p>\n<p>每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。</p>\n<p>使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。</p>\n<p>上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）</p>\n<p>为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。</p>\n<p>在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&amp;T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&amp;T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&amp;T 实验 室风光不再，这三个人都离开了 AT&amp;T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&amp;T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&amp;T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。</p>\n<h2 id=\"十一、-Google-阿卡-47-的制造者阿米特-辛格博士\"><a href=\"#十一、-Google-阿卡-47-的制造者阿米特-辛格博士\" class=\"headerlink\" title=\"十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士\"></a>十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士</h2><p>2006 年 7 月 10 日 上午 09:52:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。</p>\n<p>我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。</p>\n<p>从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。</p>\n<p>后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。</p>\n<p>当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&amp;T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&amp;T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。</p>\n<p>辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，</p>\n<p>你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。</p>\n<p>辛格在 AT&amp;T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。</p>\n<h2 id=\"十二、余弦定理和新闻的分类\"><a href=\"#十二、余弦定理和新闻的分类\" class=\"headerlink\" title=\"十二、余弦定理和新闻的分类\"></a>十二、余弦定理和新闻的分类</h2><p>2006 年 7 月 20 日 上午 10:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。</p>\n<p>Google 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。</p>\n<p>我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为</p>\n<p>单 词编号 汉字词</p>\n<p>—————– - 1 阿 2 啊</p>\n<p>3 阿斗 4 阿姨 …</p>\n<p>789 服 装 ….</p>\n<p>64000 做作</p>\n<p>在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为</p>\n<p>单 词编号 TF/IDF 值 ============== 1 0</p>\n<p>2 0.0 034 3 0</p>\n<p>4 0.0 0052 5 0 …</p>\n<p>789 0 .034 …</p>\n<p>64000 0.075</p>\n<p>如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。</p>\n<p>学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。</p>\n<p>余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 –</p>\n<p>如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于</p>\n<p>其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,…,x64000 和 y1,y2,…,y64000,</p>\n<p>那么它们夹角的余弦等 于，</p>\n<p>当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。</p>\n<p>我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。</p>\n<div><h1>おススメ記事<span style=\"font-size:0.45em; color:gray\">（<a href=\"https://github.com/huiwang/hexo-recommended-posts\">hexo-recommend-posts</a>）</span></h1><ul><li><a href=\"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/\">数学之美(13-24)</a></li><li><a href=\"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/\">数学之美(13-24)</a></li><li><a href=\"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/\">数学之美(13-24)</a></li><li><a href=\"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/\">区块链学习备忘录之共识算法</a></li></ul></div>","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"一、统计语言模型\"><a href=\"#一、统计语言模型\" class=\"headerlink\" title=\"一、统计语言模型\"></a>一、统计语言模型</h2><p>2006 年 4 月 3 日 上午 08:15:00</p>\n<p>从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。</p>\n<p>发表者: 吴军, Google 研究员</p>\n<p>前言</p>\n<p>也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。</p>\n<p>系列一： 统计语言模型 (Statistical Language Models)</p>\n<p>Google 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。</p>\n<p>其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。</p>\n<p>首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。</p>\n<p>给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。</p>\n<p>如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)</p>\n<p>其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…</p>\n<p>(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）</p>\n<p>接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。</p>\n<p>也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。</p>\n<p>现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。</p>\n<p>我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦</p>\n<h2 id=\"二、谈谈中文分词\"><a href=\"#二、谈谈中文分词\" class=\"headerlink\" title=\"二、谈谈中文分词\"></a>二、谈谈中文分词</h2><p>2006 年 4 月 10 日 上午 08:10:00</p>\n<p>发表者: 吴军， Google 研究员</p>\n<p>谈谈中文分词</p>\n<p>—– 统计语言模型在中文处理中的一个应用</p>\n<p>上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”</p>\n<p>分成一串词：</p>\n<p>中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。</p>\n<p>最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。</p>\n<p>用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。</p>\n<p>九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。</p>\n<p>利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：</p>\n<p>我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, …, Ak, B1, B2, B3, …, Bm C1, C2, C3, …, Cn</p>\n<p>其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,…, Ak 是</p>\n<p>最好的分法，那么 （P 表示概率）：</p>\n<p>P (A1, A2, A3, …, Ak） 〉 P (B1, B2, B3, …, Bm), 并且 P (A1, A2, A3, …, Ak） 〉 P(C1, C2, C3, …, Cn)</p>\n<p>因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。</p>\n<p>当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。</p>\n<p>在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。</p>\n<p>需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。</p>\n<p>一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。</p>\n<p>也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。</p>\n<p>对中文分词有兴趣的读者，可以阅读以下文献：</p>\n<ol>\n<li>梁南元</li>\n</ol>\n<p>书面汉语自动分词系统</p>\n<p>m/demo/LiangNanyuan-JCIP-1987.pdf</p>\n<ol start=\"2\">\n<li>郭进</li>\n</ol>\n<p>统计语言模型和汉语音字转换的一些新结果</p>\n<p>m/demo/GuoJin-JCIP-1993.pdf</p>\n<ol start=\"3\">\n<li>郭进</li>\n</ol>\n<p>Critical Tokenization and its Properties u/J/J97/J97-4004.pdf</p>\n<ol start=\"4\">\n<li>孙茂松</li>\n</ol>\n<p>Chinese word segmentation without using lexicon and hand-crafted training data</p>\n<p>g/m?coll=GUIDE&amp;dl=GUIDE&amp;id=980775</p>\n<h2 id=\"三、隐含马尔可夫模型在语言处理中的应用\"><a href=\"#三、隐含马尔可夫模型在语言处理中的应用\" class=\"headerlink\" title=\"三、隐含马尔可夫模型在语言处理中的应用\"></a>三、隐含马尔可夫模型在语言处理中的应用</h2><p>2006 年 4 月 17 日 上午 08:01:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。</p>\n<p>自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 – 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：</p>\n<p>其中 s1，s2，s3…表示信息源发出的信号。o1, o2, o3 … 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 …还原出发送的信 号 s1，s2，s3…。</p>\n<p>其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。</p>\n<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>\n<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…) 其中</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…</p>\n<p>的可能性, 而</p>\n<p>P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘 以 s1,s2,s3…本身可以一个句子的可能性，得出概率。</p>\n<p>（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：</p>\n<p>第一，s1,s2,s3,… 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；</p>\n<p>第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,…|s1,s2,s3….) = P(o1|s1) <em> P(o2|s2)</em>P(o3|s3)…。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,…。</p>\n<p>满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,…是无法直接观测到的。</p>\n<p>隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,…当成中文，把 o1,o2,o3,…当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,…当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。</p>\n<p>P (o1,o2,o3,…|s1,s2,s3….) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,…) 就是我们在系列一中提到的语言模型。</p>\n<p>在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。</p>\n<p>我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。</p>\n<h2 id=\"四、数学之美系列四-—-怎样度量信息\"><a href=\"#四、数学之美系列四-—-怎样度量信息\" class=\"headerlink\" title=\"四、数学之美系列四 — 怎样度量信息\"></a>四、数学之美系列四 — 怎样度量信息</h2><p>2006 年 4 月 26 日 上午 08:11:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？</p>\n<p>信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。</p>\n<p>一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。</p>\n<p>那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。</p>\n<p>当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）</p>\n<p>有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是</p>\n<p> = -（$p1 <em>log p1 + p2 </em>log p2  + ．．．+ p32 *log p32$)，</p>\n<p>其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：</p>\n<p>变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。</p>\n<p>有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。</p>\n<p>不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。</p>\n<p>在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。</p>\n<p>对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章</p>\n<p>《语信息熵和语言模型的复杂度》</p>\n<h2 id=\"五、简单之美：布尔代数和搜索引擎的索引\"><a href=\"#五、简单之美：布尔代数和搜索引擎的索引\" class=\"headerlink\" title=\"五、简单之美：布尔代数和搜索引擎的索引\"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>2006 年 5 月 10 日 上午 09:10:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。</p>\n<p>世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。</p>\n<p>布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。</p>\n<p>布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。</p>\n<p>AND | 1 0</p>\n<p>———————– 1 | 1 0 0 | 0 0</p>\n<p>这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。</p>\n<p>OR | 1 0</p>\n<p>———————– 1 | 1 1 0 | 1 0</p>\n<p>这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。</p>\n<p>NOT |</p>\n<p>————– 1 | 0 0 | 1</p>\n<p>这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。</p>\n<p>读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。</p>\n<p>现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 – 真（TRUE,或 1），否则，给一个逻辑值 – 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用</p>\n<ul>\n<li>不包含原子弹</li>\n</ul>\n<p>一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。</p>\n<p>早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。</p>\n<p>最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001…，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001…。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001…。表示第五篇，第十六篇文献满足要求。</p>\n<p>注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一</p>\n<p>组数字，是包含该关键词 的文献序号。</p>\n<p>对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。</p>\n<p>不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。</p>\n<h2 id=\"六、图论和网络爬虫-Web-Crawlers\"><a href=\"#六、图论和网络爬虫-Web-Crawlers\" class=\"headerlink\" title=\"六、图论和网络爬虫 (Web Crawlers)\"></a>六、图论和网络爬虫 (Web Crawlers)</h2><p>2006 年 5 月 15 日 上午 07:15:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。</p>\n<p>我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。</p>\n<p>图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。</p>\n<p>图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都<br>访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。</p>\n<p>现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为”机器人” （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(“www wanderer”)。以后的网络爬虫越写越复杂，但原理是一样的。</p>\n<p>我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。</p>\n<p>现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。</p>\n<h2 id=\"七、信息论在信息处理中的应用\"><a href=\"#七、信息论在信息处理中的应用\" class=\"headerlink\" title=\"七、信息论在信息处理中的应用\"></a>七、信息论在信息处理中的应用</h2><p>我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。</p>\n<p>先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。</p>\n<p>信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。</p>\n<p>信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。</p>\n<p>“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 “ 爱尔兰的小母牛 “ ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。</p>\n<p>当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。</p>\n<p>信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。</p>\n<p>对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 “ 信息论基础 “(Elements of Information Theory) ：</p>\n<p>m/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。</p>\n<h2 id=\"八、贾里尼克的故事和现代语言处理\"><a href=\"#八、贾里尼克的故事和现代语言处理\" class=\"headerlink\" title=\"八、贾里尼克的故事和现代语言处理\"></a>八、贾里尼克的故事和现代语言处理</h2><p>2006 年 6 月 8 日 上午 09:15:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。</p>\n<p>弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。</p>\n<p>贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向–利用信息论解决语言问题产生的重要影 响。</p>\n<p>贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：”我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。” 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。</p>\n<p>贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ</p>\n<p>ｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。</p>\n<p>七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。</p>\n<p>贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。</p>\n<p>贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。</p>\n<p>贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&amp;T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。</p>\n<p>贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。</p>\n<p>除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。</p>\n<p>贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。</p>\n<p>注释一：<br>贾格布森的通信模型<br>1上下文<br>2信息<br>3发送着<br>4接收者<br>5信道<br>6编码</p>\n<h2 id=\"九、如何确定网页和查询的相关性\"><a href=\"#九、如何确定网页和查询的相关性\" class=\"headerlink\" title=\"九、如何确定网页和查询的相关性\"></a>九、如何确定网页和查询的相关性</h2><p>2006 年 6 月 27 日 上午 09:53:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]</p>\n<p>我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。</p>\n<p>我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”</p>\n<p>相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,…,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, …, TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + … + TFN。</p>\n<p>读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。</p>\n<p>细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p>\n<ol>\n<li><p>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</p>\n</li>\n<li><p>应删除词的权重应该是零。</p>\n</li>\n</ol>\n<p>我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)</p>\n<p>则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1<em>IDF1 + TF2</em>IDF2 ＋… + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。</p>\n<p>ＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。</p>\n<p>现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。</p>\n<p>如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。</p>\n<h2 id=\"十、有限状态机和地址识别\"><a href=\"#十、有限状态机和地址识别\" class=\"headerlink\" title=\"十、有限状态机和地址识别\"></a>十、有限状态机和地址识别</h2><p>2006 年 7 月 5 日 上午 09:09:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。</p>\n<p>一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。</p>\n<p>每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。</p>\n<p>使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。</p>\n<p>上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）</p>\n<p>为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。</p>\n<p>在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&amp;T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&amp;T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&amp;T 实验 室风光不再，这三个人都离开了 AT&amp;T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&amp;T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&amp;T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。</p>\n<h2 id=\"十一、-Google-阿卡-47-的制造者阿米特-辛格博士\"><a href=\"#十一、-Google-阿卡-47-的制造者阿米特-辛格博士\" class=\"headerlink\" title=\"十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士\"></a>十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士</h2><p>2006 年 7 月 10 日 上午 09:52:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。</p>\n<p>我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。</p>\n<p>从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。</p>\n<p>后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。</p>\n<p>当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&amp;T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&amp;T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。</p>\n<p>辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，</p>\n<p>你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。</p>\n<p>辛格在 AT&amp;T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。</p>\n<h2 id=\"十二、余弦定理和新闻的分类\"><a href=\"#十二、余弦定理和新闻的分类\" class=\"headerlink\" title=\"十二、余弦定理和新闻的分类\"></a>十二、余弦定理和新闻的分类</h2><p>2006 年 7 月 20 日 上午 10:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。</p>\n<p>Google 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。</p>\n<p>我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为</p>\n<p>单 词编号 汉字词</p>\n<p>—————– - 1 阿 2 啊</p>\n<p>3 阿斗 4 阿姨 …</p>\n<p>789 服 装 ….</p>\n<p>64000 做作</p>\n<p>在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为</p>\n<p>单 词编号 TF/IDF 值 ============== 1 0</p>\n<p>2 0.0 034 3 0</p>\n<p>4 0.0 0052 5 0 …</p>\n<p>789 0 .034 …</p>\n<p>64000 0.075</p>\n<p>如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。</p>\n<p>学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。</p>\n<p>余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 –</p>\n<p>如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于</p>\n<p>其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,…,x64000 和 y1,y2,…,y64000,</p>\n<p>那么它们夹角的余弦等 于，</p>\n<p>当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。</p>\n<p>我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。</p>\n"},{"title":"数学之美","author":"Tim Zhang","mathjax":true,"date":"2018-11-30T02:20:00.000Z","_content":"## 一、统计语言模型\n\n2006 年 4 月 3 日 上午 08:15:00\n\n从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。\n\n发表者: 吴军, Google 研究员\n\n前言\n\n也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。\n\n系列一： 统计语言模型 (Statistical Language Models)\n\nGoogle 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。\n\n其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。\n\n首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。\n\n给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。\n\n如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：\n\nP(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)\n\n其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：\n\nP(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…\n\n(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）\n\n接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。\n\n也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。\n\n现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。\n\n我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦\n\n## 二、谈谈中文分词 \n\n2006 年 4 月 10 日 上午 08:10:00\n\n发表者: 吴军， Google 研究员\n\n谈谈中文分词\n\n----- 统计语言模型在中文处理中的一个应用\n\n上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”\n\n分成一串词：\n\n中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。\n\n最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。\n\n用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。\n\n九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。\n\n利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：\n\n我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, ..., Ak, B1, B2, B3, ..., Bm C1, C2, C3, ..., Cn\n\n其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,..., Ak 是\n\n最好的分法，那么 （P 表示概率）：\n\nP (A1, A2, A3, ..., Ak） 〉 P (B1, B2, B3, ..., Bm), 并且 P (A1, A2, A3, ..., Ak） 〉 P(C1, C2, C3, ..., Cn)\n\n因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。\n\n当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。\n\n在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。\n\n需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。\n\n一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。\n\n也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。\n\n对中文分词有兴趣的读者，可以阅读以下文献：\n\n1. 梁南元\n\n书面汉语自动分词系统\n\nm/demo/LiangNanyuan-JCIP-1987.pdf\n\n2. 郭进\n\n统计语言模型和汉语音字转换的一些新结果\n\nm/demo/GuoJin-JCIP-1993.pdf\n\n3. 郭进\n\nCritical Tokenization and its Properties u/J/J97/J97-4004.pdf\n\n4. 孙茂松\n\nChinese word segmentation without using lexicon and hand-crafted training data\n\ng/m?coll=GUIDE&dl=GUIDE&id=980775\n\n## 三、隐含马尔可夫模型在语言处理中的应用\n\n2006 年 4 月 17 日 上午 08:01:00\n\n发表者：吴军，Google 研究员\n\n前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。\n\n自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 -- 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：\n\n其中 s1，s2，s3...表示信息源发出的信号。o1, o2, o3 ... 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 ...还原出发送的信 号 s1，s2，s3...。\n\n其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。\n\n那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,...的情况下，求使得条件概率 P (s1,s2,s3,...|o1,o2,o3....) 达到最大值的那个句子 s1,s2,s3,...\n\n当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成\n\nP(o1,o2,o3,...|s1,s2,s3....) * P(s1,s2,s3,...) 其中\n\nP(o1,o2,o3,...|s1,s2,s3....) 表示某句话 s1,s2,s3...被读成 o1,o2,o3,...\n\n的可能性, 而\n\nP(s1,s2,s3,...) 表示字串 s1,s2,s3,...本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3...这个数列的可能性乘 以 s1,s2,s3...本身可以一个句子的可能性，得出概率。\n\n（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：\n\n第一，s1,s2,s3,... 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；\n\n第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,...|s1,s2,s3....) = P(o1|s1) * P(o2|s2)*P(o3|s3)...。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,...。\n\n满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,...是无法直接观测到的。\n\n隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,...当成中文，把 o1,o2,o3,...当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,...当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。\n\nP (o1,o2,o3,...|s1,s2,s3....) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,...) 就是我们在系列一中提到的语言模型。\n\n在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。\n\n我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。\n\n## 四、数学之美系列四 — 怎样度量信息\n\n2006 年 4 月 26 日 上午 08:11:00\n\n发表者：吴军，Google 研究员\n\n前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？\n\n信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。\n\n一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。\n\n那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。\n\n当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）\n\n有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是\n\n = -（$p1 *log p1 + p2 *log p2  + ．．．+ p32 *log p32$)，\n\n其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：\n\n变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。\n\n有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。\n\n不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。\n\n在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。\n\n对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章\n\n《语信息熵和语言模型的复杂度》\n\n## 五、简单之美：布尔代数和搜索引擎的索引 \n\n2006 年 5 月 10 日 上午 09:10:00\n\n发表者: 吴军，Google 研究员\n\n建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。\n\n世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。\n\n布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。\n\n布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。\n\nAND | 1 0\n\n----------------------- 1 | 1 0 0 | 0 0\n\n这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。\n\nOR | 1 0\n\n----------------------- 1 | 1 1 0 | 1 0\n\n这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。\n\nNOT |\n\n-------------- 1 | 0 0 | 1\n\n这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。\n\n读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。\n\n现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 -- 真（TRUE,或 1），否则，给一个逻辑值 -- 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用\n\n- 不包含原子弹\n\n一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。\n\n早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。\n\n最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001...，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001...。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001...。表示第五篇，第十六篇文献满足要求。\n\n注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一\n\n组数字，是包含该关键词 的文献序号。\n\n对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。\n\n不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。\n\n## 六、图论和网络爬虫 (Web Crawlers)\n\n2006 年 5 月 15 日 上午 07:15:00\n\n发表者: 吴军，Google 研究员\n\n离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。\n\n我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。\n\n图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。\n\n图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都\n访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。\n\n现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为\"机器人\" （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(\"www wanderer\")。以后的网络爬虫越写越复杂，但原理是一样的。\n\n我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。\n\n现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。\n\n## 七、信息论在信息处理中的应用\n\n我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。\n\n先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。\n\n信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。\n\n信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。\n\n“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 \" 爱尔兰的小母牛 \" ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。\n\n当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。\n\n信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。\n\n对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 \" 信息论基础 \"(Elements of Information Theory) ：\n\nm/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。\n\n## 八、贾里尼克的故事和现代语言处理\n\n2006 年 6 月 8 日 上午 09:15:00\n\n发表者：Google 研究员，吴军\n\n读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。\n\n弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。\n\n贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向--利用信息论解决语言问题产生的重要影 响。\n\n贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：\"我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。\" 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。\n\n贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ\n\nｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。\n\n七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。\n\n贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。\n\n贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。\n\n贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。\n\n贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。\n\n除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。\n\n贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。\n\n注释一：\n贾格布森的通信模型 \n1上下文 \n2信息\n3发送着\n4接收者\n5信道\n6编码\n\n## 九、如何确定网页和查询的相关性 \n\n2006 年 6 月 27 日 上午 09:53:00\n\n发表者：吴军，Google 研究员\n\n[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]\n\n我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。\n\n我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”\n\n相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,...,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, ..., TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + ... + TFN。\n\n读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。\n\n细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：\n\n1. 一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。\n\n2. 应删除词的权重应该是零。\n\n我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)\n\n则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1*IDF1 + TF2*IDF2 ＋... + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。\n\nＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。\n\n现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。\n\n如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。\n\n## 十、有限状态机和地址识别 \n\n2006 年 7 月 5 日 上午 09:09:00\n\n发表者：吴军，Google 研究员\n\n地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。\n\n一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。\n\n每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。\n\n使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。\n\n上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）\n\n为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。\n\n在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&T 实验 室风光不再，这三个人都离开了 AT&T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。\n\n\n## 十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士 \n\n2006 年 7 月 10 日 上午 09:52:00\n\n发表者：Google 研究员，吴军\n\n枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。\n\n我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。\n\n从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。\n\n后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。\n\n当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。\n\n辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，\n\n你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。\n\n辛格在 AT&T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。\n\n\n## 十二、余弦定理和新闻的分类 \n\n2006 年 7 月 20 日 上午 10:12:00\n\n发表者：吴军，Google 研究员\n\n余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。\n\nGoogle 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。\n\n我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为\n\n单 词编号 汉字词\n\n----------------- - 1 阿 2 啊\n\n3 阿斗 4 阿姨 ...\n\n789 服 装 ....\n\n64000 做作\n\n在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为\n\n单 词编号 TF/IDF 值 ============== 1 0\n\n2 0.0 034 3 0\n\n4 0.0 0052 5 0 ...\n\n789 0 .034 ...\n\n\n64000 0.075\n\n如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。\n\n学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。\n\n余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 --\n\n如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于\n\n其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,...,x64000 和 y1,y2,...,y64000,\n\n那么它们夹角的余弦等 于，\n\n当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。\n\n我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。\n\n## 十三、信息指纹及其应用 \n\n2006 年 8 月 3 日 上午 11:17:00\n\n发表者：吴军，Google 研究员\n\n任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。\n\n我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接\n\nm/s?ie=gb2312&bs=%CA%FD%D1%A7%D6%AE%C3%C0&sr=&amp; z=&cl=3&f=8\n\n&wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&ct=0\n\n假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:\n\n893249432984398432980545454543\n\n这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。\n\n产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。\n\n信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，\n\n比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。\n\n互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。\n\n信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。\n\n## 十四、谈谈数学模型的重要性\n\n2006 年 8 月 9 日 上午 09:12:00\n\n发表者：吴军，Google 研究员\n\n注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。\n\n在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）\n\n但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。\n\n当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。\n\n地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。\n\n纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。\n\n完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。\n\n故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。\n\n讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：\n\n１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。） \n２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）\n３. 大量准确的数据对研发很重要。\n４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。\n\n在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。\n\n## 十五、繁与简 自然语言处理的几位精英 \n\n2006 年 8 月 23 日 下午 11:22:00\n\n发表者：吴军，Google 研究员\n\n我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。\n\n柯林斯：追求完美\n\n柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。\n\n柯 林斯毕业后，在 AT&T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。\n\n布莱尔：简单才美\n\n在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：\n\n第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；\n\n第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；\n\n第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。\n\n布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。\n\n由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）\n\n在接下来了系列里，我们还会介绍一个繁与简结合的例子。\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 -- 谈谈最大熵模型 （上）\n\n2006 年 10 月 8 日 上午 07:27:00\n\n发表者：Google 研究员，吴军\n\n我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (\"the maximum entropy principle\")。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。\n\n前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。\n\n让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是\"wang-xiao-bo\"， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。\n\n数学上最漂亮的办法是最大熵(\"maximum entropy\")模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。\n\n有 一次，我去 AT&T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。\n\n最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。\n\n回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 -- 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。\n\n我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。\n\n最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。\n\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\n\n2006 年 11 月 16 日 上午 06:50:00\n\n发表者：Google 研究员，吴军\n\n我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。\n\n最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：\n\n1. 假定第零次迭代的初始模型为等概率的均匀分布。\n\n2. 用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。\n\nGIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。\n\n八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。\n\n由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。\n\n但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。\n\n最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。\n\n讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司----文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。\n\n值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。\n\n## 十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\n\n2006 年 11 月 28 日 上午 03:18:00\n\nGoogle 研究员 吴军\n\n自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。\n\n搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。\n\n在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。\n\n几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此\" 痛改前非\"，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。\n\n抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：\n\n在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）\n\n搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。\n\n还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。\n\n## 十八、矩阵运算和文本处理中的分类问题 \n\n2007 年 1 月 1 日 下午 03:10:00\n\n发表者：Google 研究员，吴军\n\n我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。\n\n在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。\n\n分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。\n\n在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。\n\n在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。\n\n奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。\n\n三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。\n\n现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。\n\n\n## 十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\n\n我们在前面的系列中多次提到 马尔可夫链 (Markov\n\nChain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。\n\n我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。\n\n和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。\n\n使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。\n\n值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。\n\n贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。\n\n## 二十、自然语言处理的教父 马库斯 \n\n2007 年 4 月 13 日 下午 07:03:00\n\n发表者：Google 研究员，吴军\n\n我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。\n\n马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree\n\nBank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。\n\n马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。\n\n作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。\n\n过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。\n\n\n## 二十一、布隆过滤器（ Bloom Filter ） \n\n2007 年 7 月 3 日 上午 09:35:00\n\n发表者：Google（谷歌）研究员 吴军\n\n在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的\n\n具体办法是将每一个\n email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹\n\nm/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。\n\n今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。\n\n布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。\n\n假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指 纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）\n\n现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, ..., F8）对这个地址产 生八个信息指纹 s1,s2,...,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,...,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。\n\n布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。\n\n布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。\n\n## 二十二、谈谈密码学的数学原理 \n\n2007 年 9 月 13 日 下午 09:00:00\n\n发表者：Google（谷歌）研究员 吴军\n\n前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）\n\n密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说\n\n这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。\n\n事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。\n\n公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。\n\n1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。\n\n2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。\n\n3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。\n\n现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。\n\n现在，我们用下面的公式对 X 加密，得到密码 Y。\n\n好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。\n\n这个过程大致可以概况如下：\n\n公开密钥的好处有：\n\n1.简单。\n\n2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。\n\n3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。\n\n最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的\n\n395058745832651445264197678006144819960207764603049364541393760515793 556265294\n\n506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =\n\n338849583746672139436839320467218152281583036860499304808492584055528 1177\n\n×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139\n\n现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。\n\n不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。\n\n## 二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\n\n2007 年 12 月 3 日 上午 10:05:00\n\n发表者：Google（谷歌）研究员 吴军\n\n今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。\n\n我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是\n\np1, p2, p3, ..., p6700 它们编码的长度是\n\nL1, L2, L3, ..., L6700 那么，平均编码长度是\n\np1×L1 + p2×L2 + ... + p6700×L6700\n\n香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - ... - p6700 log p6700。\n\n我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=\n\n4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。\n\n聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。\n\n但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。\n\n另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。\n\n另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。\n","source":"_drafts/The-Beauty-Of-Maths.md","raw":"title: 数学之美\nauthor: Tim Zhang\ntags:\n  - 吴军\n  - 算法\n  - 数学\ncategories:\n  - Maths\n  - Algorithm\nmathjax: true\ndate: 2018-11-30 11:20:00\n---\n## 一、统计语言模型\n\n2006 年 4 月 3 日 上午 08:15:00\n\n从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。\n\n发表者: 吴军, Google 研究员\n\n前言\n\n也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。\n\n系列一： 统计语言模型 (Statistical Language Models)\n\nGoogle 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。\n\n其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。\n\n首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。\n\n给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。\n\n如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：\n\nP(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)\n\n其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：\n\nP(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…\n\n(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）\n\n接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。\n\n也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。\n\n现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。\n\n我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦\n\n## 二、谈谈中文分词 \n\n2006 年 4 月 10 日 上午 08:10:00\n\n发表者: 吴军， Google 研究员\n\n谈谈中文分词\n\n----- 统计语言模型在中文处理中的一个应用\n\n上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”\n\n分成一串词：\n\n中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。\n\n最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。\n\n用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。\n\n九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。\n\n利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：\n\n我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, ..., Ak, B1, B2, B3, ..., Bm C1, C2, C3, ..., Cn\n\n其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,..., Ak 是\n\n最好的分法，那么 （P 表示概率）：\n\nP (A1, A2, A3, ..., Ak） 〉 P (B1, B2, B3, ..., Bm), 并且 P (A1, A2, A3, ..., Ak） 〉 P(C1, C2, C3, ..., Cn)\n\n因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。\n\n当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。\n\n在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。\n\n需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。\n\n一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。\n\n也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。\n\n对中文分词有兴趣的读者，可以阅读以下文献：\n\n1. 梁南元\n\n书面汉语自动分词系统\n\nm/demo/LiangNanyuan-JCIP-1987.pdf\n\n2. 郭进\n\n统计语言模型和汉语音字转换的一些新结果\n\nm/demo/GuoJin-JCIP-1993.pdf\n\n3. 郭进\n\nCritical Tokenization and its Properties u/J/J97/J97-4004.pdf\n\n4. 孙茂松\n\nChinese word segmentation without using lexicon and hand-crafted training data\n\ng/m?coll=GUIDE&dl=GUIDE&id=980775\n\n## 三、隐含马尔可夫模型在语言处理中的应用\n\n2006 年 4 月 17 日 上午 08:01:00\n\n发表者：吴军，Google 研究员\n\n前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。\n\n自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 -- 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：\n\n其中 s1，s2，s3...表示信息源发出的信号。o1, o2, o3 ... 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 ...还原出发送的信 号 s1，s2，s3...。\n\n其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。\n\n那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,...的情况下，求使得条件概率 P (s1,s2,s3,...|o1,o2,o3....) 达到最大值的那个句子 s1,s2,s3,...\n\n当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成\n\nP(o1,o2,o3,...|s1,s2,s3....) * P(s1,s2,s3,...) 其中\n\nP(o1,o2,o3,...|s1,s2,s3....) 表示某句话 s1,s2,s3...被读成 o1,o2,o3,...\n\n的可能性, 而\n\nP(s1,s2,s3,...) 表示字串 s1,s2,s3,...本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3...这个数列的可能性乘 以 s1,s2,s3...本身可以一个句子的可能性，得出概率。\n\n（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：\n\n第一，s1,s2,s3,... 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；\n\n第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,...|s1,s2,s3....) = P(o1|s1) * P(o2|s2)*P(o3|s3)...。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,...。\n\n满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,...是无法直接观测到的。\n\n隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,...当成中文，把 o1,o2,o3,...当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,...当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。\n\nP (o1,o2,o3,...|s1,s2,s3....) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,...) 就是我们在系列一中提到的语言模型。\n\n在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。\n\n我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。\n\n## 四、数学之美系列四 — 怎样度量信息\n\n2006 年 4 月 26 日 上午 08:11:00\n\n发表者：吴军，Google 研究员\n\n前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？\n\n信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。\n\n一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。\n\n那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。\n\n当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）\n\n有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是\n\n = -（$p1 *log p1 + p2 *log p2  + ．．．+ p32 *log p32$)，\n\n其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：\n\n变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。\n\n有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。\n\n不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。\n\n在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。\n\n对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章\n\n《语信息熵和语言模型的复杂度》\n\n## 五、简单之美：布尔代数和搜索引擎的索引 \n\n2006 年 5 月 10 日 上午 09:10:00\n\n发表者: 吴军，Google 研究员\n\n建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。\n\n世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。\n\n布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。\n\n布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。\n\nAND | 1 0\n\n----------------------- 1 | 1 0 0 | 0 0\n\n这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。\n\nOR | 1 0\n\n----------------------- 1 | 1 1 0 | 1 0\n\n这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。\n\nNOT |\n\n-------------- 1 | 0 0 | 1\n\n这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。\n\n读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。\n\n现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 -- 真（TRUE,或 1），否则，给一个逻辑值 -- 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用\n\n- 不包含原子弹\n\n一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。\n\n早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。\n\n最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001...，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001...。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001...。表示第五篇，第十六篇文献满足要求。\n\n注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一\n\n组数字，是包含该关键词 的文献序号。\n\n对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。\n\n不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。\n\n## 六、图论和网络爬虫 (Web Crawlers)\n\n2006 年 5 月 15 日 上午 07:15:00\n\n发表者: 吴军，Google 研究员\n\n离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。\n\n我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。\n\n图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。\n\n图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都\n访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。\n\n现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为\"机器人\" （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(\"www wanderer\")。以后的网络爬虫越写越复杂，但原理是一样的。\n\n我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。\n\n现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。\n\n## 七、信息论在信息处理中的应用\n\n我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。\n\n先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。\n\n信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。\n\n信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。\n\n“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 \" 爱尔兰的小母牛 \" ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。\n\n当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。\n\n信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。\n\n对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 \" 信息论基础 \"(Elements of Information Theory) ：\n\nm/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。\n\n## 八、贾里尼克的故事和现代语言处理\n\n2006 年 6 月 8 日 上午 09:15:00\n\n发表者：Google 研究员，吴军\n\n读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。\n\n弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。\n\n贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向--利用信息论解决语言问题产生的重要影 响。\n\n贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：\"我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。\" 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。\n\n贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ\n\nｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。\n\n七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。\n\n贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。\n\n贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。\n\n贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。\n\n贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。\n\n除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。\n\n贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。\n\n注释一：\n贾格布森的通信模型 \n1上下文 \n2信息\n3发送着\n4接收者\n5信道\n6编码\n\n## 九、如何确定网页和查询的相关性 \n\n2006 年 6 月 27 日 上午 09:53:00\n\n发表者：吴军，Google 研究员\n\n[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]\n\n我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。\n\n我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”\n\n相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,...,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, ..., TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + ... + TFN。\n\n读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。\n\n细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：\n\n1. 一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。\n\n2. 应删除词的权重应该是零。\n\n我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)\n\n则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1*IDF1 + TF2*IDF2 ＋... + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。\n\nＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。\n\n现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。\n\n如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。\n\n## 十、有限状态机和地址识别 \n\n2006 年 7 月 5 日 上午 09:09:00\n\n发表者：吴军，Google 研究员\n\n地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。\n\n一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。\n\n每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。\n\n使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。\n\n上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）\n\n为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。\n\n在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&T 实验 室风光不再，这三个人都离开了 AT&T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。\n\n\n## 十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士 \n\n2006 年 7 月 10 日 上午 09:52:00\n\n发表者：Google 研究员，吴军\n\n枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。\n\n我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。\n\n从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。\n\n后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。\n\n当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。\n\n辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，\n\n你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。\n\n辛格在 AT&T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。\n\n\n## 十二、余弦定理和新闻的分类 \n\n2006 年 7 月 20 日 上午 10:12:00\n\n发表者：吴军，Google 研究员\n\n余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。\n\nGoogle 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。\n\n我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为\n\n单 词编号 汉字词\n\n----------------- - 1 阿 2 啊\n\n3 阿斗 4 阿姨 ...\n\n789 服 装 ....\n\n64000 做作\n\n在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为\n\n单 词编号 TF/IDF 值 ============== 1 0\n\n2 0.0 034 3 0\n\n4 0.0 0052 5 0 ...\n\n789 0 .034 ...\n\n\n64000 0.075\n\n如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。\n\n学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。\n\n余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 --\n\n如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于\n\n其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,...,x64000 和 y1,y2,...,y64000,\n\n那么它们夹角的余弦等 于，\n\n当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。\n\n我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。\n\n## 十三、信息指纹及其应用 \n\n2006 年 8 月 3 日 上午 11:17:00\n\n发表者：吴军，Google 研究员\n\n任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。\n\n我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接\n\nm/s?ie=gb2312&bs=%CA%FD%D1%A7%D6%AE%C3%C0&sr=&amp; z=&cl=3&f=8\n\n&wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&ct=0\n\n假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:\n\n893249432984398432980545454543\n\n这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。\n\n产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。\n\n信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，\n\n比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。\n\n互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。\n\n信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。\n\n## 十四、谈谈数学模型的重要性\n\n2006 年 8 月 9 日 上午 09:12:00\n\n发表者：吴军，Google 研究员\n\n注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。\n\n在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）\n\n但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。\n\n当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。\n\n地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。\n\n纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。\n\n完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。\n\n故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。\n\n讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：\n\n１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。） \n２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）\n３. 大量准确的数据对研发很重要。\n４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。\n\n在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。\n\n## 十五、繁与简 自然语言处理的几位精英 \n\n2006 年 8 月 23 日 下午 11:22:00\n\n发表者：吴军，Google 研究员\n\n我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。\n\n柯林斯：追求完美\n\n柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。\n\n柯 林斯毕业后，在 AT&T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。\n\n布莱尔：简单才美\n\n在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：\n\n第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；\n\n第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；\n\n第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。\n\n布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。\n\n由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）\n\n在接下来了系列里，我们还会介绍一个繁与简结合的例子。\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 -- 谈谈最大熵模型 （上）\n\n2006 年 10 月 8 日 上午 07:27:00\n\n发表者：Google 研究员，吴军\n\n我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (\"the maximum entropy principle\")。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。\n\n前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。\n\n让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是\"wang-xiao-bo\"， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。\n\n数学上最漂亮的办法是最大熵(\"maximum entropy\")模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。\n\n有 一次，我去 AT&T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。\n\n最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。\n\n回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 -- 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。\n\n我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。\n\n最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。\n\n\n## 十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\n\n2006 年 11 月 16 日 上午 06:50:00\n\n发表者：Google 研究员，吴军\n\n我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。\n\n最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：\n\n1. 假定第零次迭代的初始模型为等概率的均匀分布。\n\n2. 用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。\n\nGIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。\n\n八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。\n\n由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。\n\n但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。\n\n最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。\n\n讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司----文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。\n\n值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。\n\n## 十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\n\n2006 年 11 月 28 日 上午 03:18:00\n\nGoogle 研究员 吴军\n\n自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。\n\n搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。\n\n在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。\n\n几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此\" 痛改前非\"，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。\n\n抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：\n\n在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）\n\n搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。\n\n还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。\n\n## 十八、矩阵运算和文本处理中的分类问题 \n\n2007 年 1 月 1 日 下午 03:10:00\n\n发表者：Google 研究员，吴军\n\n我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。\n\n在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。\n\n分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。\n\n在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。\n\n在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。\n\n奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。\n\n三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。\n\n现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。\n\n\n## 十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\n\n我们在前面的系列中多次提到 马尔可夫链 (Markov\n\nChain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。\n\n我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。\n\n和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。\n\n使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。\n\n值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。\n\n贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。\n\n## 二十、自然语言处理的教父 马库斯 \n\n2007 年 4 月 13 日 下午 07:03:00\n\n发表者：Google 研究员，吴军\n\n我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。\n\n马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree\n\nBank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。\n\n马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。\n\n作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。\n\n过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。\n\n\n## 二十一、布隆过滤器（ Bloom Filter ） \n\n2007 年 7 月 3 日 上午 09:35:00\n\n发表者：Google（谷歌）研究员 吴军\n\n在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的\n\n具体办法是将每一个\n email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹\n\nm/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。\n\n今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。\n\n布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。\n\n假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, ...,F8） 产生八个信息指 纹（f1, f2, ..., f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, ...,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）\n\n现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, ..., F8）对这个地址产 生八个信息指纹 s1,s2,...,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,...,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。\n\n布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。\n\n布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。\n\n## 二十二、谈谈密码学的数学原理 \n\n2007 年 9 月 13 日 下午 09:00:00\n\n发表者：Google（谷歌）研究员 吴军\n\n前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）\n\n密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说\n\n这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。\n\n事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。\n\n公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。\n\n1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。\n\n2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。\n\n3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。\n\n现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。\n\n现在，我们用下面的公式对 X 加密，得到密码 Y。\n\n好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。\n\n这个过程大致可以概况如下：\n\n公开密钥的好处有：\n\n1.简单。\n\n2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。\n\n3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。\n\n最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的\n\n395058745832651445264197678006144819960207764603049364541393760515793 556265294\n\n506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =\n\n338849583746672139436839320467218152281583036860499304808492584055528 1177\n\n×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139\n\n现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。\n\n不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。\n\n## 二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\n\n2007 年 12 月 3 日 上午 10:05:00\n\n发表者：Google（谷歌）研究员 吴军\n\n今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。\n\n我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是\n\np1, p2, p3, ..., p6700 它们编码的长度是\n\nL1, L2, L3, ..., L6700 那么，平均编码长度是\n\np1×L1 + p2×L2 + ... + p6700×L6700\n\n香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - ... - p6700 log p6700。\n\n我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=\n\n4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。\n\n聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。\n\n但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。\n\n另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。\n\n另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。\n","slug":"The-Beauty-Of-Maths","published":0,"updated":"2018-11-30T04:38:27.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp7z0n5u002brd4lbc1mfvil","content":"<h2 id=\"一、统计语言模型\"><a href=\"#一、统计语言模型\" class=\"headerlink\" title=\"一、统计语言模型\"></a>一、统计语言模型</h2><p>2006 年 4 月 3 日 上午 08:15:00</p>\n<p>从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。</p>\n<p>发表者: 吴军, Google 研究员</p>\n<p>前言</p>\n<p>也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。</p>\n<p>系列一： 统计语言模型 (Statistical Language Models)</p>\n<p>Google 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。</p>\n<p>其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。</p>\n<p>首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。</p>\n<p>给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。</p>\n<p>如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)</p>\n<p>其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…</p>\n<p>(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）</p>\n<p>接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。</p>\n<p>也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。</p>\n<p>现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。</p>\n<p>我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦</p>\n<h2 id=\"二、谈谈中文分词\"><a href=\"#二、谈谈中文分词\" class=\"headerlink\" title=\"二、谈谈中文分词\"></a>二、谈谈中文分词</h2><p>2006 年 4 月 10 日 上午 08:10:00</p>\n<p>发表者: 吴军， Google 研究员</p>\n<p>谈谈中文分词</p>\n<p>—– 统计语言模型在中文处理中的一个应用</p>\n<p>上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”</p>\n<p>分成一串词：</p>\n<p>中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。</p>\n<p>最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。</p>\n<p>用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。</p>\n<p>九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。</p>\n<p>利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：</p>\n<p>我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, …, Ak, B1, B2, B3, …, Bm C1, C2, C3, …, Cn</p>\n<p>其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,…, Ak 是</p>\n<p>最好的分法，那么 （P 表示概率）：</p>\n<p>P (A1, A2, A3, …, Ak） 〉 P (B1, B2, B3, …, Bm), 并且 P (A1, A2, A3, …, Ak） 〉 P(C1, C2, C3, …, Cn)</p>\n<p>因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。</p>\n<p>当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。</p>\n<p>在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。</p>\n<p>需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。</p>\n<p>一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。</p>\n<p>也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。</p>\n<p>对中文分词有兴趣的读者，可以阅读以下文献：</p>\n<ol>\n<li>梁南元</li>\n</ol>\n<p>书面汉语自动分词系统</p>\n<p>m/demo/LiangNanyuan-JCIP-1987.pdf</p>\n<ol start=\"2\">\n<li>郭进</li>\n</ol>\n<p>统计语言模型和汉语音字转换的一些新结果</p>\n<p>m/demo/GuoJin-JCIP-1993.pdf</p>\n<ol start=\"3\">\n<li>郭进</li>\n</ol>\n<p>Critical Tokenization and its Properties u/J/J97/J97-4004.pdf</p>\n<ol start=\"4\">\n<li>孙茂松</li>\n</ol>\n<p>Chinese word segmentation without using lexicon and hand-crafted training data</p>\n<p>g/m?coll=GUIDE&amp;dl=GUIDE&amp;id=980775</p>\n<h2 id=\"三、隐含马尔可夫模型在语言处理中的应用\"><a href=\"#三、隐含马尔可夫模型在语言处理中的应用\" class=\"headerlink\" title=\"三、隐含马尔可夫模型在语言处理中的应用\"></a>三、隐含马尔可夫模型在语言处理中的应用</h2><p>2006 年 4 月 17 日 上午 08:01:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。</p>\n<p>自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 – 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：</p>\n<p>其中 s1，s2，s3…表示信息源发出的信号。o1, o2, o3 … 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 …还原出发送的信 号 s1，s2，s3…。</p>\n<p>其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。</p>\n<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>\n<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…) 其中</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…</p>\n<p>的可能性, 而</p>\n<p>P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘 以 s1,s2,s3…本身可以一个句子的可能性，得出概率。</p>\n<p>（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：</p>\n<p>第一，s1,s2,s3,… 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；</p>\n<p>第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,…|s1,s2,s3….) = P(o1|s1) <em> P(o2|s2)</em>P(o3|s3)…。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,…。</p>\n<p>满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,…是无法直接观测到的。</p>\n<p>隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,…当成中文，把 o1,o2,o3,…当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,…当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。</p>\n<p>P (o1,o2,o3,…|s1,s2,s3….) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,…) 就是我们在系列一中提到的语言模型。</p>\n<p>在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。</p>\n<p>我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。</p>\n<h2 id=\"四、数学之美系列四-—-怎样度量信息\"><a href=\"#四、数学之美系列四-—-怎样度量信息\" class=\"headerlink\" title=\"四、数学之美系列四 — 怎样度量信息\"></a>四、数学之美系列四 — 怎样度量信息</h2><p>2006 年 4 月 26 日 上午 08:11:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？</p>\n<p>信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。</p>\n<p>一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。</p>\n<p>那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。</p>\n<p>当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）</p>\n<p>有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是</p>\n<p> = -（$p1 <em>log p1 + p2 </em>log p2  + ．．．+ p32 *log p32$)，</p>\n<p>其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：</p>\n<p>变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。</p>\n<p>有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。</p>\n<p>不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。</p>\n<p>在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。</p>\n<p>对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章</p>\n<p>《语信息熵和语言模型的复杂度》</p>\n<h2 id=\"五、简单之美：布尔代数和搜索引擎的索引\"><a href=\"#五、简单之美：布尔代数和搜索引擎的索引\" class=\"headerlink\" title=\"五、简单之美：布尔代数和搜索引擎的索引\"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>2006 年 5 月 10 日 上午 09:10:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。</p>\n<p>世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。</p>\n<p>布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。</p>\n<p>布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。</p>\n<p>AND | 1 0</p>\n<p>———————– 1 | 1 0 0 | 0 0</p>\n<p>这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。</p>\n<p>OR | 1 0</p>\n<p>———————– 1 | 1 1 0 | 1 0</p>\n<p>这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。</p>\n<p>NOT |</p>\n<p>————– 1 | 0 0 | 1</p>\n<p>这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。</p>\n<p>读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。</p>\n<p>现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 – 真（TRUE,或 1），否则，给一个逻辑值 – 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用</p>\n<ul>\n<li>不包含原子弹</li>\n</ul>\n<p>一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。</p>\n<p>早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。</p>\n<p>最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001…，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001…。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001…。表示第五篇，第十六篇文献满足要求。</p>\n<p>注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一</p>\n<p>组数字，是包含该关键词 的文献序号。</p>\n<p>对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。</p>\n<p>不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。</p>\n<h2 id=\"六、图论和网络爬虫-Web-Crawlers\"><a href=\"#六、图论和网络爬虫-Web-Crawlers\" class=\"headerlink\" title=\"六、图论和网络爬虫 (Web Crawlers)\"></a>六、图论和网络爬虫 (Web Crawlers)</h2><p>2006 年 5 月 15 日 上午 07:15:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。</p>\n<p>我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。</p>\n<p>图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。</p>\n<p>图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都<br>访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。</p>\n<p>现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为”机器人” （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(“www wanderer”)。以后的网络爬虫越写越复杂，但原理是一样的。</p>\n<p>我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。</p>\n<p>现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。</p>\n<h2 id=\"七、信息论在信息处理中的应用\"><a href=\"#七、信息论在信息处理中的应用\" class=\"headerlink\" title=\"七、信息论在信息处理中的应用\"></a>七、信息论在信息处理中的应用</h2><p>我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。</p>\n<p>先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。</p>\n<p>信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。</p>\n<p>信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。</p>\n<p>“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 “ 爱尔兰的小母牛 “ ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。</p>\n<p>当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。</p>\n<p>信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。</p>\n<p>对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 “ 信息论基础 “(Elements of Information Theory) ：</p>\n<p>m/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。</p>\n<h2 id=\"八、贾里尼克的故事和现代语言处理\"><a href=\"#八、贾里尼克的故事和现代语言处理\" class=\"headerlink\" title=\"八、贾里尼克的故事和现代语言处理\"></a>八、贾里尼克的故事和现代语言处理</h2><p>2006 年 6 月 8 日 上午 09:15:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。</p>\n<p>弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。</p>\n<p>贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向–利用信息论解决语言问题产生的重要影 响。</p>\n<p>贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：”我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。” 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。</p>\n<p>贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ</p>\n<p>ｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。</p>\n<p>七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。</p>\n<p>贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。</p>\n<p>贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。</p>\n<p>贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&amp;T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。</p>\n<p>贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。</p>\n<p>除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。</p>\n<p>贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。</p>\n<p>注释一：<br>贾格布森的通信模型<br>1上下文<br>2信息<br>3发送着<br>4接收者<br>5信道<br>6编码</p>\n<h2 id=\"九、如何确定网页和查询的相关性\"><a href=\"#九、如何确定网页和查询的相关性\" class=\"headerlink\" title=\"九、如何确定网页和查询的相关性\"></a>九、如何确定网页和查询的相关性</h2><p>2006 年 6 月 27 日 上午 09:53:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]</p>\n<p>我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。</p>\n<p>我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”</p>\n<p>相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,…,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, …, TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + … + TFN。</p>\n<p>读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。</p>\n<p>细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p>\n<ol>\n<li><p>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</p>\n</li>\n<li><p>应删除词的权重应该是零。</p>\n</li>\n</ol>\n<p>我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)</p>\n<p>则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1<em>IDF1 + TF2</em>IDF2 ＋… + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。</p>\n<p>ＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。</p>\n<p>现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。</p>\n<p>如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。</p>\n<h2 id=\"十、有限状态机和地址识别\"><a href=\"#十、有限状态机和地址识别\" class=\"headerlink\" title=\"十、有限状态机和地址识别\"></a>十、有限状态机和地址识别</h2><p>2006 年 7 月 5 日 上午 09:09:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。</p>\n<p>一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。</p>\n<p>每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。</p>\n<p>使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。</p>\n<p>上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）</p>\n<p>为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。</p>\n<p>在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&amp;T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&amp;T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&amp;T 实验 室风光不再，这三个人都离开了 AT&amp;T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&amp;T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&amp;T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。</p>\n<h2 id=\"十一、-Google-阿卡-47-的制造者阿米特-辛格博士\"><a href=\"#十一、-Google-阿卡-47-的制造者阿米特-辛格博士\" class=\"headerlink\" title=\"十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士\"></a>十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士</h2><p>2006 年 7 月 10 日 上午 09:52:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。</p>\n<p>我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。</p>\n<p>从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。</p>\n<p>后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。</p>\n<p>当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&amp;T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&amp;T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。</p>\n<p>辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，</p>\n<p>你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。</p>\n<p>辛格在 AT&amp;T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。</p>\n<h2 id=\"十二、余弦定理和新闻的分类\"><a href=\"#十二、余弦定理和新闻的分类\" class=\"headerlink\" title=\"十二、余弦定理和新闻的分类\"></a>十二、余弦定理和新闻的分类</h2><p>2006 年 7 月 20 日 上午 10:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。</p>\n<p>Google 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。</p>\n<p>我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为</p>\n<p>单 词编号 汉字词</p>\n<p>—————– - 1 阿 2 啊</p>\n<p>3 阿斗 4 阿姨 …</p>\n<p>789 服 装 ….</p>\n<p>64000 做作</p>\n<p>在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为</p>\n<p>单 词编号 TF/IDF 值 ============== 1 0</p>\n<p>2 0.0 034 3 0</p>\n<p>4 0.0 0052 5 0 …</p>\n<p>789 0 .034 …</p>\n<p>64000 0.075</p>\n<p>如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。</p>\n<p>学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。</p>\n<p>余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 –</p>\n<p>如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于</p>\n<p>其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,…,x64000 和 y1,y2,…,y64000,</p>\n<p>那么它们夹角的余弦等 于，</p>\n<p>当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。</p>\n<p>我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。</p>\n<h2 id=\"十三、信息指纹及其应用\"><a href=\"#十三、信息指纹及其应用\" class=\"headerlink\" title=\"十三、信息指纹及其应用\"></a>十三、信息指纹及其应用</h2><p>2006 年 8 月 3 日 上午 11:17:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。</p>\n<p>我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接</p>\n<p>m/s?ie=gb2312&amp;bs=%CA%FD%D1%A7%D6%AE%C3%C0&amp;sr=&amp; z=&amp;cl=3&amp;f=8</p>\n<p>&amp;wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&amp;ct=0</p>\n<p>假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:</p>\n<p>893249432984398432980545454543</p>\n<p>这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。</p>\n<p>产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。</p>\n<p>信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，</p>\n<p>比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。</p>\n<p>互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。</p>\n<p>信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。</p>\n<h2 id=\"十四、谈谈数学模型的重要性\"><a href=\"#十四、谈谈数学模型的重要性\" class=\"headerlink\" title=\"十四、谈谈数学模型的重要性\"></a>十四、谈谈数学模型的重要性</h2><p>2006 年 8 月 9 日 上午 09:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。</p>\n<p>在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）</p>\n<p>但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。</p>\n<p>当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。</p>\n<p>地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。</p>\n<p>纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。</p>\n<p>完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。</p>\n<p>故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。</p>\n<p>讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：</p>\n<p>１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。）<br>２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）<br>３. 大量准确的数据对研发很重要。<br>４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</p>\n<p>在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。</p>\n<h2 id=\"十五、繁与简-自然语言处理的几位精英\"><a href=\"#十五、繁与简-自然语言处理的几位精英\" class=\"headerlink\" title=\"十五、繁与简 自然语言处理的几位精英\"></a>十五、繁与简 自然语言处理的几位精英</h2><p>2006 年 8 月 23 日 下午 11:22:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。</p>\n<p>柯林斯：追求完美</p>\n<p>柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。</p>\n<p>柯 林斯毕业后，在 AT&amp;T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&amp;T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。</p>\n<p>布莱尔：简单才美</p>\n<p>在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：</p>\n<p>第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；</p>\n<p>第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；</p>\n<p>第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。</p>\n<p>布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。</p>\n<p>由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）</p>\n<p>在接下来了系列里，我们还会介绍一个繁与简结合的例子。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）</h2><p>2006 年 10 月 8 日 上午 07:27:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (“the maximum entropy principle”)。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。</p>\n<p>前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。</p>\n<p>让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是”wang-xiao-bo”， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。</p>\n<p>数学上最漂亮的办法是最大熵(“maximum entropy”)模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。</p>\n<p>有 一次，我去 AT&amp;T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。</p>\n<p>最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。</p>\n<p>回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 – 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。</p>\n<p>我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。</p>\n<p>最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）</h2><p>2006 年 11 月 16 日 上午 06:50:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。</p>\n<p>最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：</p>\n<ol>\n<li><p>假定第零次迭代的初始模型为等概率的均匀分布。</p>\n</li>\n<li><p>用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。</p>\n</li>\n</ol>\n<p>GIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。</p>\n<p>八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。</p>\n<p>由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。</p>\n<p>但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。</p>\n<p>最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。</p>\n<p>讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司—-文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。</p>\n<p>值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。</p>\n<h2 id=\"十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\"><a href=\"#十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\" class=\"headerlink\" title=\"十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\"></a>十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)</h2><p>2006 年 11 月 28 日 上午 03:18:00</p>\n<p>Google 研究员 吴军</p>\n<p>自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。</p>\n<p>搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。</p>\n<p>在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。</p>\n<p>几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此” 痛改前非”，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。</p>\n<p>抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：</p>\n<p>在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）</p>\n<p>搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。</p>\n<p>还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。</p>\n<h2 id=\"十八、矩阵运算和文本处理中的分类问题\"><a href=\"#十八、矩阵运算和文本处理中的分类问题\" class=\"headerlink\" title=\"十八、矩阵运算和文本处理中的分类问题\"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>2007 年 1 月 1 日 下午 03:10:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。</p>\n<p>在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。</p>\n<p>分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。</p>\n<p>在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。</p>\n<p>在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。</p>\n<p>奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。</p>\n<p>三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。</p>\n<p>现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。</p>\n<h2 id=\"十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\"><a href=\"#十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\" class=\"headerlink\" title=\"十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\"></a>十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)</h2><p>我们在前面的系列中多次提到 马尔可夫链 (Markov</p>\n<p>Chain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。</p>\n<p>我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。</p>\n<p>和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。</p>\n<p>使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。</p>\n<p>值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。</p>\n<p>贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。</p>\n<h2 id=\"二十、自然语言处理的教父-马库斯\"><a href=\"#二十、自然语言处理的教父-马库斯\" class=\"headerlink\" title=\"二十、自然语言处理的教父 马库斯\"></a>二十、自然语言处理的教父 马库斯</h2><p>2007 年 4 月 13 日 下午 07:03:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。</p>\n<p>马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&amp;T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree</p>\n<p>Bank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。</p>\n<p>马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。</p>\n<p>作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。</p>\n<p>过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。</p>\n<h2 id=\"二十一、布隆过滤器（-Bloom-Filter-）\"><a href=\"#二十一、布隆过滤器（-Bloom-Filter-）\" class=\"headerlink\" title=\"二十一、布隆过滤器（ Bloom Filter ）\"></a>二十一、布隆过滤器（ Bloom Filter ）</h2><p>2007 年 7 月 3 日 上午 09:35:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的</p>\n<p>具体办法是将每一个<br> email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹</p>\n<p>m/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。</p>\n<p>今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p>\n<p>布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。</p>\n<p>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指 纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）</p>\n<p>现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, …, F8）对这个地址产 生八个信息指纹 s1,s2,…,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,…,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。</p>\n<p>布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。</p>\n<p>布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。</p>\n<h2 id=\"二十二、谈谈密码学的数学原理\"><a href=\"#二十二、谈谈密码学的数学原理\" class=\"headerlink\" title=\"二十二、谈谈密码学的数学原理\"></a>二十二、谈谈密码学的数学原理</h2><p>2007 年 9 月 13 日 下午 09:00:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）</p>\n<p>密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说</p>\n<p>这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。</p>\n<p>事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。</p>\n<p>公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。</p>\n<p>1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。</p>\n<p>2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。</p>\n<p>3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。</p>\n<p>现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。</p>\n<p>现在，我们用下面的公式对 X 加密，得到密码 Y。</p>\n<p>好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。</p>\n<p>这个过程大致可以概况如下：</p>\n<p>公开密钥的好处有：</p>\n<p>1.简单。</p>\n<p>2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。</p>\n<p>3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。</p>\n<p>最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的</p>\n<p>395058745832651445264197678006144819960207764603049364541393760515793 556265294</p>\n<p>506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =</p>\n<p>338849583746672139436839320467218152281583036860499304808492584055528 1177</p>\n<p>×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139</p>\n<p>现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。</p>\n<p>不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。</p>\n<h2 id=\"二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\"><a href=\"#二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\" class=\"headerlink\" title=\"二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\"></a>二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律</h2><p>2007 年 12 月 3 日 上午 10:05:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。</p>\n<p>我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是</p>\n<p>p1, p2, p3, …, p6700 它们编码的长度是</p>\n<p>L1, L2, L3, …, L6700 那么，平均编码长度是</p>\n<p>p1×L1 + p2×L2 + … + p6700×L6700</p>\n<p>香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - … - p6700 log p6700。</p>\n<p>我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=</p>\n<p>4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。</p>\n<p>聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。</p>\n<p>但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。</p>\n<p>另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。</p>\n<p>另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。</p>\n","site":{"data":{"recommended_posts":{"https://cyouraku.github.io/2016/11/28/How-To-Next/":[{"title":"How To Hexo","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Hexo/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/":[{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"好用的中文分词工具AnsjSeq","permalink":"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/"},{"title":"我要系列｜学习循环的必要基础","permalink":"http://www.davidfnck.com/notes/skill_learning_basic_ability_language_english_japanese.html/"}],"https://cyouraku.github.io/2015/12/03/How-To-GitHub/":[],"https://cyouraku.github.io/2016/11/28/How-To-Hexo/":[{"title":"How To Next","permalink":"https://cyouraku.github.io/2016/11/28/How-To-Next/"},{"title":"Hexo进行简单的SEO优化","permalink":"http://elegantme.cn/Hexo进行简单的SEO优化/"}],"https://cyouraku.github.io/2018/11/30/An-Easy-To-Use-Analyzer-Tool-AnjSeq/":[{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"跟着日语分词器Kuromoji学习日语","permalink":"https://cyouraku.github.io/2018/12/03/Japanese-Analyzer-Tool-Kuromoji/"},{"title":"为 lunr.js 添加中文支持","permalink":"http://linfuyan.com/add-chinese-support-to-lunrjs/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/":[{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"数学之美(1-12)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}],"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-01/":[{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"数学之美(13-24)","permalink":"https://cyouraku.github.io/2017/11/30/The-Beauty-Of-Maths-02/"},{"title":"区块链学习备忘录之共识算法","permalink":"http://www.davidfnck.com/blockchain/consensus-algorithm-notebook.html/"}]}}},"excerpt":"","more":"<h2 id=\"一、统计语言模型\"><a href=\"#一、统计语言模型\" class=\"headerlink\" title=\"一、统计语言模型\"></a>一、统计语言模型</h2><p>2006 年 4 月 3 日 上午 08:15:00</p>\n<p>从本周开始，我们将定期刊登 Google 科学家吴军写的《数学之美》系列文章， 介绍数学在信息检索和自然语言处理中的主导作用和奇妙应用。</p>\n<p>发表者: 吴军, Google 研究员</p>\n<p>前言</p>\n<p>也许大家不相信，数学是解决信息检索和自然语言处理的最好工具。它能非常 清晰地描述这些领域的实际问题并且给出漂亮的解决办法。每当人们应用数学工 具解决一 个语言问题时，总会感叹数学之美。我们希望利用 Google 中文黑板 报这块园地，介绍一些数学工具，以及我们是如何利用这些工具来开发 Google 产品的。</p>\n<p>系列一： 统计语言模型 (Statistical Language Models)</p>\n<p>Google 的使命是整合全球的信息，所以我们一直致力于研究如何让机器对信息、 语言做最好的理解和处理。长期以来，人类一直梦想着能让机器代替人来翻译语 言、识别语 音、认识文字（不论是印刷体或手写体）和进行海量文献的自动检 索，这就需要让机器理解语言。但是人类的语言可以说是信息里最复杂最动态的 一部分。为了解决 这个问题，人们容易想到的办法就是让机器模拟人类进行学 习 - 学习人类的语法、分析语句等等。尤其是在乔姆斯基（Noam Chomsky 有史 以来最伟大的语言学家）提出 “形式语言” 以后，人们更坚定了利用语法规则 的办法进行文字处理的信念。遗憾的是，几十年过去了，在计算机处理语言领域， 基于这个语法规则的方法几乎毫无突破。</p>\n<p>其实早在几十年前，数学家兼信息论的祖师爷 香农 (Claude Shannon)就提出了 用数学的办法处理自然语言的想法。遗憾的是当时的计算机条件根本无法满足大 量信息处理的需要，所以他这个想法当时并没有被人们重视。七十年代初，有了 大规模集成电路的快速计算机后，香农的梦想才得以实现。</p>\n<p>首先成功利用数学方法解决自然语言处理问题的是语音和语言处理大师贾里尼 克 ( Fred Jelinek ) 。 当 时 贾 里 尼 克 在 IBM 公 司 做 学 术 休 假 (Sabbatical Leave)，领导了一批杰出的科学家利用大型计算机来处理人类语言问题。统计语 言模型就是在那个时候提出的。</p>\n<p>给大家举个例子：在很多涉及到自然语言处理的领域，如机器翻译、语音识别、 印刷体或手写体识别、拼写纠错、汉字输入和文献查询中，我们都需要知道一个 文字序列是否能构成一个大家能理解的句子，显示给使用者。对这个问题，我们 可以用一个简单的统计模型来解决这个问题。</p>\n<p>如 果 S 表示一连串特定顺序排列的词 w1， w2，…， wn ，换句话说，S 可以 表示某一个由一连串特定顺序排练的词而组成的一个有意义的句子。现在，机器 对语言的识别从某种角度来说，就是想知道S在文本中出现的可能性，也就是数 学上所说的S 的概率用 P(S) 来表示。利用条件概率的公式，S 这个序列出现的 概率等于每一个词出现的概率相乘，于是P(S) 可展开为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3| w1 w2)…P(wn|w1 w2…wn-1)</p>\n<p>其 中 P (w1) 表示第一个词w1 出现的概率；P (w2|w1) 是在已知第一个词的前 提下，第二个词出现的概率；以次类推。不难看出，到了词wn，它的出现概率取 决于它前面所有词。从计算上来看，各种可能性太多，无法 实现。因此我们假 定任意一个词wi的出现概率只同它前面的词 wi-1 有关(即马尔可夫假设），于 是问题就变得很简单了。现在，S 出现的概率就变为：</p>\n<p>P(S) = P(w1)P(w2|w1)P(w3|w2)…P(wi|wi-1)…</p>\n<p>(当然，也可以假设一个词又前面N-1 个词决定，模型稍微复杂些。）</p>\n<p>接下来的问题就是如何估计 P (wi|wi-1)。现在有了大量机读文本后，这个问 题变得很简单，只要数一数这对词（wi-1,wi) 在统计的文本中出现了多少次， 以及 wi-1 本身在同样的文本中前后相邻出现了多少次，然后用两个数一除就可 以了,P(wi|wi-1) = P(wi-1,wi)/ P (wi-1)。</p>\n<p>也许很多人不相信用这么简单的数学模型能解决复杂的语音识别、机器翻译等问 题。其实不光是常人，就连很多语言学家都曾质疑过这种方法的有效性，但事实 证明，统计语言模型比任何已知的借助某种规则的解决方法都有效。比如在 Google 的 中英文自动翻译 中，用的最重要的就是这个统计语言模型。去年美国 标准局(NIST) 对所有的机器翻译系统进行了评测，Google 的系统是不仅是全世 界最好的，而且高出所有基于规则的系统很多。</p>\n<p>现 在，读者也许已经能感受到数学的美妙之处了，它把一些复杂的问题变得如 此的简单。当然，真正实现一个好的统计语言模型还有许多细节问题需要解决。 贾里尼克 和他的同事的贡献在于提出了统计语言模型，而且很漂亮地解决了所 有的细节问题。十几年后，李开复用统计语言模型把 997 词语音识别的问题简 化成了一个 20 词的识别问题，实现了有史以来第一次大词汇量非特定人连续语 音的识别。</p>\n<p>我是一名科学研究人员 ，我在工作中经常惊叹于数学语言应用于解决实际问题 上时的神奇。我也希望把这种神奇讲解给大家听。当然，归根结底，不管什莫样 的科学方法、无论多莫奇妙的解决手段都是为人服务的。我希望 Google 多努力 一分，用户就多一分搜索的喜悦</p>\n<h2 id=\"二、谈谈中文分词\"><a href=\"#二、谈谈中文分词\" class=\"headerlink\" title=\"二、谈谈中文分词\"></a>二、谈谈中文分词</h2><p>2006 年 4 月 10 日 上午 08:10:00</p>\n<p>发表者: 吴军， Google 研究员</p>\n<p>谈谈中文分词</p>\n<p>—– 统计语言模型在中文处理中的一个应用</p>\n<p>上回我们谈到 利用统计语言模型进行语言处理 ，由于模型是建立在词的基础上 的，对于中日韩等语言，首先需要进行分词。例如把句子 “中国航天官员应邀 到美国与太空总署官员开会。”</p>\n<p>分成一串词：</p>\n<p>中国 / 航天 / 官员 / 应邀 / 到 / 美国 / 与 / 太空 / 总署 / 官员 / 开 会。</p>\n<p>最容易想到的，也是最简单的分词办法就是查字典。这种方法最早是由北京航天 航空大学的梁南元教授提出的。</p>\n<p>用 “查字典” 法，其实就是我们把一个句子从左向右扫描一遍，遇到字典里有 的词就标识出来，遇到复合词（比如 “上海大学”）就找最长的词匹配，遇到 不认识的字串就分割成单字词，于是简单的分词就完成了。这种简单的分词方法 完全能处理上面例子中的句子。八十年代， 哈工大的王晓龙博士 把 它理论化， 发展成最少词数的分词理论，即一句话应该分成数量最少的词串。这种方法一个 明显的不足是当遇到有二义性 （有双重理解意思）的分割时就无能为力了。比 如，对短语 “发展中国家” 正确的分割是“发展-中-国家”，而从左向右查字 典的办法会将它分割成“发展-中国-家”，显然是错了。另外，并非所有的最长 匹配都一定是正确的。比如 “上海大学城书店”的正确分词应该是 “上海-大 学城-书店，” 而不是 “上海大学-城-书店”。</p>\n<p>九十年代以前，海内外不少学者试图用一些文法规则来解决分词的二义性问题， 都不是很成功。90 年前后，清华大学的郭进博士用统计语言模型成功解决分词 二义性问题，将汉语分词的错误率降低了一个数量级。</p>\n<p>利用统计语言模型分词的方法，可以用几个数学公式简单概括如下：</p>\n<p>我们假定一个句子S可以有几种分词方法，为了简单起见我们假定有以下三种： A1, A2, A3, …, Ak, B1, B2, B3, …, Bm C1, C2, C3, …, Cn</p>\n<p>其中，A1, A2, B1, B2, C1, C2 等等都是汉语的词。那么最好的一种分词方法 应该保证分完词后这个句子出现的概率最大。也就是说如果 A1,A2,…, Ak 是</p>\n<p>最好的分法，那么 （P 表示概率）：</p>\n<p>P (A1, A2, A3, …, Ak） 〉 P (B1, B2, B3, …, Bm), 并且 P (A1, A2, A3, …, Ak） 〉 P(C1, C2, C3, …, Cn)</p>\n<p>因此，只要我们利用上回提到的统计语言模型计算出每种分词后句子出现的概 率，并找出其中概率最大的，我们就能够找到最好的分词方法。</p>\n<p>当然，这里面有一个实现的技巧。如果我们穷举所有可能的分词方法并计算出每 种可能性下句子的概率，那么计算量是相当大的。因此，我们可以把它看成是一 个 动态规划 （Dynamic Programming) 的问题，并利用 “维特比”（ Viterbi ） 算 法快速地找到最佳分词。</p>\n<p>在清华大学的郭进博士以后，海内外不少学者利用统计的方法，进一步完善中文 分词。其中值得一提的是清华大学孙茂松教授和香港科技大学吴德凯教授的工 作。</p>\n<p>需 要指出的是，语言学家对词语的定义不完全相同。比如说 “北京大学”，有 人认为是一个词，而有人认为该分成两个词。一个折中的解决办法是在分词的同 时，找到复合词的嵌套结构。在上面的例子中，如果一句话包含 “北京大学” 四个字，那么先把它当成一个四字词，然后再进一步找出细分词 “北京” 和 “大学”。这种方法是最早是郭进在 “Computational Linguistics” （《计 算机语言学》）杂志上发表的，以后不少系统采用这种方法。</p>\n<p>一般来讲，根 据不同应用，汉语分词的颗粒度大小应该不同。比如，在机器翻 译中，颗粒度应该大一些，“北京大学”就不能被分成两个词。而在语音识别中， “北京大学”一般 是被分成两个词。因此，不同的应用，应该有不同的分词系 统。Google 的葛显平博士和朱安博士，专门为搜索设计和实现了自己的分词系 统。</p>\n<p>也 许你想不到，中文分词的方法也被应用到英语处理，主要是手写体识别中。 因为在识别手写体时，单词之间的空格就不很清楚了。中文分词方法可以帮助判 别英语单 词的边界。其实，语言处理的许多数学方法通用的和具体的语言无关。 在 Google 内，我们在设计语言处理的算法时，都会考虑它是否能很容易地适用 于各种自然语言。这样，我们才能有效地支持上百种语言的搜索。</p>\n<p>对中文分词有兴趣的读者，可以阅读以下文献：</p>\n<ol>\n<li>梁南元</li>\n</ol>\n<p>书面汉语自动分词系统</p>\n<p>m/demo/LiangNanyuan-JCIP-1987.pdf</p>\n<ol start=\"2\">\n<li>郭进</li>\n</ol>\n<p>统计语言模型和汉语音字转换的一些新结果</p>\n<p>m/demo/GuoJin-JCIP-1993.pdf</p>\n<ol start=\"3\">\n<li>郭进</li>\n</ol>\n<p>Critical Tokenization and its Properties u/J/J97/J97-4004.pdf</p>\n<ol start=\"4\">\n<li>孙茂松</li>\n</ol>\n<p>Chinese word segmentation without using lexicon and hand-crafted training data</p>\n<p>g/m?coll=GUIDE&amp;dl=GUIDE&amp;id=980775</p>\n<h2 id=\"三、隐含马尔可夫模型在语言处理中的应用\"><a href=\"#三、隐含马尔可夫模型在语言处理中的应用\" class=\"headerlink\" title=\"三、隐含马尔可夫模型在语言处理中的应用\"></a>三、隐含马尔可夫模型在语言处理中的应用</h2><p>2006 年 4 月 17 日 上午 08:01:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言：隐含马尔可夫模型是一个数学模型，到目前为之，它一直被认为是实现快 速精确的语音识别系统的最成功的方法。复杂的语音识别问题通过隐含马尔可夫 模型能非常简单地被表述、解决，让我不由由衷地感叹数学模型之妙。</p>\n<p>自 然语言是人类交流信息的工具。很多自然语言处理问题都可以等同于通信系 统中的解码问题 – 一个人根据接收到的信息，去猜测发话人要表达的意思。这 其实就象通信中，我们根据接收端收到的信号去分析、理解、还原发送端传送过 来的信息。以下该图就表 示了一个典型的通信系统：</p>\n<p>其中 s1，s2，s3…表示信息源发出的信号。o1, o2, o3 … 是接受器接收到 的信号。通信中的解码就是根据接收到的信号 o1, o2, o3 …还原出发送的信 号 s1，s2，s3…。</p>\n<p>其 实我们平时在说话时，脑子就是一个信息源。我们的喉咙（声带），空气， 就是如电线和光缆般的信道。听众耳朵的就是接收端，而听到的声音就是传送过 来的信 号。根据声学信号来推测说话者的意思，就是语音识别。这样说来，如 果接收端是一台计算机而不是人的话，那么计算机要做的就是语音的自动识别。 同样，在计算 机中，如果我们要根据接收到的英语信息，推测说话者的汉语意 思，就是机器翻译； 如果我们要根据带有拼写错误的语句推测说话者想表达的 正确意思，那就是自动纠错。</p>\n<p>那么怎么根据接收到的信息来推测说话者想表达的意思呢？我们可以利用叫做 “ 隐含马尔可夫模型 ” （Hidden Markov Model）来解决这些问题。以语音识别 为例，当我们观测到语音信号 o1,o2,o3 时，我们要根据这组信号推测出发送的 句子 s1,s2,s3。显然，我们应该在所有可能的句子中找最有可能性的一个。用 数学语言来描述，就是在已知 o1,o2,o3,…的情况下，求使得条件概率 P (s1,s2,s3,…|o1,o2,o3….) 达到最大值的那个句子 s1,s2,s3,…</p>\n<p>当然，上面的概率不容易直接求出，于是我们可以间接地计算它。利用贝叶斯公 式并且省掉一个常数项，可以把上述公式等价变换成</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) * P(s1,s2,s3,…) 其中</p>\n<p>P(o1,o2,o3,…|s1,s2,s3….) 表示某句话 s1,s2,s3…被读成 o1,o2,o3,…</p>\n<p>的可能性, 而</p>\n<p>P(s1,s2,s3,…) 表示字串 s1,s2,s3,…本身能够成为一个合乎情理的句子的 可能性，所以这个公式的意义是用发送信号为 s1,s2,s3…这个数列的可能性乘 以 s1,s2,s3…本身可以一个句子的可能性，得出概率。</p>\n<p>（读者读到这里也许会问，你现在是不是把问题变得更复杂了，因为公式越写越 长了。别着急，我们现在就来简化这个问题。）我们在这里做两个假设：</p>\n<p>第一，s1,s2,s3,… 是一个马尔可夫链，也就是说，si 只由 si-1 决定 (详见 系列一 )；</p>\n<p>第二， 第 i 时刻的接收信号 oi 只由发送信号 si 决定（又称为独立输出假设, 即 P(o1,o2,o3,…|s1,s2,s3….) = P(o1|s1) <em> P(o2|s2)</em>P(o3|s3)…。 那么我们就可以很容易利用算法 Viterbi 找出上面式子的最大值，进而找出要 识别的句子 s1,s2,s3,…。</p>\n<p>满足上述两个假设的模型就叫隐含马尔可夫模型。我们之所以用“隐含”这个 词，是因为状态 s1,s2,s3,…是无法直接观测到的。</p>\n<p>隐 含马尔可夫模型的应用远不只在语音 识别中。在上面的公式中，如果我们把 s1,s2,s3,…当成中文，把 o1,o2,o3,…当成对应的英文，那么我们就能利用 这个模型解决机器翻译问题； 如果我们把 o1,o2,o3,…当成扫描文字得到的图 像特征，就能利用这个模型解决印刷体和手写体的识别。</p>\n<p>P (o1,o2,o3,…|s1,s2,s3….) 根据应用的不同而又不同的名称，在语音识别 中它被称为“声学模型” (Acoustic Model)， 在机器翻译中是“翻译模型” (Translation Model) 而在拼写校正中是“纠错模型” (Correction Model)。 而P (s1,s2,s3,…) 就是我们在系列一中提到的语言模型。</p>\n<p>在利用隐含马尔可夫模型解决语言处理问题前，先要进行模型的训练。 常用的 训练方法由伯姆（Baum）在 60 年代提出的，并以他的名字命名。隐含马尔可夫 模型在处理语言问题早期的成功应用是语音识别。七十年代，当时 IBM 的 Fred Jelinek (贾里尼克) 和卡内基·梅隆大学的 Jim and Janet Baker (贝克夫妇 ， 李开复的师兄师姐) 分别独立地提出用隐含马尔可夫模型来识别语音，语音识别 的错误率相比人工智能和模式匹配等方法降低了三倍 (从 30% 到 10%)。 八十 年代李开复博士坚持采用隐含马尔可夫模型的框架， 成功地开发了世界上第一 个大词汇量连续语音识别系统 Sphinx。</p>\n<p>我 最早接触到隐含马尔可夫模型是几乎二十年前的事。那时在《随机过程》（清 华“著名”的一门课）里学到这个模型，但当时实在想不出它有什么实际用途。 几年 后，我在清华跟随王作英教授学习、研究语音识别时，他给了我几十篇文 献。 我印象最深的就是贾里尼克和李开复的文章，它们的核心思想就是隐含马 尔可夫模型。复杂的语音识别问题居然能如此简单地被表述、解决，我由衷地感 叹数学模型 之妙。</p>\n<h2 id=\"四、数学之美系列四-—-怎样度量信息\"><a href=\"#四、数学之美系列四-—-怎样度量信息\" class=\"headerlink\" title=\"四、数学之美系列四 — 怎样度量信息\"></a>四、数学之美系列四 — 怎样度量信息</h2><p>2006 年 4 月 26 日 上午 08:11:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>前言: Google 一直以 “整合全球信息，让人人能获取，使人人能受益” 为使 命。那么究竟每一条信息应该怎样度量呢？</p>\n<p>信息是个很抽象的概念。我们常常说信息很多，或者信息较少，但却很难说清楚 信息到底有多少。比如一本五十万字的中文书到底有多少信息量。直到 1948 年， 香农 提出了“ 信息熵 ”(shāng) 的概念，才解决了对信息的量化度量问题。</p>\n<p>一 条信息的信息量大小和它的不确定性有直接的关系。比如说，我们要搞清楚 一件非常非常不确定的事，或是我们一无所知的事情，就需要了解大量的信息。 相反，如 果我们对某件事已经有了较多的了解，我们不需要太多的信息就能把 它搞清楚。所以，从这个角度，我们可以认为，信息量的度量就等于不确定性的 多少。</p>\n<p>那 么我们如何量化的度量信息量呢？我们来看一个例子，马上要举行世界杯赛 了。大家都很关心谁会是冠军。假如我错过了看世界杯，赛后我问一个知道比赛 结果的观 众“哪支球队是冠军”？ 他不愿意直接告诉我， 而要让我猜，并且 我每猜一次，他要收一元钱才肯告诉我是否猜对了，那么我需要付给他多少钱才 能知道谁是冠军呢? 我可以把球队编上号，从 1 到 32， 然后提问： “冠军的 球队在 1-16 号中吗?” 假如他告诉我猜对了， 我会接着问： “冠军在 1-8 号 中吗?” 假如他告诉我猜错了， 我自然知道冠军队在 9-16 中。 这样只需要五 次， 我就能知道哪支球队是冠军。所以，谁是世界杯冠军这条消息的信息量只 值五块钱。</p>\n<p>当然，香农不是用钱，而是用 “比特”（bit）这个概念来度量信息量。 一个 比特是一位二进制数，计算机中的一个字节是八个比特。在上面的例子中，这条 消息的信息量是五比特。（如果有朝一日有六十四个队进入决赛阶段的比赛，那 么“谁世界杯冠军”的信息量就是六比特，因为我们要多猜一次。） 读者可能 已经发现, 信息量的比特数和所有可能情况的对数函数 log 有关。 (log32=5, log64=6。）</p>\n<p>有些读者此时可能会发现我们实际上可能不需要猜五次就能猜出谁是冠军，因为 象巴西、德国、意 大利这样的球队得冠军的可能性比日本、美国、韩国等队大 的多。因此，我们第一次猜测时不需要把 32 个球队等分成两个组，而可以把少 数几个最可能的球队分成一组，把其它队分成另一组。然后我们猜冠军球队是否 在那几只热门队中。我们重复这样的过程，根据夺 冠概率对剩下的候选球队分 组，直到找到冠军队。这样，我们也许三次或四次就猜出结果。因此，当每个球 队夺冠的可能性（概率）不等时，“谁世界杯冠军”的信 息量的信息量比五比 特少。香农指出，它的准确信息量应该是</p>\n<p> = -（$p1 <em>log p1 + p2 </em>log p2  + ．．．+ p32 *log p32$)，</p>\n<p>其 中，p1，p2 ， ．．．，p32 分别是这 32 个球队夺冠的概率。香农把它称 为“信息熵” (Entropy)，一般用符号 H 表示，单位是比特。有兴趣的读者可 以推算一下当 32 个球队夺冠概率相同时，对应的信息熵等于五比特。有数学基 础的读者还可以证明上面公式的值不可能大于五。对于任意一个随机变量 X（比 如得冠军的球队），它的熵定义如下：</p>\n<p>变量的不确定性越大，熵也就越大，把它搞清楚所需要的信息量也就越大。</p>\n<p>有 了“熵”这个概念，我们就可以回答本文开始提出的问题，即一本五十万字 的中文书平均有多少信息量。我们知道常用的汉字（一级二级国标）大约有 7000 字。假如每个字等概率，那么我们大约需要 13 个比特（即 13 位二进制数）表 示一个汉字。但汉字的使用是不平衡的。实际上，前 10% 的汉字占文本的 95% 以 上。因此，即使不考虑上下文的相关性，而只考虑每个汉字的独立的概率，那么， 每个汉字的信息熵大约也只有 8-9 个比特。如果我们再考虑上下文相关性，每 个汉字的信息熵只有 5 比特左右。所以，一本五十万字的中文书，信息量大约是 250 万比特。如果用一个好的算法压缩一下，整本书可以存成一个 320KB 的文 件。如果我们直接用两字节的国标编码存储这本书，大约需要 1MB 大小，是压 缩文件的三倍。这两个数量的差距，在信息论中称作“冗余度”（redundancy)。 需要指出的是我们这里讲的 250 万比特是个平均数，同样长度的书，所含的信 息量可以差很多。如果一本书重复的内容很多，它的信息量就小，冗余度就大。</p>\n<p>不同语言的冗余度差别很大，而汉语在所有语言中冗余度是相对小的。这和人们 普遍的认识“汉语是最简洁的语言”是一致的。</p>\n<p>在下一集中， 我们将介绍信息熵在信息处理中的应用以及两个相关的概念互信 息和相对熵。</p>\n<p>对中文信息熵有兴趣的读者可以读我和王作英教授在电子学报上合写的一篇文 章</p>\n<p>《语信息熵和语言模型的复杂度》</p>\n<h2 id=\"五、简单之美：布尔代数和搜索引擎的索引\"><a href=\"#五、简单之美：布尔代数和搜索引擎的索引\" class=\"headerlink\" title=\"五、简单之美：布尔代数和搜索引擎的索引\"></a>五、简单之美：布尔代数和搜索引擎的索引</h2><p>2006 年 5 月 10 日 上午 09:10:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>建立一个搜索引擎大致需要做这样几件事：自动下载尽可能多的网页；建立快 速 有 效 的 索 引 ； 根 据 相 关 性 对 网 页 进 行 公 平 准 确 的 排 序 。 我 们 在 介 绍 Google Page Rank (网页排名) 时已经谈到了一些排序的问题，这里我们谈谈索引问题， 以后我们还会谈如何度量网页的相关性，和进行网页自动下载。</p>\n<p>世界上不可能有比二进制更简单的计数方法了，也不可能有比布尔运算更简单的 运算了。尽管今天每个搜索引擎都宣称自己如何聪明、多么智能化，其实从根本 上讲都没有逃出布尔运算的框框。</p>\n<p>布尔 （George Boole) 是十九世纪英国一位小学数学老师。他生前没有人认为他 是数学家。布尔在工作之余，喜欢阅读数学论著、思考数学问题。1854 年“ 思 维规律 ” （An Investigation of the Laws of Thought, on which are founded the Mathematical Theories of Logic and Probabilities）一书，第一次向人 们展示了如何用数学的方法解决逻辑问题。</p>\n<p>布尔代数简单得不能再简单了。运算的元素只有两个 1 （TRUE， 真) 和 0 （FALSE，假)。基本的运算只有“与”（AND)、“或” (OR) 和“非”（NOT) 三 种（后来发现，这三种运算都可以转换成“与”“非” ＡＮＤ－ＮＯＴ一种运 算）。全部运算只用下列几张真值表就能完全地描述清楚。</p>\n<p>AND | 1 0</p>\n<p>———————– 1 | 1 0 0 | 0 0</p>\n<p>这张表说明如果 AND 运算的两个元素有一个是 0，则运算结果总是 0。如果两 个元素都是 1，运算结果是 1。例如，“太阳从西边升起”这个判断是假的 (0),“水可以流动”这个判断是真的（1），那么，“太阳从西边升起并且水可 以流动”就是假的（0）。</p>\n<p>OR | 1 0</p>\n<p>———————– 1 | 1 1 0 | 1 0</p>\n<p>这张表说明如果OR运算的两个元素有一个是 1，则运算结果总是 1。如果两个元 素都是 0，运算结果是 0。比如说，“张三是比赛第一名”这个结论是假的（0）， “李四是比赛第一名”是真的（1），那么“张三或者李四是第一名”就是真的 （1）。</p>\n<p>NOT |</p>\n<p>————– 1 | 0 0 | 1</p>\n<p>这张表说明 NOT 运算把 1 变成 0，把 0 变成 1。比如，如果“象牙是白的” 是真的（1），那么“象牙不是白的”必定是假的（0）。</p>\n<p>读 者也许会问这么简单的理论能解决什么实际问题。布尔同时代的数学家们也 有同样的问题。事实上在布尔代数提出后 80 多年里，它确实没有什么像样的应 用，直到 1938 年香农在他的硕士论文中指出用布尔代数来实现开关电路，才使 得布尔代数成为数字电路的基础。所有的数学和逻辑运算，加、减、乘、除、乘 方、开方等等，全部 能转换成二值的布尔运算。</p>\n<p>现在我们看看文献检索和布尔运算的关系。对于一个用户输入的关键词，搜索引 擎要判断每篇文献是否含有这个关键 词，如果一篇文献含有它，我们相应地给 这篇文献一个逻辑值 – 真（TRUE,或 1），否则，给一个逻辑值 – 假（FALSE, 或 0）。比如我们要找有关原子能应用的文献，但并不想知道如何造原子弹。我 们可以这样写一个查询语句“原子能 AND 应用 AND (NOT 原子弹)”，表示符合 要求的文献必须同时满足三个条件： - 包含原子能 - 包含应用</p>\n<ul>\n<li>不包含原子弹</li>\n</ul>\n<p>一篇文献对于上面每一个条件，都有一个 True 或者 False 的答案，根据上述 真值表就能算出每篇文献是否是要找的。</p>\n<p>早期的文献检索查询系统大多基于数据库，严格要求查询语句符合布尔运算。今 天的搜索引擎相比之下要聪明的多，它自动把用户的查询语句转换成布尔运算的 算式。当然在查询时，不能将每篇文献扫描一遍，来看看它是否满足上面三个条 件，因此需要建立一个索引。</p>\n<p>最 简单索引的结构是用一个很长的二进制数表示一个关键字是否出现在每篇文 献中。有多少篇文献，就有多少位数，每一位对应一篇文献，1 代表相应的文献 有这个关键字，0 代表没有。比如关键字“原子能”对应的二进制数是 0100100001100001…，表示第二、第五、第九、第十、第十六篇文献包含着个 关键字。注 意，这个二进制数非常之长。同样，我们假定“应用”对应的二进 制数是 0010100110000001…。那么要找到同时包含“原子能”和“应用”的文 献时，只要将这两个二进制数进行布尔运算 AND。根据上面的真值表，我们知道 运算结果是 0000100000000001…。表示第五篇，第十六篇文献满足要求。</p>\n<p>注意，计算 机作布尔运算是非常非常快的。现在最便宜的微机都可以一次进行 三十二位布尔运算，一秒钟进行十亿次以上。当然，由于这些二进制数中绝大部 分位数都是零，我 们只需要记录那些等于 1 的位数即可。于是，搜索引擎的索 引就变成了一张大表：表的每一行对应一个关键词，而每一个关键词后面跟着一</p>\n<p>组数字，是包含该关键词 的文献序号。</p>\n<p>对于互联网的搜索引擎来讲，每一个网页就是一个文献。互联网的网页数量是巨 大的，网络中所用的词也非常非常多。因此这个索引 是巨大的，在万亿字节这 个量级。早期的搜索引擎（比如 Alta Vista 以前的所有搜索引擎），由于受计 算机速度和容量的限制，只能对重要的关键的主题词建立索引。至今很多学术杂 志还要求作者提供 3-5 个关键词。这样所有不常见的词和太常见的虚词就找不 到了。现在，为了保证对任何搜索都能提供相关的网页，所有的搜索引擎都是对 所有的词进行索引。为了网页 排名方便，索引中还需存有大量附加信息，诸如 每个词出现的位置、次数等等。因此，整个索引就变得非常之大，以至于不可能 用一台计算机存下。大家普遍的做法 就是根据网页的序号将索引分成很多份 （Shards)，分别存储在不同的服务器中。每当接受一个查询时，这个查询就被 分送到许许多多服务器中，这些服务器 同时并行处理用户请求，并把结果送到 主服务器进行合并处理，最后将结果返回给用户。</p>\n<p>不管索引如何复杂，查找的基本操作仍然是布尔运算。布 尔运算把逻辑和数学 联系起来了。它的最大好处是容易实现，速度快，这对于海量的信息查找是至关 重要的。它的不足是只能给出是与否的判断，而不能给出量化的 度量。因此， 所有搜索引擎在内部检索完毕后，都要对符合要求的网页根据相关性排序，然后 才返回给用户。</p>\n<h2 id=\"六、图论和网络爬虫-Web-Crawlers\"><a href=\"#六、图论和网络爬虫-Web-Crawlers\" class=\"headerlink\" title=\"六、图论和网络爬虫 (Web Crawlers)\"></a>六、图论和网络爬虫 (Web Crawlers)</h2><p>2006 年 5 月 15 日 上午 07:15:00</p>\n<p>发表者: 吴军，Google 研究员</p>\n<p>离散数学 是当代数学的一个重要分支，也是计算机科学的数学基础。它包括数 理逻辑、集合论、图论和近世代数四个分支。数理逻辑基于布尔运算，我们已经 介绍过了。这里我们介绍图论和互联网自动下载工具网络爬虫 (Web Crawlers) 之间的关系。顺便提一句，我们用 Google Trends 来搜索一下“离散数学”这 个词，可以发现不少有趣的现象。比如，武汉、哈尔滨、合肥和长沙市对这一数 学题目最有兴趣的城市。</p>\n<p>我们 上回 谈到了如何建立搜索引擎的索引，那么如何自动下载互联网所有的网页 呢，它要用到图论中的遍历（Traverse) 算法。</p>\n<p>图论的起源可追溯到大数学家 欧拉 （Leonhard Euler）。1736 年欧拉来到德国 的哥尼斯堡（Konigsberg，大哲学家康德的故乡，现在是俄罗斯的加里宁格勒）， 发现当地市民们有一项消遣活动，就是试图将下图中的 每座桥恰好走过一遍并 回到原出发点，从来没有人成功过。欧拉证明了这件事是不可能的，并写了一篇 论文，一般认为这是图论的开始。</p>\n<p>图 论中所讨论的的图由一些节点和连接这些节点的弧组成。如果我们把中国的 城市当成节点，连接城市的国道当成弧，那么全国的公路干线网就是图论中所说 的图。关 于图的算法有很多，但最重要的是图的遍历算法，也就是如何通过弧 访问图的各个节点。以中国公路网为例，我们从北京出发，看一看北京和哪些城 市直接相连，比 如说和天津、济南、石家庄、南京、沈阳、大同直接相连。我 们可以依次访问这些城市，然后我们看看都有哪些城市和这些已经访问过的城市 相连，比如说北戴河、 秦皇岛与天津相连，青岛、烟台和济南相连，太原、郑 州和石家庄相连等等，我们再一次访问北戴河这些城市，直到中国所有的城市都<br>访问过一遍为止。这种图的遍 历算法称为“广度优先算法”（BFS)，因为它先 要尽可能广地访问每个节点所直接连接的其他节点。另外还有一种策略是从北京 出发，随便找到下一个要访问的 城市，比如是济南，然后从济南出发到下一个 城市，比如说南京，再访问从南京出发的城市，一直走到头。然后再往回找，看 看中间是否有尚未访问的城市。这种方 法叫“深度优先算法”（DFS)，因为它 是一条路走到黑。这两种方法都可以保证访问到全部的城市。当然，不论采用哪 种方法，我们都应该用一个小本本，记录 已经访问过的城市，以防同一个城市 访问多次或者漏掉哪个城市。</p>\n<p>现在我们看看图论的遍历算法和搜索引擎的关系。互联网其实就是一张大图，我 们可以把每一个网页当作一个节点，把那些超链接（Hyperlinks)当作连接网页 的弧。很多读者可能已经注意到，网页中那些蓝色的、带有下划线的文字 背后 其实藏着对应的网址，当你点下去的的时候，浏览器是通过这些隐含的网址转到 相应的网页中的。这些隐含在文字背后的网址称为“超链接”。有了超链接，我 们可以从任何一个网页出发，用图的遍历算法，自动地访问到每一个网页并把它 们存起来。完成这个功能的程序叫做网络爬虫，或者在一些文献中称为”机器人” （Robot) 。 世 界 上 第 一 个 网 络 爬 虫 是 由 麻 省 理 工 学 院 (MIT) 的 学 生 马 休. 格 雷 （Matthew Gray)在 1993 年写成的。他给他的程序起了个名字叫“互联网漫游 者”(“www wanderer”)。以后的网络爬虫越写越复杂，但原理是一样的。</p>\n<p>我们来看看网络爬虫如何下载整个互联网。假定我们从一家门户网站的首页出 发，先下载这个网页，然后通过分析这个网页，可以找到藏在它里面的所有超链 接，也就 等于知道了这家门户网站首页所直接连接的全部网页，诸如雅虎邮件、 雅虎财经、雅虎新闻等等。我们接下来访问、下载并分析这家门户网站的邮件等 网页，又能找 到其他相连的网页。我们让计算机不停地做下去，就能下载整个 的互联网。当然，我们也要记载哪个网页下载过了，以免重复。在网络爬虫中， 我们使用一个称为“ 哈希表 ”(Hash Table)的列表而不是一个记事本纪录网页 是否下载过的信息。</p>\n<p>现在的互联网非常巨大，不可能通过一台或几台计算机服务器就能完成下载任 务。比如雅虎公司（Google 没有公开公布我们的数目，所以我这里举了雅虎的 索引大小为例）宣称他们索引了 200 亿个网页，假如下载一个网页需要一秒钟， 下载这 200 亿个网页则需要 634 年。因此，一个商业的网络爬虫需要有成千上 万个服务器，并且由快速网络连接起来。如何建立这样复杂的网络系统，如何协 调这些服务器的任务，就是网络设计和 程序设计的艺术了。</p>\n<h2 id=\"七、信息论在信息处理中的应用\"><a href=\"#七、信息论在信息处理中的应用\" class=\"headerlink\" title=\"七、信息论在信息处理中的应用\"></a>七、信息论在信息处理中的应用</h2><p>我们已经介绍了 信息熵 ，它是信息论的基础，我们这次谈谈信息论在自然语言处理中的应用。</p>\n<p>先看看信息熵和语言模型的关系。我们在 系列一 中 谈到语言模型时，没有讲如何定量地衡 量一个语言模型的好坏，当然，读者会很自然地想到，既然语言模型能减少语音识别和机器 翻译的错误，那么就拿一个语音识 别系统或者机器翻译软件来试试，好的语言模型必然导 致错误率较低。这种想法是对的，而且今天的语音识别和机器翻译也是这么做的。但这种测 试方法对于研发语 言模型的人来讲，既不直接、又不方便，而且很难从错误率反过来定量 度量语言模型。事实上，在贾里尼克 ( Fred Jelinek ) 的人研究语言模型时，世界上既没有像样 的语音识别系统，更没有机器翻译。我们知道，语言模型是为了用上下文预测当前的文字， 模型越好，预测得越准，那么当前文字的不确定性就越小。</p>\n<p>信 息熵正是对不确定性的衡量，因此信息熵可以直接用于衡量统计语言模型的好坏。贾里 尼克从信息熵出发，定义了一个称为语言模型复杂度 (Perplexity) 的概念，直接衡量语言模 型的好坏。一个模型的复杂度越小，模型越好。李开复博士在介绍他发明的 Sphinx 语音识 别系统时谈到，如果不用任何语言模型（即零元语言模型）时，复杂度为 997 ，也就是说句 子中每个位置有 997 个可能的单词可以填入。如果（二元）语言模型只考虑前后词的搭配 不考虑搭配的概率时，复杂度为 60 。虽然它比不用语言模型好很多，但是和考虑了搭配概 率的二元语言模型相比要差很多，因为后者的复杂度只有 20 。</p>\n<p>信 息 论 中 仅 次 于 熵 的 另 外 两 个 重 要 的 概 念 是 “ 互 信 息 ” （ Mutual Information) 和 “ 相 对 熵 ” （ Kullback-Leibler Divergence) 。</p>\n<p>“ 互 信息 ” 是信息熵的引申概念，它是对两个随机事件相关性的度量。比如说今天随机事件 北京下雨和随机变量空气湿度的相关性就很大，但是和姚明所在的休斯敦火箭 队是否能赢 公牛队几乎无关。互信息就是用来量化度量这种相关性的。在自然语言处理中，经常要度量 一些语言现象的相关性。比如在机器翻译中，最难的问题是词 义的二义性（歧义性）问题。 比如 Bush 一词可以是美国总统的名字，也可以是灌木丛。（有一个笑话，美国上届总统候 选人凯里 Kerry 的名字被一些机器翻译系统翻译成了 “ 爱尔兰的小母牛 “ ， Kerry 在英语中另 外一个意思。）那么如何正确地翻译这个词呢？人们很容易想到要用语法、要分析语句等等。 其实，至今为止，没有一种语法能很好解决这个问题，真正 实用的方法是使用互信息。具 体 的 解决 办法 大 致如 下： 首 先从 大量 文 本中 找出 和 总统 布什 一 起出 现的 互 信息 最大 的 一些 词，比如总统、美国、国会、华盛顿等等，当 然，再用同样的方法找出和灌木丛一起出现 的互信息最大的词，比如土壤、植物、野生等等。有了这两组词，在翻译 Bush 时，看看 上下文中哪类相关的词多就可以了。这种方法最初是由吉尔 (Gale) ，丘奇 (Church) 和雅让斯 基 (Yarowsky) 提出的。</p>\n<p>当时雅让斯基在宾西法尼亚大学是自然语言处理大师马库斯 (Mitch Marcus) 教授的博士 生，他很多时间泡在贝尔实验室丘奇等人的研究室里。也许是急于毕业，他在吉尔等人的帮 助下想出了一个最快也是最好地解决翻译中的二义性，就是上 述的方法，这个看上去简单 的方法效果好得让同行们大吃一惊。雅让斯基因而只花了三年就从马库斯那里拿到了博士， 而他的师兄弟们平均要花六年时间。</p>\n<p>信息论中另外一个重要的概念是 “ 相对熵 ” ，在有些文献中它被称为成 “ 交叉熵 ” 。在英语中是 Kullback-Leibler Divergence ， 是以它的两个提出者库尔贝克和莱伯勒的名字命名的。相对 熵用来衡量两个正函数是否相似，对于两个完全相同的函数，它们的相对熵等于零。在自然 语言处理中可 以用相对熵来衡量两个常用词（在语法上和语义上）是否同义，或者两篇文 章的内容是否相近等等。利用相对熵，我们可以到处信息检索中最重要的一个概念：词频 率 - 逆向文档频率（ TF/IDF) 。我们下回会介绍如何根据相关性对搜索出的网页进行排序，就要 用的餐 TF/IDF 的概念。另外，在新闻的分类中也要用到相对熵和 TF/IDF 。</p>\n<p>对信息论有兴趣又有一定数学基础的读者，可以阅读斯坦福大学托马斯 . 科弗 (Thomas Cover) 教授的专著 “ 信息论基础 “(Elements of Information Theory) ：</p>\n<p>m/gp/product/0471062596/ref=nosim/103-7880775-7782209?n=283155 m/query/p?viBookCode=17909 科弗教授是当今最权威的信息论专家。</p>\n<h2 id=\"八、贾里尼克的故事和现代语言处理\"><a href=\"#八、贾里尼克的故事和现代语言处理\" class=\"headerlink\" title=\"八、贾里尼克的故事和现代语言处理\"></a>八、贾里尼克的故事和现代语言处理</h2><p>2006 年 6 月 8 日 上午 09:15:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>读 者也许注意到了，我们在前面的系列中多次提到了贾里尼克这个名字。事实 上，现代语音识别和自然语言处理确实是和它的名字是紧密联系在一起的。我想 在这回的 系列里，介绍贾里尼克本人。在这里我不想列举他的贡献，而想讲一 讲他作为一个普普通通的人的故事。这些事要么是我亲身经历的，要么是他亲口 对我讲的。</p>\n<p>弗 莱德里克.贾里尼克(Fred Jelinek)出生于捷克一个富有的犹太家庭。他的父 母原本打算送他去英国的公学（私立学校）读书。为了教他德语，还专门请的一 位德国的家庭女教师，但 是第二次世界大战完全打碎了他们的梦想。他们先是 被从家中赶了出去，流浪到布拉格。他的父亲死在了集中营，弗莱德自己成天在 街上玩耍，完全荒废了学业。二 战后，当他再度回到学校时，他的成绩一塌糊 涂， 全部是 D，但是很快他就赶上了班上的同学。不过，他在小学时从来没有 得过 A。1949 年，他的母亲带领全家移民美国。在美国，贾里尼克一家生活非 常贫困，全家基本是靠母亲做点心卖钱为生，弗莱德自己十四五岁就进工厂打工 补助全 家。</p>\n<p>贾里尼克最初想成为一个律师，为他父亲那样的冤屈者辩护，但他很快意识到他 那浓厚的外国口音将使他在法庭上的辩护很吃力。贾里 尼克的第二个理想是成 为医生，他想进哈佛大学医学院，但经济上他无法承担医学院 8 年高昂的学费。 与此同时麻省理工学院给于了他一份（为东欧移民设的）全额奖学金。贾里尼克 决定到麻省理工学电机工程。在那里，他遇到了信息论的鼻祖香农博 士，和语 言学大师贾格布森 Roman Jakobson (他提出了著名的通信六功能）[注释一]， 后来贾里尼克又陪着太太听最伟大的语言学家乔姆斯基(Noam Chomsky)的课。这 三位大师对贾里尼克今后的研究方向–利用信息论解决语言问题产生的重要影 响。</p>\n<p>贾 里尼克从麻省理工获得博士学位后，在哈佛大学教了一年书，然后到康乃尔 大学任教。他之所以选择康乃尔大学，是因为找工作时和那里的一位语言学家谈 得颇为投 机。当时那位教授表示愿意和贾里尼克在利用信息论解决语言问题上 合作。但是，等贾里尼克到康乃尔以后，那位教授表示对语言学在没有兴趣而转 向写歌剧了。贾 里尼克对语言学家的坏印象从此开始。加上后来他在 IBM 时发 现语言学家们嘴上头头是道，干起活来高不成低不就，对语言学家从此深恶痛绝。 他甚至说：”我每开除一名语言学家，我的语音识别系统错误率就降低一个百 分 点。” 这句话后来在业界广为流传，为每一个搞语音识别和语言处理的人所熟知。</p>\n<p>贾里尼克在康乃尔十年磨一剑，潜心研究信息论，终于悟 出了自然语言处理的 真谛。１９７２年，贾里尼克到ＩＢＭ 华生实验室（ＩＢＭ Ｔ．Ｇ．Ｗａｔ</p>\n<p>ｓｏｎ Ｌａｂｓ）做学术休假，无意中领导了语音识别实验室，两年后他在康 乃尔和ＩＢＭ 之间选择了留在ＩＢＭ。在那里，贾里尼克组建了阵容空前绝后 强大的研究队伍，其中包括他的著名搭档波尔（Bahl），著名的语音识别 Dragon 公司的创始人贝克夫妇，解决最大熵迭代算法的达拉皮垂(Della Pietra)孪生兄 弟，BCJR 算法的另外两个共同提出者库克(Cocke)和拉维夫(Raviv)，以及第一 个提出机器翻译统计模型的布朗。</p>\n<p>七十年代的 IBM 有点像九十年代的微软和今天的 Google, 给于杰出科学家作 任何有兴趣研究的自由。在那种宽松的环境里，贾里尼克等人提出了统计语音识 别的框架结构。 在贾里尼克以前，科学家们把语音识别问题当作人工智能问题 和模式匹配问题。而贾里尼克把它当成通信问题，并用两个隐含马尔可夫模型（声 学模型和语言模型） 把语音识别概括得清清楚楚。这个框架结构对至今的语音 和语言处理有着深远的影响，它从根本上使得语音识别有实用的可能。 贾里尼 克本人后来也因此当选美国工程院院士。</p>\n<p>贾里尼克和波尔，库克以及拉维夫对人类的另一大贡献是 BCJR 算法，这是今天 数字通信中应用的最广的两个算法之一（另一个是维特比算法）。有趣的是，这 个算法发明了二十年后，才得以广泛应用。IBM 于是把它列为了 IBM 有史以来 对人类最大贡献之一，并贴在加州 Amaden 实现室墙上。遗憾的是 BCJR 四个人 已经全部离开 IBM，有一次IBM 的通信部门需要用这个算法，还得从斯坦福大学 请一位专家去讲解，这位专家看到 IBM 橱窗里的成就榜，感慨万分。</p>\n<p>贾 里尼克和 IBM 一批最杰出的科学家在九十年代初离开了 IBM，他们大多数在 华尔街取得了巨大的成功。贾里尼克的书生气很浓，于是去约翰霍普金斯大学建 立了世界著名的 CLSP 实验室。每年夏天，贾里尼克邀请世界上 20-30 名顶级 的科学家和学生到 CLSP 一起工作，使得 CLSP 成为世界上语音和语言处理的中 心之一。</p>\n<p>贾里尼克治学极为严谨，对学生要求也极严。他淘汰学生的比例极高，即使留下 来的，毕业时间也极 长。但是，另一方面，贾里尼克也千方百计利用自己的影 响力为学生的学习和事业创造方便。贾里尼克为组里的每一位学生提供从进组第 一天到离开组最后一天全部 的学费和生活费。他还为每一位学生联系实习机会， 并保证每位学生在博士生阶段至少在大公司实习一次。从他那里拿到博士学位的 学生，全部任职于著名实验室， 比如IBM, 微软，AT&amp;T 和 Google 的实验室。 为了提高外国人的英语水平，贾里尼克用自己的经费为他们请私人英语教师。</p>\n<p>贾里尼克生活俭朴，一辆老式丰田车开了二十多年，比组里学生的车都破。他 每年都邀请组里的学生和教授到家里做客，很多毕业了的学生也专程赶来聚会。 在那里， 他不再谈论学术问题，而会谈些巩俐的电影（他太太是哥伦比亚大学 电影专业的教授），或是某著名教授被拉斯韦加斯的赌馆定为不受欢迎的人等等。 但是他聚会的 食物实在难吃，无非是些生胡萝卜和芹菜。后来贾里尼克掏钱让 系里另一个教授承办聚会，那个教授每次请专业大厨在家作出极丰盛的晚宴，并 准备许多美酒，从此 这种聚会就转移到那个教授家了。</p>\n<p>除了巩俐的电影，贾里尼克对中国的了解就是清华大学和青岛啤酒了。他有时会 把两个名字搞混，有两次被香港科技大学的 Pascale 冯教授抓住。</p>\n<p>贾 里尼克说话心直口快，不留余地。在他面前谈论学术一定要十分严谨，否则 很容易被他抓住辫子。除了刚才提到的对语言学家略有偏见的评论，他对许多世 界级的大 师都有过很多“刻薄”但又实事求是的评论，这些评论在业界广为流 传。贾里尼克在四十多年的学术生涯中居然没有得罪太多的人 ，可以说是一个 奇迹。</p>\n<p>注释一：<br>贾格布森的通信模型<br>1上下文<br>2信息<br>3发送着<br>4接收者<br>5信道<br>6编码</p>\n<h2 id=\"九、如何确定网页和查询的相关性\"><a href=\"#九、如何确定网页和查询的相关性\" class=\"headerlink\" title=\"九、如何确定网页和查询的相关性\"></a>九、如何确定网页和查询的相关性</h2><p>2006 年 6 月 27 日 上午 09:53:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>[我们已经谈过了 如何自动下载网页 、 如何建立索引 、 如何衡量网页的质量 (Page Rank)。我们今天谈谈如何确定一个网页和某个查询的相关性。了解了这四个方 面，一个有一定编程基础的读者应该可以写一个简单的搜索引擎了，比如为您所 在的学校或院系建立一个小的搜索引擎。]</p>\n<p>我们还是看上回的例子，查找关于“原子能的应用”的网页。我们第一步是在索 引中找到包含这三个词的网页（详见关于 布尔运算 的系列）。现在任何一个搜索 引擎都包含几十万甚至是上百万个多少有点关系的网页。那么哪个应该排在前面 呢？显然我们应该根据网页和查询“原子能的应用”的相关性对这些网页进行 排序。因此，这里的关键问题是如何度量网页和查询的相关性。</p>\n<p>我 们知道，短语“原子能的应用”可以分成三个关键词：原子能、的、应用。 根据我们的直觉，我们知道，包含这三个词多的网页应该比包含它们少的网页相 关。当 然，这个办法有一个明显的漏洞，就是长的网页比短的网页占便宜，因 为长的网页总的来讲包含的关键词要多些。因此我们需要根据网页的长度，对关 键词的次数进 行归一化，也就是用关键词的次数除以网页的总字数。我们把这 个商称为“关键词的频率”，或者“单文本词汇频率”（Term Frequency)，比 如，在某个一共有一千词的网页中“原子能”、“的”和“应用”分别出现了 2 次、35 次 和 5 次，那么它们的词频就分别是 0.002、0.035 和 0.005。 我们 将这三个数相加，其和 0.042 就是相应网页和查询“原子能的应用”</p>\n<p>相关性的一个简单的度量。概括地讲，如果一个查询包含关键词 w1,w2,…,wN, 它 们 在 一 篇 特 定 网 页 中 的 词 频 分 别 是: TF1, TF2, …, TFN 。 （TF: term frequency)。 那么，这个查询和该网页的相关性就是: TF1 + TF2 + … + TFN。</p>\n<p>读 者可能已经发现了又一个漏洞。在上面的例子中，词“的”站了总词频的 80% 以上，而它对确定网页的主题几乎没有用。我们称这种词叫“应删除词” （Stopwords)，也就是说在度量相关性是不应考虑它们的频率。在汉语中，应删 除词还有“是”、“和”、“中”、“地”、“得”等等几十个。忽略这些应删 除词后，上述网页的相似度就变成了 0.007，其中“原子能”贡献了 0.002，“应 用”贡献了 0.005。</p>\n<p>细心的读者可能还会发现另一个小的漏洞。在汉语中，“应用”是个很通用的词， 而“原子能”是个很专业的词，后者在相关性排名中比前者重要。因此我们需要 给汉语中的每一个词给一个权重，这个权重的设定必须满足下面两个条件：</p>\n<ol>\n<li><p>一个词预测主题能力越强，权重就越大，反之，权重就越小。我们在网页中看到“原子能”这个词，或多或少地能了解网页的主题。我们看到“应用”一次， 对主题基本上还是一无所知。因此，“原子能“的权重就应该比应用大。</p>\n</li>\n<li><p>应删除词的权重应该是零。</p>\n</li>\n</ol>\n<p>我 们很容易发现，如果一个关键词只在很少的网页中出现，我们通过它就容易 锁定搜索目标，它的权重也就应该大。反之如果一个词在大量网页中出现，我们 看到它仍 然不很清楚要找什么内容，因此它应该小。概括地讲，假定一个关键 词 ｗ 在 Ｄｗ 个网页中出现过，那么 Ｄｗ 越大，ｗ 的权重越小，反之亦然。 在 信 息 检 索 中 ， 使 用 最 多 的 权 重 是 “ 逆 文 本 频 率 指 数 ” （Inverse document frequency 缩写为ＩＤＦ），它的公式为ｌｏｇ（Ｄ／Ｄｗ）其中Ｄ是全部网页 数。比如，我们假定中文网页数是Ｄ＝１０亿，应删除词“的”在所有的网页中 都出现，即Ｄｗ ＝１０亿，那么它的ＩＤＦ＝log(10 亿/10 亿）= log (1) = ０。 假如专用词“原子能”在两百万个网页中出现，即Ｄｗ＝２００万，则它的权重 ＩＤＦ＝log(500) =6.2。又假定通用词“应用”，出现在五亿个网页中，它的 权重ＩＤＦ = log(2)</p>\n<p>则只有 0.7。也就只说，在网页中找到一个“原子能”的比配相当于找到九个 “应用”的匹配。利用 IDF，上述相关性计算个公式就由词频的简单求和变成了 加权求和，即 TF1<em>IDF1 + TF2</em>IDF2 ＋… + TFN*IDFN。在上面的例子中，该 网页和“原子能的应用”的相关性为 0.0161，其中“原子能”贡献了 0.0126， 而“应用”只贡献了 0.0035。这个比例和我们的直觉比较一致了。</p>\n<p>ＴＦ／ＩＤＦ（term frequency/inverse document frequency) 的概念被公认 为信息检索中最重要的发明。在搜索、文献分类和其他相关领域有广泛的应用。 讲起 TF/IDF 的历史蛮有意思。IDF 的概念最早是剑桥大学的斯巴克－琼斯(注： 她有两个姓) (Karen Sparck Jones)提出来的。斯巴克－琼斯 １９７２ 年在 一篇题为关键词特殊性的统计解释和她在文献检索中的应用的论文中提出ＩＤ Ｆ。遗憾的是，她既没有从理论上解释为什么权重ＩＤＦ 应该是对数函数 ｌｏ ｇ（Ｄ／Ｄｗ）（而不是其它的函数，比如平方根），也没有在这个题目上作进 一步深入研究，以至于在以后的很多文献中人们提到 ＴＦ／ＩＤＦ 时没有引用 她的论文，绝大多数人甚至不知道斯巴克－琼斯的贡献。同年罗宾逊写了个两页 纸的解释，解释得很不好。倒是后来康乃尔大学的萨尔顿 （Salton)多次写文章、 写书讨论 TF/IDF 在信息检索中的用途，加上萨尔顿本人的大名（信息检索的世 界大奖就是以萨尔顿的名字命名的）。很多人都引用萨尔顿的书，甚至以为这个 信息检索中最重要的概 念是他提出的。当然，世界并没有忘记斯巴克－琼斯的 贡献，2004 年，在纪念文献学学报创刊 60 周年之际，该学报重印了斯巴克-琼 斯的大作。罗宾逊在同期期刊上写了篇文章，用香农的信息论解释 IDF，这回的 解释是对的，但文章写的并不好、非常冗长（足足十八页），把一个简单问题搞 复杂了。其实，信息论的学者们已经发现并指出，其实 IDF 的概念就是一个特 定条件下、关键词的概率分布的交叉熵（Kullback-Leibler Divergence)（详见 上一系列 ）。这样，信息检索相关性的度量，又回到了信息论。</p>\n<p>现在的搜索引擎对 TF/IDF 进行了不少细微的优化，使得相关性的度量更加准 确了。当然，对有兴趣写一个搜索引擎的爱好者来讲，使用 TF/IDF 就足够了。</p>\n<p>如果我们结合上网页排名(Page Rank)，那么给定一个查询，有关网页综合排名 大致由相关性和网页排名乘积决定。</p>\n<h2 id=\"十、有限状态机和地址识别\"><a href=\"#十、有限状态机和地址识别\" class=\"headerlink\" title=\"十、有限状态机和地址识别\"></a>十、有限状态机和地址识别</h2><p>2006 年 7 月 5 日 上午 09:09:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>地址的识别和分析是本地搜索必不可少的技术，尽管有许多识别和分析地址的方 法，最有效的是有限状态机。</p>\n<p>一个有限状态机是一个特殊的有向图（参见有关 图论的系列 ），它包括一些状态 （节点）和连接这些状态的有向弧。下图是一个识别中国地址的有限状态机的简 单的例子。</p>\n<p>每 一个有限状态机都有一个启始状态和一个终止状态和若干中间状态。每一条 弧上带有从一个状态进入下一个状态的条件。比如，在上图中，当前的状态是 “省”，如 果遇到一个词组和（区）县名有关，我们就进入状态“区县”；如 果遇到的下一个词组和城市有关，那么我们就进入“市”的状态，如此等等。如 果一条地址能从状 态机的起始状态经过状态机的若干中间状态，走到终止状态， 那么这条地址则有效，否则无效。比如说，“北京市双清路 83 号”对于上面的 有限状态来讲有效，而 “上海市辽宁省马家庄”则无效（因为无法从市走回到 省）。</p>\n<p>使用有限状态机识别地址，关键要解决两个问题，即通过一些有效的地址建立状 态 机，以及给定一个有限状态机后，地址字串的匹配算法。好在这两个问题都 有现成的算法。有了关于地址的有限状态机后，我们就可又用它分析网页，找出 网页中的 地址部分，建立本地搜索的数据库。同样，我们也可以对用户输入的 查询进行分析，挑出其中描述地址的部分，当然，剩下的关键词就是用户要找的 内容。比如，对 于用户输入的“北京市双清路附近的酒家”，Google 本地会自 动识别出地址“北京市双清路”和要找的对象“酒家”。</p>\n<p>上述基于有限状态 机的地址识别方法在实用中会有一些问题：当用户输入的地 址不太标准或者有错别字时，有限状态机会束手无策，因为它只能进行严格匹配。 （其实，有限状态机在 计算机科学中早期的成功应用是在程序语言编译器的设 计中。一个能运行的程序在语法上必须是没有错的，所以不需要模糊匹配。而自 然语言则很随意，无法用简单 的语法描述。）</p>\n<p>为了解决这个问题，我们希望有一个能进行模糊匹配、并给出一个字串为正确地 址的可能性。为了实现这一目的，科学家们提出了基于概率的有限状态机。这种 基于概率的有限状态机和离散的马尔可夫链（详见前面关于 马尔可夫模型 的系 列）基本上等效。</p>\n<p>在八十年代以前，尽管有不少人使用基于概率的有限状态机，但都是为自己的 应用设计专用的有限状态机的程序。九十年代以后，随着有限状态机在自然语言 处理的广 泛应用，不少科学家致力于编写通用的有限状态机程序库。其中，最 成功的是前 AT&amp;T 实验室的三位科学家，莫瑞（Mohri）, 皮瑞尔（Pereira） 和 瑞利（Riley）。他们三人花了很多年时间，编写成一个通用的基于概率的有限 状态机 C 语言工具库。由于 AT&amp;T 有对学术界免费提供各种编程工具的好传统， 他们三人也把自己多年的心血拿出来和同行们共享。可惜好景不长，AT&amp;T 实验 室风光不再，这三个人都离开了 AT&amp;T，莫瑞成了纽约大学的教授，皮瑞尔当了 宾西法尼亚大学计算机系系主任，而瑞利成了 Google 的研究员，AT&amp;T 实验室 的新东家不再免费提供有限状态机 C 语言工具库。虽然此前莫瑞等人公布了他 们的详细算法，但是省略了实现的细节。因此在学术界，不少科学家能够重写同 样功能的工具库，但是很难达到 AT&amp;T 工具库的效率（即运算速度），这的确是 一件令人遗憾的事。</p>\n<h2 id=\"十一、-Google-阿卡-47-的制造者阿米特-辛格博士\"><a href=\"#十一、-Google-阿卡-47-的制造者阿米特-辛格博士\" class=\"headerlink\" title=\"十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士\"></a>十一、 Google 阿卡 47 的制造者阿米特 . 辛格博士</h2><p>2006 年 7 月 10 日 上午 09:52:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>枪迷或者看过尼古拉斯.凯奇（Nicolas Cage)主演的电影“战争之王”（Lord of War)的人也许还记得影片开头的一段话：（在所有轻武器中，）最有名的是阿卡 47( AK47)冲锋枪(也就是中国的五六式冲锋枪的原型），因为它从不卡壳、从不 损坏、可在任何环境下使用、可靠性好、杀伤力大并且操作简单。</p>\n<p>我 认为，在计算机中一个好的算法，应该向阿卡 47 冲锋枪那样简单、有效、 可靠性好而且容易读懂(或者说易操作），而不应该是故弄玄虚。Google 的杰出 工程师阿米特.辛格博士 (Amit Singhal) 就是为 Google 设计阿卡 47 冲锋枪 的人，在公司内部，Google 的排序算法便是以他的名字命名的。</p>\n<p>从加入 Google 的第一天，我就开始了和辛格长期而愉快的合作，而他一直是我 的一个良师益友。辛格、Matt Cutts（中国一些用户误认为他是联邦调查局特工， 当然他不是）、马丁和我四个人当时一同研究和解决网络搜索中的作弊问题 （Spam)。我们需要建一个 分类器，我以前一直在学术界工作和学习，比较倾向 找一个很漂亮的解决方案。我设计了一个很完美的分类器，大约要花三个月到半 年时间来实现和训练，而辛格认 为找个简单有效的办法就行了。我们于是尽可 能简化问题，一、两个月就把作弊的数量减少了一半。当时我们和公司工程副总 裁罗森打了个赌，如果我们能减少 40% 的作弊，他就送我们四个家庭去夏威夷 度假，后来罗森真的履约了。这个分类器设计得非常小巧（只用很小的内存）， 而且非常快速（几台服务器就能处理全球搜索 的分类），至今运行得很好。</p>\n<p>后来我和辛格一起又完成了许多项目，包括对中、日、韩文排名算法的改进。每 一次，辛格总是坚持找简单有效的解 决方案。这种做法在 Google 这个人才济 济的公司常常招人反对，因为很多资深的工程师怀疑这些简单方法的有效性。不 少人试图用精确而复杂的办法对辛格的设计的各种“阿卡 47” 进行改进，后来 发现几乎所有时候，辛格的简单方法都接近最优化的解决方案，而且还快得多。 另一条选择简单方案的原因是这样设计的系统很容易查错 （debug)。</p>\n<p>当然，辛格之所以总是能找到那些简单有效的方法，不是靠直觉，更不是撞大运， 而是靠他丰富的研究经验。辛格早年从师于搜 索大师萨尔顿(Salton)教授，毕 业后就职于 AT&amp;T 实验室。在那里，他和两个同事半年就搭起了一个中等规模的 搜索引擎，这个引擎索引的网页数量虽然无法和商用的引擎相比，但是准确性却 非常好。在 AT&amp;T，他对搜索问题的各个细节进行了仔细的研究，他的那些简单 而有效的解决方案，常常是深思熟虑去伪存真的结果。</p>\n<p>辛格非常鼓励年轻人不怕失败，大胆尝试。一次一位刚毕业不久的工程师因为 把带有错误的程序推出到 Google 的服务器上而惶惶不可终日。辛格安慰她讲，</p>\n<p>你知道，我在 Google 犯的最大一次错误是曾经将所有网页的相关性得分全部变 成了零，于是所有搜索的结果全部是随机的了。这位工程师后来为 Google 开发 了很多好的产品。</p>\n<p>辛格在 AT&amp;T 时确立了他在学术界的地位，但是，他不是一个满足于做实验写论文的人，于是他离开了实验室来到了当时只有百、十人的 Google。在这里， 他得以施展才智，重写了 Google 的排名算法，并且一直在负责改进它。辛格因 为舍不得放下两个孩子，很少参加各种会议，但是他仍然被学术界公认为是当今 最权威的网络搜索专家。2005 年， 辛格作为杰出校友被请回母校康乃尔大学计 算机系在 40 年系庆上作报告，获得这一殊荣的还有大名鼎鼎的美国工程院院 士，计算机独立磁盘冗余阵列（RAID)的发明人凯茨(Randy Katz) 教授。</p>\n<h2 id=\"十二、余弦定理和新闻的分类\"><a href=\"#十二、余弦定理和新闻的分类\" class=\"headerlink\" title=\"十二、余弦定理和新闻的分类\"></a>十二、余弦定理和新闻的分类</h2><p>2006 年 7 月 20 日 上午 10:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>余弦定理和新闻的分类似乎是两件八杆子打不着的事，但是它们确有紧密的联 系。具体说，新闻的分类很大程度上依靠余弦定理。</p>\n<p>Google 的新闻是自动分类和整理的。所谓新闻的分类无非是要把相似的新闻放 到一类中。计算机其实读不懂新闻，它只能快速计算。这就要求我们设计一个算 法来算出任意两篇新闻的相似性。为了做到这一点，我们需要想办法用一组数字 来描述一篇新闻。</p>\n<p>我们来看看怎样找一组数字，或者说一个向量来描述一篇新闻。回忆一下我们在 “ 如何度量网页相关性 ” 一文中介绍的TF/IDF 的概念。对于一篇新闻中的所有 实词，我们可以计算出它们的单文本词汇频率/逆文本频率值（TF/IDF)。不难想 象，和新闻主题有关的那些实词频率高， TF/IDF 值很大。我们按照这些实词在 词汇表的位置对它们的 TF/IDF 值排序。比如，词汇表有六万四千个词，分别为</p>\n<p>单 词编号 汉字词</p>\n<p>—————– - 1 阿 2 啊</p>\n<p>3 阿斗 4 阿姨 …</p>\n<p>789 服 装 ….</p>\n<p>64000 做作</p>\n<p>在 一篇新闻中，这 64,000 个词的 TF/IDF 值分别为</p>\n<p>单 词编号 TF/IDF 值 ============== 1 0</p>\n<p>2 0.0 034 3 0</p>\n<p>4 0.0 0052 5 0 …</p>\n<p>789 0 .034 …</p>\n<p>64000 0.075</p>\n<p>如 果单词表中的某个次在新闻中没有出现，对应的值为零，那么这 64,000 个数， 组成一个 64,000 维的向量。我们就用这个向量来代表这篇新闻，并成为新闻的 特征向量。如果两篇新闻的特征向量相近，则对应的新闻内容相似，它们应当归 在一类，反之亦然。</p>\n<p>学 过向量代数的人都知道，向量实际上是多维空间中有方向的线段。如果两个向 量的方向一致，即夹角接近零，那么这两个向量就相近。而要确定两个向量方向 是否一致，这就要用到余弦定理计算向量的夹角了。</p>\n<p>余 弦定理对我们每个人都不陌生，它描述了三角形中任何一个夹角和三个边的关 系，换句话说，给定三角形的三条边，我们可以用余弦定理求出三角形各个角的 角度。假定三角形的三条边为 a, b 和 c，对应的三个角为 A, B 和 C，那么角 A 的余弦 –</p>\n<p>如 果 我们将三角形的两边 b 和 c 看成是两个向量，那么上述公式等价于</p>\n<p>其 中 分母表示两个向量 b 和 c 的长度，分子表示两个向量的内积。举一个具体 的例子，假如新闻 X 和新闻 Y 对应向量分别是 x1,x2,…,x64000 和 y1,y2,…,y64000,</p>\n<p>那么它们夹角的余弦等 于，</p>\n<p>当 两条新闻向量夹角的余弦等于一时，这两条新闻完全重复（用这个办法可以删 除重复的网页）；当夹角的余弦接近于一时，两条新闻相似，从而可以归成一类； 夹角的余弦越小，两条新闻越不相关。</p>\n<p>我们在中学学习余弦定理时，恐怕很难想象它可以用来对新闻进行分类。在这里， 我们再一次看到数学工具的用途。</p>\n<h2 id=\"十三、信息指纹及其应用\"><a href=\"#十三、信息指纹及其应用\" class=\"headerlink\" title=\"十三、信息指纹及其应用\"></a>十三、信息指纹及其应用</h2><p>2006 年 8 月 3 日 上午 11:17:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>任何一段信息文字，都可以对应一个不太长的随机数，作为区别它和其它信息的 指纹（Fingerprint)。只要算法设计的好，任何两段信息的指纹都很难重复，就 如同人类的指纹一样。信息指纹在加密、信息压缩和处理中有着广泛的应用。</p>\n<p>我们在 图论和网络爬虫 一 文中提到，为了防止重复下载同一个网页，我们需要 在哈希表中纪录已经访问过的网址（URL)。但是在哈希表中以字符串的形式直接 存储网址，既费内存空间， 又浪费查找时间。现在的网址一般都较长，比如， 如果在 Google 或者百度在查找数学之美，对应的网址长度在一百个字符以上。 下面是百度的链接</p>\n<p>m/s?ie=gb2312&amp;bs=%CA%FD%D1%A7%D6%AE%C3%C0&amp;sr=&amp; z=&amp;cl=3&amp;f=8</p>\n<p>&amp;wd=%CE%E2%BE%FC+%CA%FD%D1%A7%D6%AE%C3%C0&amp;ct=0</p>\n<p>假定网址的平均长度为一百个字符，那么存贮 200 亿个网址本身至少需要 2 TB，即两千 GB 的容量，考虑到哈希表的存储效率一般只有 50%，实际需要的内 存在 4 TB以上。即使把这些网址放到了计算机的内存中，由于网址长度不固定， 以字符串的形式查找的效率会很低。因此，我们如果能够找到一个函数，将这 200 亿个网址随机地映射到 128 二进位即 16 个字节的整数空间，比如将上面那个 很长的字符串对应成一个如下的随机数:</p>\n<p>893249432984398432980545454543</p>\n<p>这样每个网址只需要占用 16 个字节而不是原来的一百个。这就能把存储网址 的内存需求量降低到原来的 1/6。这个 16 个字节的随机数，就称做该网址的信 息指纹（Fingerprint)。可以证明，只要产生随机数的算法足够好，可以保证几 乎不可能有两个字符串的指纹相 同，就如同不可能有两个人的指纹相同一样。 由于指纹是固定的 128 位整数，因此查找的计算量比字符串比较小得多。网络 爬虫在下载网页时，它将访问过的网页的网址都变成一个个信息指纹，存到哈希 表中，每当遇到一个新网址 时，计算机就计算出它的指纹，然后比较该指纹是 否已经在哈希表中，来决定是否下载这个网页。这种整数的查找比原来字符串查 找,可以快几倍到几十倍。</p>\n<p>产生信息指纹的关键算法是伪随机数产生器算法（prng)。最早的 prng 算法是 由计算机之父冯诺伊曼提出来的。他的办法非常简单，就是将一个数的平方掐头 去尾，取中间的几位数。比如一个四位的二进制数 1001（相当于十进制的 9）， 其平方为 01010001 (十进制的 81）掐头去尾剩下中间的四位 0100。当然这种方法产生的数字并不很随机，也就是说两个不同信息很有可能有同一指纹。现在常用的 MersenneTwister 算法要好得多。</p>\n<p>信息指纹的用途远不止网址的消重，信息指纹的的孪生兄弟是密码。信息指纹的 一个特征是其不可逆性, 也就是说无法根据信息指纹推出原有信息，这种性质正是网络加密传输所需要的。比如说，一个网站可以根据用户的Cookie 识别不同用户，这个 cookie 就是信息指纹。但是网站无法根据信息指纹了解用户的身份，这样就可以保护用户的隐私。 在互联网上加密的可靠性，取决于是否很难人为地找到拥有同一指纹的 信息，</p>\n<p>比如一个黑客是否能随意产生用户的cookie 。 从加密的角度讲MersenneTwister算法并不好，因为它产生的随机数有相关性。</p>\n<p>互联网上加密要用基于加密伪随机数产生器（csprng)。常用的算法有 MD5 或 者 SHA1 等标准，它们可以将不定长的信息变成定长的 128 二进位或者 160 二 进位随机数。值得一提的事，SHA1 以前被认为是没有漏洞的，现在已经被中国 的王小云教授证明存在漏洞。但是大家不必恐慌， 因为这和黑客能真正攻破你 的注册信息是还两回事。</p>\n<p>信息指纹的虽然历史很悠久，但真正的广泛应用是在有了互联网以后，这几年才渐渐热门起来。</p>\n<h2 id=\"十四、谈谈数学模型的重要性\"><a href=\"#十四、谈谈数学模型的重要性\" class=\"headerlink\" title=\"十四、谈谈数学模型的重要性\"></a>十四、谈谈数学模型的重要性</h2><p>2006 年 8 月 9 日 上午 09:12:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>注：一直关注数学之美系列的读者可能已经发现，我们对任何问题总是在找相 应的准确的数学模型。为了说明模型的重要性，今年七月份我在 Google 中国内 部讲课时用了整整一堂课来讲这个问题，下面的内容是我讲座的摘要。</p>\n<p>在 包括哥白尼、伽利略和牛顿在内的所有天文学家中，我最佩服的是地心说的 提出者托勒密。虽然天文学起源于古埃及，并且在古巴比伦时，人们就观测到了 五大行星 （金、木、水、火、土）运行的轨迹，以及行星在近日点运动比远日 点快。（下图是在地球上看到的金星的轨迹，看过达芬奇密码的读者知道金星大 约每四年在天上 画一个五角星。）</p>\n<p>但是真正创立了天文学，并且计算出诸多天体运行轨迹的是两千年前古罗马时代 的托勒密。虽然今天我们可能会嘲笑托勒密犯的简单的错误，但是真正了解托勒 密贡献的人都会对他肃然起敬。托勒密发明了球坐标，定义了包括赤道和零度经 线在内的经纬线，他提出了黄道，还发明了弧度制。</p>\n<p>当然，他最大也是最有争议的发明是地心说。虽然我们知道地球是围绕太阳运动的，但是在当时，从人们的观测出发，很容易得到地球是宇宙中心的结论。从地球上看行星的运动轨迹是不规则的，托勒密的伟大之处是用四十个小圆套大圆的方法，精确地计算出了所有行星运动的轨迹。（托勒密继承了毕达格拉斯的一些思想， 他也认为圆是最完美的几何图形。）托勒密模型的精度之高，让以后所有的科学家惊叹不已。即使今天，我们在计算机的帮助下，也很难解出四十个套在一起的圆的方程。每每想到这里，我都由衷地佩服托勒密。一千五百 年来，人们根据他的计算决定农时。但是，经过了一千五百年，托勒密对太阳运动的累积误差，还是差出了一星期。</p>\n<p>地心说的示意图，我国天文学家张衡的浑天地动说其实就是地心说。</p>\n<p>纠正地心说错误不是靠在托勒密四十个圆的模型上再多套上几个圆，而是进一 步探索真理。哥白尼发现，如果以太阳为中心来描述星体的运行，只需要 8-10 个 圆，就能计算出一个行星的运动轨迹，他提出了日心说。很遗憾的事，哥白尼正 确的假设并没有得到比托勒密更好的结果，哥白尼的模型的误差比托勒密地要大 不 少。这是教会和当时人们认为哥白尼的学说是邪说的一个原因，所以日心说 要想让人心服口服地接受，就得更准确地描述行星运动。</p>\n<p>完成这一使命 的是开普勒。开普勒在所有一流的天文学家中，资质较差，一生 中犯了无数低级的错误。但是他有两条别人没有的东西，从他的老师第谷手中继 承的大量的、在当时 最精确的观测数据，以及运气。开普勒很幸运地发现了行 星围绕太阳运转的轨道实际是椭圆形的，这样不需要用多个小圆套大圆，而只要 用一个椭圆就能将星体运动 规律描述清楚了。只是开普勒的知识和水平不足以 解释为什么行星的轨道是椭圆形的。最后是伟大的科学家牛顿用万有引力解释了 这个问题。</p>\n<p>故事 到这里似乎可以结束了。但是，许多年后，又有了个小的波澜。天文学家 们发现，天王星的实际轨迹和用椭圆模型算出来的不太符合。当然，偷懒的办法 是接着用小 圆套大圆的方法修正，但是一些严肃的科学家在努力寻找真正的原 因。英国的亚当斯和法国的维内尔（Verrier）独立地发现了吸引天王星偏离轨 道的海王 星。</p>\n<p>讲座结束前，我和 Google 中国的工程师们一同总结了这么几个结论：</p>\n<p>１. 一个正确的数学模型应当在形式上是简单的。 托勒密的模型显然太复杂。）<br>２. 一个正确的模型在它开始的时候可能还不如一个精雕细琢过的错误的模型 来的准确，但是，如果我们认定大方向是对的，就应该坚持下去。（日心说开始 并没有地心说准确。）<br>３. 大量准确的数据对研发很重要。<br>４. 正确的模型也可能受噪音干扰，而显得不准确；这时我们不应该用一种凑 合的修正方法来弥补它，而是要找到噪音的根源，这也许能通往重大发现。</p>\n<p>在网络搜索的研发中，我们在前面提到的单文本词频/逆文本频率指数（TF/IDF) 和网页排名（page rank)都相当于是网络搜索中的“椭圆模型”，它们都很简单易懂。</p>\n<h2 id=\"十五、繁与简-自然语言处理的几位精英\"><a href=\"#十五、繁与简-自然语言处理的几位精英\" class=\"headerlink\" title=\"十五、繁与简 自然语言处理的几位精英\"></a>十五、繁与简 自然语言处理的几位精英</h2><p>2006 年 8 月 23 日 下午 11:22:00</p>\n<p>发表者：吴军，Google 研究员</p>\n<p>我 在数学之美系列中一直强调的一个好方法就是简单。但是，事实上，自然语 言处理中也有一些特例，比如有些学者将一个问题研究到极致，执著追求完善甚 至可以说 完美的程度。他们的工作对同行有很大的参考价值，因此我们在科研 中很需要这样的学者。在自然语言处理方面新一代的顶级人物麦克尔 · 柯林斯 ( Michael Collins ) 就是这样的人。</p>\n<p>柯林斯：追求完美</p>\n<p>柯 林斯从师于自然语言处理大师马库斯 (Mitch Marcus)（我们以后还会多次提 到马库斯），从宾夕法利亚大学获得博士学位，现任麻省理工学院 (MIT) 副教 授（别看他是副教授，他的水平在当今自然语言处理领域是数一数二的），在作 博士期间，柯林斯写了一个后来以他名字命名的自然语言文法分析器 (sentence parser)，可以将书面语的每一句话准确地进行文法分析。文法分析是很多自然 语言应用的基础。虽然柯林斯的师兄布莱尔 (Eric Brill) 和 Ratnaparkhi 以 及师弟 Eisnar 都完成了相当不错的语言文法分析器，但是柯林斯却将它做到了 极致，使它在相当长一段时间内成为世界上最好的文法分析器。柯林斯成功的关 键在于将文法分析的 每一个细节都研究得很仔细。柯林斯用的数学模型也很漂 亮，整个工作可以用完美来形容。我曾因为研究的需要，找柯林斯要过他文法分 析器的源程序，他很爽快地 给了我。我试图将他的程序修改一下来满足我特定 应用的要求，但后来发现，他的程序细节太多以至于很难进一步优化。 柯林斯的 博士论文 堪称是自然语言处理领域的范文。它像一本优秀的小说，把所有事情的 来龙去脉介绍的清清楚楚，对于任何有一点计算机和自然语言处理知识的人，都 可以轻而易举地读懂他复杂的方法。</p>\n<p>柯 林斯毕业后，在 AT&amp;T 实验室度过了三年快乐的时光。在那里柯林斯完成了 许多世界一流的研究工作诸如隐含马尔科夫模型的区别性训练方法，卷积核在自 然语言处理中的应用等等。三年 后，AT&amp;T 停止了自然语言处理方面的研究，柯 林斯幸运地在 MIT 找到了教职。在 MIT 的短短几年间，柯林斯多次在国际会议 上获得最佳论文奖。相比其他同行，这种成就是独一无二的。柯林斯的特点就是 把事情做到极致。如果说有人喜欢“繁琐哲 学”，柯林斯就是一个。</p>\n<p>布莱尔：简单才美</p>\n<p>在研究方法上，站在柯林斯对立面的典型是他的师兄艾里克 · 布莱尔 ( Eric Brill ) 和雅让斯基，后者我们已经介绍过了，这里就不再重复。与柯林斯从工业界到学术界相反，布莱尔职业路径是从学术界走到工业界。与柯里斯的研究方 法相反，布莱 尔总是试图寻找简单得不能再简单的方法。布莱尔的成名作是基 于变换规则的机器学习方法 (transformation rule based machine learning)。 这个方法名称虽然很复杂，其实非常简单。我们以拼音转换字为例来说明它：</p>\n<p>第一步，我们把每个拼音对应的汉字中最常见的找出来作为第一遍变换的结果， 当然结果有不少错误。比如，“常识”可能被转换成“长识”；</p>\n<p>第二步，可以说是“去伪存真”，我们用计算机根据上下文，列举所有的同音字 替换的规则，比如，如果 chang 被标识成“长”，但是后面的汉字是“识”， 则将“长”改成“常”；</p>\n<p>第三步，应该就是“去粗取精”，将所有的规则用到事先标识好的语料中，挑出 有用的，删掉无用的。然后重复二三步，直到找不到有用的为止。</p>\n<p>布 莱尔就靠这么简单的方法，在很多自然语言研究领域，得到了几乎最好的结 果。由于他的方法再简单不过了，许许多多的人都跟着学。布莱尔可以算是我在 美国的第 一个业师，我们俩就用这么简单的方法作词性标注 (part of speech tagging)，也就是把句子中的词标成名词动词，很多年内无人能超越。（最后超 越我们的是后来加入 Google 的一名荷兰工程师，用的是同样的方法，但是做得 细致很多）布莱尔离开学术界后去了微软研究院。在那里的第一年，他一人一年 完成的工作比组里其他所有人许多 年做的工作的总和还多。后来，布莱尔又加 入了一个新的组，依然是高产科学家。据说，他的工作真正被微软重视要感谢 Google，因为有了 Google，微软才对他从人力物力上给于了巨大的支持，使得 布莱尔成为微软搜索研究的领军人物之一。在研究方面，布莱尔有时不一定能马 上找到应该怎么 做，但是能马上否定掉一种不可能的方案。这和他追求简单的 研究方法有关，他能在短时间内大致摸清每种方法的好坏。</p>\n<p>由于布莱尔总是找简单有 效的方法，而又从不隐瞒自己的方法，所以他总是很 容易被包括作者我自己在内的很多人赶上和超过。好在布莱尔很喜欢别人追赶 他，因为，当人们在一个研究方向 超过他时，他已经调转船头驶向它方了。一 次，艾里克对我说，有一件事我永远追不上他，那就是他比我先有了第二个孩 子 ：）</p>\n<p>在接下来了系列里，我们还会介绍一个繁与简结合的例子。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-–-谈谈最大熵模型-（上）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 – 谈谈最大熵模型 （上）</h2><p>2006 年 10 月 8 日 上午 07:27:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们在投资时常常讲不要把所有的鸡蛋放在一个篮子里，这样可以降低风险。 在信息处理中，这个原理同样适用。在数学上，这个原理称为最大熵原理 (“the maximum entropy principle”)。这是一个非常有意思的题目，但是把它讲清楚要 用两个系列的篇幅。</p>\n<p>前段时间，Google 中国研究院的刘骏总监谈到在网络搜索排名中，用到的信息 有上百种。更普遍地讲，在自然语言处理中，我们常常知道各种各样的但是又不 完全确定的信息，我们需要用一个统一的模型将这些信息综合起来。如何综合得 好，是一门很大的学问。</p>\n<p>让 我们看一个拼音转汉字的简单的例子。假如输入的拼音是”wang-xiao-bo”， 利用语言模型，根据有限的上下文(比如前两个词)，我们能给出两个最 常见的 名字“王小波”和“王晓波”。至于要唯一确定是哪个名字就难了，即使利用较 长的上下文也做不到。当然，我们知道如果通篇文章是介绍文学的，作家王小 波 的可能性就较大；而在讨论两岸关系时，台湾学者王晓波的可能性会较大。在上 面的例子中，我们只需要综合两类不同的信息，即主题信息和上下文信息。虽然 有 不少凑合的办法，比如：分成成千上万种的不同的主题单独处理，或者对每 种信息的作用加权平均等等，但都不能准确而圆满地解决问题，这样好比以前我 们谈到的 行星运动模型中的 小圆套大圆 打补丁的方法。在很多应用中，我们需 要综合几十甚至上百种不同的信息，这种小圆套大圆的方法显然行不通。</p>\n<p>数学上最漂亮的办法是最大熵(“maximum entropy”)模型，它相当于行星运动的椭 圆模型。“最大熵”这个名词听起来很深奥，但是它的原理很简单，我们每天都 在用。说白了，就是要保留全部的不确定性，将风险降到最小。让我们来看一个 实际例子。</p>\n<p>有 一次，我去 AT&amp;T 实验室作关于最大熵模型的报告，我带去了一个色子。我 问听众“每个面朝上的概率分别是多少”，所有人都说是等概率，即各点的概率 均为 1/6。这种猜测当然 是对的。我问听众们为什么，得到的回答是一致的： 对这个“一无所知”的色子，假定它每一个朝上概率均等是最安全的做法。（你 不应该主观假设它象韦小宝的色 子一样灌了铅。）从投资的角度看，就是风险 最小的做法。从信息论的角度讲，就是保留了最大的不确定性，也就是说让熵达 到最大。接着，我又告诉听众，我的这 个色子被我特殊处理过，已知四点朝上 的概率是三分之一，在这种情况下，每个面朝上的概率是多少？这次，大部分人 认为除去四点的概率是 1/3，其余的均是 2/15，也就是说已知的条件（四点概 率为 1/3）必须满足，而对其余各点的概率因为仍然无从知道，因此只好认为它 们均等。注意，在猜测这两种不同情况下的概率分布时，大家都没有添加任何主观的假 设，诸如四点的反面一定是三点等等。（事实上，有的色子四点反面不 是三点而是一点。）这种基于直觉的猜测之所以准确，是因为它恰好符合了最大 熵原理。</p>\n<p>最 大熵原理指出，当我们需要对一个随机事件的概率分布进行预测时，我们的 预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。（不做主 观假设这 点很重要。）在这种情况下，概率分布最均匀，预测的风险最小。因 为这时概率分布的信息熵最大，所以人们称这种模型叫“最大熵模型”。我们常 说，不要把所有 的鸡蛋放在一个篮子里，其实就是最大熵原理的一个朴素的说 法，因为当我们遇到不确定性时，就要保留各种可能性。</p>\n<p>回到我们刚才谈到的拼音转 汉字的例子，我们已知两种信息，第一，根据语言 模型，wang-xiao-bo 可以被转换成王晓波和王小波；第二，根据主题，王小波 是作家，《黄金时代》的作者等等，而王晓波是台湾研究两岸关系的学者。因此， 我们就可以建立一个最大 熵模型，同时满足这两种信息。现在的问题是，这样 一个模型是否存在。匈牙利著名数学家、信息论最高奖香农奖得主希萨（Csiszar） 证明，对任何一组不 自相矛盾的信息，这个最大熵模型不仅存在，而且是唯一 的。而且它们都有同一个非常简单的形式 – 指数函数。下面公式是根据上下文 （前两个词）和主题预测下一个词的最大熵模型，其中 w3 是要预测的词（王晓 波 或 者 王 小 波 ）w1 和 w2 是 它 的 前 两 个 字 （ 比 如 说 它 们 分 别 是 “ 出 版 ” ， 和 “”），也就是其上下文的一个大致估计，subject 表示主题。</p>\n<p>我们看到，在上面的公式中，有几个参数 lambda 和 Z ，他们需要通过观测数 据训练出来。</p>\n<p>最大熵模型在形式上是最漂亮的统计模型，而在实现上是最复杂的模型之一。我 们在将下一个系列中介绍如何训练最大熵模型的诸多参数，以及最大熵模型在自 然语言处理和金融方面很多有趣的应用。</p>\n<h2 id=\"十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\"><a href=\"#十六、不要把所有的鸡蛋放在一个篮子里-最大熵模型-（下）\" class=\"headerlink\" title=\"十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）\"></a>十六、不要把所有的鸡蛋放在一个篮子里 最大熵模型 （下）</h2><p>2006 年 11 月 16 日 上午 06:50:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我们 上次谈到 用最大熵模型可以将各种信息综合在一起。我们留下一个问题没有 回答，就是如何构造最大熵模型。我们已经所有的最大熵模型都是指数函数的形 式，现在只需要确定指数函数的参数就可以了，这个过程称为模型的训练。</p>\n<p>最 原 始 的 最 大 熵 模 型 的 训 练 方 法 是 一 种 称 为 通 用 迭 代 算 法 GIS(generalized iterative scaling) 的迭代 算法。GIS 的原理并不复杂，大致可以概括为以下 几个步骤：</p>\n<ol>\n<li><p>假定第零次迭代的初始模型为等概率的均匀分布。</p>\n</li>\n<li><p>用第 N 次迭代的模型来估算每种信息特征在训练数据中的分布，如果超过了 实际的，就把相应的模型参数变小；否则，将它们便大。 3. 重复步骤 2 直到收敛。</p>\n</li>\n</ol>\n<p>GIS 最早是由 Darroch 和 Ratcliff 在七十年代提出的。但是，这两人没有能 对这种算法的物理含义进行很好地解释。后来是由数学家希萨（Csiszar)解释清 楚的，因此，人们在谈到这个算法 时，总是同时引用 Darroch 和Ratcliff 以 及希萨的两篇论文。GIS 算法每次迭代的时间都很长，需要迭代很多次才能收敛， 而且不太稳定，即使在 64 位计算机上都会出现溢出。因此，在实际应用中很少 有人真正使用 GIS。大家只是通过它来了解最大熵模型的算法。</p>\n<p>八十年代，很有天才的孪生兄弟的达拉皮垂(Della Pietra)在 IBM 对 GIS 算法 进行了两方面的改进，提出了改进迭代算法 IIS（improved iterative scaling）。 这使得最大熵模型的训练时间缩短了一到两个数量级。这样最大熵模型才有可能 变得实用。即使如此，在当时也只有 IBM 有条件是用最大熵模型。</p>\n<p>由于最大熵模型在数学上十分完美，对科学家们有很大的诱惑力，因此不少研究 者试图把自己的问题用一个类似最大熵的 近似模型去套。谁知这一近似，最大 熵模型就变得不完美了，结果可想而知，比打补丁的凑合的方法也好不了多少。 于是，不少热心人又放弃了这种方法。第一个在 实际信息处理应用中验证了最 大熵模型的优势的，是宾夕法尼亚大学马库斯的另一个高徒原 IBM 现微软的研 究员拉纳帕提(Adwait Ratnaparkhi)。拉纳帕提的聪明之处在于他没有对最大熵 模型进行近似，而是找到了几个最适合用最大熵模型、而计算量相对不太大的自 然语言处理问 题，比如词性标注和句法分析。拉纳帕提成功地将上下文信息、 词性（名词、动词和形容词等）、句子成分（主谓宾）通过最大熵模型结合起来， 做出了当时世界上 最好的词性标识系统和句法分析器。拉纳帕提的论文发表后 让人们耳目一新。拉纳帕提的词性标注系统，至今仍然是使用单一方法最好的系统。科学家们从拉纳帕提的成就中又看到了用最大熵模型解决复杂的文字信 息处理的希望。</p>\n<p>但是，最大熵模型的计算量仍然是个拦路虎。我在学校时花了很长时间考虑如 何 简化最大熵模型的计算量。终于有一天，我对我的导师说，我发现一种数学变换， 可以将大部分最大熵模型的训练时间在 IIS 的基础上减少两个数量级。我在黑 板上推导了一个多小时，他没有找出我的推导中的任何破绽，接着他又回去想了 两天，然后告诉我我的算法是对的。从此，我们就 建造了一些很大的最大熵模 型。这些模型比修修补补的凑合的方法好不少。即使在我找到了快速训练算法以 后，为了训练一个包含上下文信息，主题信息和语法信息 的文法模型(language model)，我并行使用了 20 台当时最快的 SUN 工作站，仍然计算了三个月。由 此可见最大熵模型的复杂的一面。最大熵模型快速算法的实现很复杂，到今天为 止，世界上能有效实现这些算法的人也不到一百人。 有兴趣实现一个最大熵模 型的读者可以阅读 我的论文 。</p>\n<p>最大熵模型，可以说是集简与繁于一体，形式简单，实现复杂。值得一提的是， 在Google的很多产品中，比如机器翻译，都直接或间接地用到了最大熵模型。</p>\n<p>讲到这里，读者也许会问，当年最早改进最大熵模型算法的达拉皮垂兄弟这些 年难道没有做任何事吗？他们在九十年代初贾里尼克离开 IBM 后，也退出了学 术界，而到在金融界大显身手。他们两人和很多 IBM 语音识别的同事一同到了 一家当时还不大，但现在是世界上最成功对冲基金(hedge fund)公司—-文艺复 兴技术公司 (Renaissance Technologies)。我们知道，决定股票涨落的因素可 能有几十甚至上百种，而最大熵方法恰恰能找到一个同时满足成千上万种不同条 件的模型。达拉皮 垂兄弟等科学家在那里，用于最大熵模型和其他一些先进的 数学工具对股票预测，获得了巨大的成功。从该基金 1988 年创立至今，它的净 回报率高达平均每年 34%。也就是说，如果 1988 年你在该基金投入一块钱，今 天你能得到 200 块钱。这个业绩，远远超过股神巴菲特的旗舰公司伯克夏哈撒 韦（Berkshire Hathaway)。同期，伯克夏哈撒韦的总回报是16 倍。</p>\n<p>值得一提的是，信息处理的很多数学手段，包括隐含马尔可夫模型、子波变换、 贝叶斯网络等等，在华尔街多有直接的应用。由此可见，数学模型的作用。</p>\n<h2 id=\"十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\"><a href=\"#十七、闪光的不一定是金子-谈谈搜索引擎作弊问题-Search-Engine-Anti-SPAM\" class=\"headerlink\" title=\"十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)\"></a>十七、闪光的不一定是金子 谈谈搜索引擎作弊问题 (Search Engine Anti-SPAM)</h2><p>2006 年 11 月 28 日 上午 03:18:00</p>\n<p>Google 研究员 吴军</p>\n<p>自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发 现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一 定是金子。</p>\n<p>搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手段提高自己 网页的排名。早期最常见的作弊方法是重复关键词。比如一个卖数码相机的网站， 重复地罗列各种数码相机的品牌，如尼康、佳能和柯达等等。为了不让读者看到 众多讨厌的关键词，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩 盖这些关键词。其实，这种做法很容易被搜索引擎发现并纠正。</p>\n<p>在有了网页排名(page rank)以后，作弊者发现一个网页被引用的连接越多，排 名就可能越靠前，于是就有了专门卖链接和买链接的生意。比如，有人自己创建 成百上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的连接。 这种做法比重复关键词要高明得多，但是还是不太难被发现。因为那些所谓帮别 人提高排名的网站，为了维持生意需要大量地卖链接，所以很容易露马脚。（这 就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。） 再以后，又有了形形色色的作弊方式，我们就不在这里一一赘述了。</p>\n<p>几年前，我加入 Google 做的第一件事就是消除网络作弊。在 Google 最早发现搜 索引擎作弊的是 Matt Cutts，他在我加入 Google 前几个月开始研究这个问题， 后来，辛格，马丁和我先后加入进来。我们经过几个月的努力，清除了一半的作 弊者。(当然，以后抓作弊的效率就不会有这么高了。）其中一部分网站从此” 痛改前非”，但是还是有很多网站换一种作弊方法继续作弊，因此，抓作弊成了 一种长期的猫捉老鼠的游戏。虽然至今还没有一个一劳永逸地解决作弊问题的方 法，但是，Google 基本做到了对于任何已知的作弊方法，在一定时间内发现并 清除它，从而总是将作弊的网站的数量控制在一个很小的比例范围。</p>\n<p>抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号处理经验的 读者可能知道这么一个事实，我们如果在发动机很吵的汽车里用手机打电话，对 方可能听不清；但是如果我们知道了汽车发动机的频率，我们可以加上一个和发 动机噪音相反的信号，很容易地消除发动机的噪音，这样，收话人可以完全听不 到汽车的噪音。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功 能。消除噪音的流程可以概括如下：</p>\n<p>在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积。噪音消除的 过程是一个解卷积的过程。这在信号处理中并不是什么难题。因为第一，汽车发 动机的频率是固定的，第二，这个频率的噪音重复出现，只要采集几秒钟的信号 进行处理就能做到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性， 就可以检测到并且消除。 事实上，完全随机不相关的高斯白噪音是很难消除的。）</p>\n<p>搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音，使得搜索结果的 排名完全乱了。但是，这种人为加入的噪音并不难消除，因为作弊者的方法不可 能是随机的（否则就无法提高排名了）。而且，作弊者也不可能是一天换一种方 法，即作弊方法是时间相关的。因此，搞搜索引擎排名算法的人，可以在搜集一 段时间的作弊信息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时 间，就如同采集汽车发动机噪音需要时间一样，在这段时间内，作弊者可能会尝 到些甜头。因此，有些人看到自己的网站经过所谓的优化（其实是作弊），排名 在短期内靠前了，以为这种所谓的优化是有效的。但是，不久就会发现排名掉下 去了很多。这倒不是搜索引擎以前宽容，现在严厉了，而是说明抓作弊需要一定 的时间，以前只是还没有检测到这些作弊的网站而已。</p>\n<p>还要强调一点，Google 抓作弊和恢复网站原有排名的过程完全是自动的(并没有 个人的好恶），就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前， 就需要把内容做好，同时要和那些作弊网站划清界限。</p>\n<h2 id=\"十八、矩阵运算和文本处理中的分类问题\"><a href=\"#十八、矩阵运算和文本处理中的分类问题\" class=\"headerlink\" title=\"十八、矩阵运算和文本处理中的分类问题\"></a>十八、矩阵运算和文本处理中的分类问题</h2><p>2007 年 1 月 1 日 下午 03:10:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 在大学学习线性代数时，实在想不出它除了告诉我们如何解线性方程外，还 能有什么别的用途。关于矩阵的许多概念，比如特征值等等，更是脱离日常生活。 后来在 数值分析中又学了很多矩阵的近似算法，还是看不到可以应用的地方。 当时选这些课，完全是为了混学分的学位。我想，很多同学都多多少少有过类似 的经历。直到 后来长期做自然语言处理的研究，我才发现数学家们提出那些矩 阵的概念和算法，是有实际应用的意义的。</p>\n<p>在自然语言处理中，最常见的两类的分 类问题分别是，将文本按主题归类（比 如将所有介绍亚运会的新闻归到体育类）和将词汇表中的字词按意思归类（比如 将各种体育运动的名称个归成一类）。这两种 分类问题都可用通过矩阵运算来 圆满地、同时解决。为了说明如何用矩阵这个工具类解决这两个问题的，让我们 先来来回顾一下我们在余弦定理和新闻分类中介绍的 方法 。</p>\n<p>分类的关键是计算相关性。我们首先对两个文本计算出它们的内容词，或者说 实词的向量，然后求这两个向量的夹角。当这两个向量夹角为零时，新闻就相关； 当它们 垂直或者说正交时，新闻则无关。当然，夹角的余弦等同于向量的内积。 从理论上讲，这种算法非常好。但是计算时间特别长。通常，我们要处理的文章 的数量都很 大，至少在百万篇以上，二次回标有非常长，比如说有五十万个词 （包括人名地名产品名称等等）。如果想通过对一百万篇文章两篇两篇地成对比 较，来找出所有共 同主题的文章，就要比较五千亿对文章。现在的计算机一秒 钟最多可以比较一千对文章，完成这一百万篇文章相关性比较就需要十五年时 间。注意，要真正完成文章 的分类还要反复重复上述计算。</p>\n<p>在文本分类中，另一种办法是利用矩阵运算中的奇异值分解（Singular Value Decomposition，简称 SVD)。现在让我们来看看奇异值分解是怎么回事。首先， 我们可以用一个大矩阵A来描述这一百万篇文章和五十万词的关联性。这个矩阵 中，每一行对应一篇文 章，每一列对应一个词。</p>\n<p>在上面的图中，M=1,000,000，N=500,000。第 i 行，第 j 列的元素，是字典中 第 j 个词在第 i 篇文章中出现的加权词频（比如， TF/IDF )。读者可能已经注 意到了，这个矩阵非常大，有一百万乘以五十万，即五千亿个元素。</p>\n<p>奇 异值分解就是把上面这样一个大矩阵，分解成三个小矩阵相乘，如下图所示。 比如把上面的例子中的矩阵分解成一个一百万乘以一百的矩阵X，一个一百乘以 一百的 矩阵B，和一个一百乘以五十万的矩阵Y。这三个矩阵的元素总数加起来 也不过 1.5 亿，仅仅是原来的三千分之一。相应的存储量和计算量都会小三个数 量级以 上。</p>\n<p>三 个矩阵有非常清楚的物理含义。第一个矩阵X中的每一行表示意思相关的一类 词，其中的每个非零元素表示这类词中每个词的重要性（或者说相关性），数值 越大越 相关。最后一个矩阵Y中的每一列表示同一主题一类文章，其中每个元素 表示这类文章中每篇文章的相关性。中间的矩阵则表示类词和文章雷之间的相关 性。因此， 我们只要对关联矩阵A进行一次奇异值分解，w 我们就可以同时完成 了近义词分类和文章的分类。（同时得到每类文章和每类词的相关性）。</p>\n<p>现在剩下的唯一问题，就是如何用计算机进行奇异值分解。这时线性代数中的许多概念，比如矩阵的特征值等等，以及数值分析的各种算法就统统用上了。 在很长时 间内，奇异值分解都无法并行处理。 虽然 Google 早就有了MapReduce 等并行计算的工具，但是由于奇异值分解很难拆成不相关子运算，即使在 Google 内部以前也无法利用并行计算的优势来分解矩阵。）最近，Google 中国的张智威博士和几个中国的工程师及实习生已经实现了奇异值分解的并行算法，我认为 这是 Google 中国对世界的一个贡献。</p>\n<h2 id=\"十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\"><a href=\"#十九、马尔可夫链的扩展-贝叶斯网络-Bayesian-Networks\" class=\"headerlink\" title=\"十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)\"></a>十九、马尔可夫链的扩展 贝叶斯网络 (Bayesian Networks)</h2><p>我们在前面的系列中多次提到 马尔可夫链 (Markov</p>\n<p>Chain) ， 它描述了一种状态序列，其每个状态值取决于前面有限个状态。这种模型，对很 多实际问题来讲是一种很粗略的简化。在现实生活中，很多事物相互的关系并不能用 一条 链来串起来。它们之间的关系可能是交叉的、错综复杂的。比如在下图中可以看到，心血管 疾病和它的成因之间的关系是错综复杂的。显然无法用一个链来表 示。</p>\n<p>我们可以把上述的 有向图 看 成一个网络，它就是贝叶斯网络。其中每个圆圈表示一个状态。 状态之间的连线表示它们的因果关系。比如从心血管疾病出发到吸烟的弧线表示心血管疾病 可能和吸 烟有关。当然，这些关系可以有一个量化的可信度 (belief) ，用一个概率描述。我 们可以通过这样一张网络估计出一个人的心血管疾病的可能性。在网络中每个节点概率的计 算，可以用贝叶斯公式来进行， 贝叶斯网络因此而得名。由于网络的每个弧有一个可信度， 贝叶斯网络也被称作信念网络 (belief networks) 。</p>\n<p>和马尔可夫链类似，贝叶斯网络中的每个状态值取决于前面有限个状态。不同的是，贝叶斯 网络比马尔可夫链灵活，它不受马尔可夫链的链状结构的约束，因此可以更准确地描述事件 之间的相关性。可以讲，马尔可夫链是贝叶斯网络的特例，而贝叶斯网络是马尔可夫链的推 广。</p>\n<p>使 用贝叶斯网络必须知道各个状态之间相关的概率。得到这些参数的过程叫做训练。和训 练马尔可夫模型一样，训练贝叶斯网络要用一些已知的数据。比如在训练上面 的网络，需 要知道一些心血管疾病和吸烟、家族病史等有关的情况。相比马尔可夫链，贝叶斯网络的训 练比较复杂，从理论上讲，它是一个 NP-complete 问题，也就是说，对于现在的计算机是 不可计算的。但是，对于某些应用，这个训练过程可以简化，并在计算上实现。</p>\n<p>值得一提的是 IBM Watson 研究所的茨威格博士 (Geoffrey Zweig) 和西雅图华盛顿大学的 比尔默 (Jeff Bilmes) 教授完成了一个通用的贝叶斯网络的工具包，提供给对贝叶斯网络有 兴趣的研究者。</p>\n<p>贝叶斯网络在图像处理、文字处理、支持决策等方面有很多应用。在文字处理方面，语义相近的词之间的关系可以用一个贝叶斯网络来描述。我们利用贝叶斯网络，可以找出近义词和相关的词，在 Google 搜索和 Google 广告中都有直接的应用。</p>\n<h2 id=\"二十、自然语言处理的教父-马库斯\"><a href=\"#二十、自然语言处理的教父-马库斯\" class=\"headerlink\" title=\"二十、自然语言处理的教父 马库斯\"></a>二十、自然语言处理的教父 马库斯</h2><p>2007 年 4 月 13 日 下午 07:03:00</p>\n<p>发表者：Google 研究员，吴军</p>\n<p>我 们在前面的系列中介绍和提到了一些年轻有为的科学家，迈克尔·柯林斯， 艾里克·布莱尔，大卫·雅让斯基，拉纳帕提等等，他们都出自宾夕法尼亚计算 机系米奇 ·马库斯(Mitch Marcus)名下。就像许多武侠小说中描写的，弟子都 成了各派的掌门，师傅一定了不得。的确，马库斯虽然作为第一作者发表的论文 并不多，但是从很多角度 上讲，他可以说是自然语言处理领域的教父。</p>\n<p>马库斯教授长期当任宾夕法尼亚大学计算机系主任，直到他在几年前从 AT&amp;T 找 到皮耶尔替代他为止。作为一个管理者，马库斯显示出在自然处理和计算机科学 方面的卓识的远见。在指导博士生时，马库斯发现语料库在自然语言处理中的重 要 性。马库斯呕心沥血，花了十几年工夫建立了一系列标准的语料库，提供给 全世界的学者使用。这套被称为 LDC 的语料库，是当今全世界自然语言处理的 所有学者都使用的工具。我们在以前的系列中讲到，当今的自然语言处理几乎都 是使用给予统计的方法。要做统计，就需要 大量有代表性的数据。利用这些数 据开发一个自然语言处理系统的过程，可以统称为训练。比如，我们要训练一个 汉语分词系统，我们需要一些已经分好词的中文句 子。当然这些句子需要有代 表性。如果想知道一个分词系统的准确性，我们也需要一些人工分好词的句子进 行测试。这些人工处理好的文字数据库，成为语料库 (corpus)。如果每个研究 室都人工建立几个语料库，不仅浪费时间精力，而且发表文章时，数据没有可比 性。因此，马库斯想到了建立一系列标准的语料库 为全世界的学者用。他利用 自己的影响力让美国自然科学基金会和 DARPA 出钱立项，联络的多所大学和研 究机构，建立的数百个标准的语料库。其中最著名的是 PennTree</p>\n<p>Bank 的语料库。PennTree Bank 覆盖多种语言（包括中文）。每一种语言，它 有几十万到几百万字的有代表性的句子，每个句子都有的词性标注，语法分析树 等等。LDC 语料库如今已成为全世界自然语言处理科学家共用的数据库。如今， 在自然语言处理方面发表论文，几乎都要提供基于 LDC语料库的测试结果。</p>\n<p>马库斯给予他的博士生研究自己感兴趣的课题的自由，这是他之所以桃李满天 下的原因。马库斯对几乎所有的自然语言处理领域有独到的见解。和许多教授让 博士生去 做他拿到基金的项目，马库斯让博士生提出自己有兴趣的课题，或者 用他已有的经费支持学生，或者为他们的项目区申请经费。马库斯高屋建瓴，能够很快的判断一个研究方向是否正确，省去了博士生很多 try-and-error 的时 间。因此他的学生有些很快地拿到的博士学位。</p>\n<p>作为系主任，马库斯在专业设置方面显示出卓识的远见。我有幸和他在同一个 校务顾问委员会任职，一起讨论计算机系的研究方向。马库斯在几年前互联网很 热门、很多大学开始互联 网研究时，看到 bioinformatics (生物信息学）的重 要性，在宾夕法利亚大学设置这个专业，并且在其他大学还没有意识到时，开始招聘这方面的教授。马库斯还建议一些相关领域的教授，包括后 来的系主任皮 耶尔把一部分精力转到生物信息学方面。马库斯同时向他担任顾问的其他一些大 学提出同样的建议。等到网络泡沫破裂以后，很多大学的计算机系开始 向生物信息学转向，但是发现已经很难找到这些方面好的教授了。我觉得，当今中国的 大学，最需要的就是马库斯这样卓有远见的管理者。</p>\n<p>过几天我又要和马库斯一起开顾问委员会的会议了，不知道这次他对计算机科学的发展有什么见解。</p>\n<h2 id=\"二十一、布隆过滤器（-Bloom-Filter-）\"><a href=\"#二十一、布隆过滤器（-Bloom-Filter-）\" class=\"headerlink\" title=\"二十一、布隆过滤器（ Bloom Filter ）\"></a>二十一、布隆过滤器（ Bloom Filter ）</h2><p>2007 年 7 月 3 日 上午 09:35:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>在 日常生活中，包括在设计计算机软件时，我们经常要判断一个元素是否在一 个集合中。比如在字处理软件中，需要检查一个英语单词是否拼写正确（也就是 要判断它 是否在已知的字典中）；在 FBI，一个嫌疑人的名字是否已经在嫌疑 名单上；在网络爬虫里，一个网址是否被访问过等等。最直接的方法就是将集合 中全部的元素存在计算机中，遇到一个新 元素时，将它和集合中的元素直接比 较即可。一般来讲，计算机中的集合是用哈希表（hash table）来存储的。它的 好处是快速准确，缺点是费存储空间。当集合比较小时，这个问题不显著，但是 当集合巨大时，哈希表存储效率低的问题就显现出来 了。比如说，一个象 Yahoo,Hotmail 和 Gmai 那样的公众电子邮件（email）提供商，总是需要过滤 来自发送垃圾邮件的人（spamer）的垃圾邮件。一个办法就是记录下那些发垃圾 邮件的 email 地址。由于那些发送者不停地在注册新的地址，全世界少说也有 几十亿个发垃圾邮件的地址，将他们都存起来则需要大量的网络服务器。如果用 哈希表，每存储一亿 个 email 地址， 就需要 1.6GB 的内存（用哈希表实现的</p>\n<p>具体办法是将每一个<br> email 地 址 对 应 成 一 个 八 字 节 的 信 息 指 纹</p>\n<p>m/2006/08/ml ， 然后将这些信息指纹存入哈 希表，由于哈希表的存储效率一般只有 50%，因此一个 email 地址需要占用十 六个字节。一亿个地址大约要 1.6GB， 即十六亿字节的内存）。因此存贮几十 亿个邮件地址可能需要上百 GB 的内存。除非是超级计算机，一般服务器是无法 存储的。</p>\n<p>今天，我们介绍一种称作布隆过滤器的数学工具，它只需要哈希表 1/8 到 1/4 的大小就能解决同样的问题。</p>\n<p>布隆过滤器是由巴顿.布隆于一九七零年提出的。它实际上是一个很长的二进制 向量和一系列随机映射函数。我们通过上面的例子来说明起工作原理。</p>\n<p>假定我们存储一亿个电子邮件地址，我们先建立一个十六亿二进制（比特）， 即两亿字节的向量，然后将这十六亿个二进制全部设置为零。对于每一个电子邮 件地址 X，我们用八个不同的随机数产生器（F1,F2, …,F8） 产生八个信息指 纹（f1, f2, …, f8）。再用一个随机数产生器 G 把这八个信息指纹映射到 1 到十六亿中的八个自然数 g1, g2, …,g8。现在我们把这八个位置的二进制全 部设置为一。当我们对这一亿个 email 地址都进行这样的处理后。一个针对这 些 email 地址的布隆过滤器就建成了。（见下图）</p>\n<p>现在，让我们看看如何用布隆过滤器来检测一个可疑的电子邮件地址 Y 是否在黑名单中。我们用相同的八个随机数产生器（F1, F2, …, F8）对这个地址产 生八个信息指纹 s1,s2,…,s8，然后将这八个指纹对应到布隆过滤器的八个二 进制位，分别是 t1,t2,…,t8。如果 Y 在黑名单中，显然，t1,t2,..,t8 对应 的八个二进制一定是一。这样在遇到任何在黑名单中的电子邮件地址，我们都能 准确地发现。</p>\n<p>布隆过滤器决不会漏掉任何一个在黑名单中的可 疑地址。但是，它有一条不足 之处。也就是它有极小的可能将一个不在黑名单中的电子邮件地址判定为在黑名 单中，因为有可能某个好的邮件地址正巧对应个八个都 被设置成一的二进制位。 好在这种可能性很小。我们把它称为误识概率。在上面的例子中，误识概率在万 分之一以下。</p>\n<p>布隆过滤器的好处在于快速省空间。但是有一定的误识别率。常见的补救办法是在建立一个小的白名单，存储那些可能别误判的邮件地址。</p>\n<h2 id=\"二十二、谈谈密码学的数学原理\"><a href=\"#二十二、谈谈密码学的数学原理\" class=\"headerlink\" title=\"二十二、谈谈密码学的数学原理\"></a>二十二、谈谈密码学的数学原理</h2><p>2007 年 9 月 13 日 下午 09:00:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>前一阵子看了电视剧《暗算》，蛮喜欢它的构思和里面的表演。其中有一个故事 提到了密码学，故事本身不错，但是有点故弄玄虚。不过有一点是对的，就是当 今的密码学是以数学为基础的。（没有看过暗算的读者可以看一下介绍，  因为我们后面要多次提到这部电视剧。）</p>\n<p>密码学的历史大致可以推早到两千年前，相传名将凯撒为了防止敌方截获情报， 用密码传送情报。凯撒的做法很简单，就是对二十几个罗马字母建立一张对应表， 比如说</p>\n<p>这样，如果不知道密码本，即使截获一段信息也看不懂，比如收到一个的消息 是 EBKTBP，那么在敌人看来是毫无意义的字，通过密码本解破出来就是 CAESAR 一词，即凯撒的名字。这种编码方法史称凯撒大帝。当然，学过信息论的人都知 道，只要多截获一些情报，统计一下字母的频率，就可以解破出这种密码。柯蓝 道尔 在他的“福尔摩斯探案集”中“跳舞的小人”的故事里已经介绍了这种小 技巧。在很长时间里，人们试图找到一些好的编码方法使得解密者无法从密码中 统计出明码 的统计信息，但是，基本上靠经验。有经验的编码者会把常用的词 对应成多个密码， 使得破译者很难统计出任何规律。比如，如果将汉语中的 “是”一词对应于唯一一个编码 0543，那么破译者就会发现 0543 出现的特别 多。但如果将它对应成十个密码 0543，3737，2947 等等，每次随机的挑一个使 用，每个密码出现的次数就不会太多，而且破译者也无从知道这些密码其实对应 一个字。这里面虽然包含着朴素的概率论的原理，但是并不科学化。另外，好的密码必须做到不能根据已知的明文和密文的对应推断出新的密文的内容。历史 上有很多在这方面设计得不周到的密码的例子。在第二次世界大 战中，日本军 方的密码设计就很成问题。美军破获了日本很多密码。在中途岛海战前，美军截 获的日军密电经常出现 AF 这样一个地名，应该是太平洋的某个岛屿，但是美军无从知道是哪个。于是，美军就逐个发表自己控制的每个岛屿上的假新闻。当美 军发出“中途岛供水系统坏了” 这条假新闻后，从截获的日军情报中又看到 AF 供水出来问题的电文，美军就断定中途岛就是 AF。事实证明判断正确，美军在 那里成功地伏击了日本主力舰队。</p>\n<p>事实上，在第二次世界大战中，很多顶尖的科学家包括提出信息论的香农都在 为 美军情报部门工作，而信息论实际上就是情报学的直接产物。香农提出信息论后， 为密码学的发展带来了新气象。根据信息论，密码的最高境界是使得敌人在截获 密码后，对我方的所知没有任何增加，用信息论的专业术语讲，就是信息量没有 增加。一般来讲，当密码之间分布均匀并且统计独立时，提供的信息最少。均匀 分布 使得敌人无从统计，而统计独立能保证敌人即使看到一段密码和明码后， 不能破译另一段密码。这也是《暗算》里传统的破译员老陈破译的一份密报后， 但无法推广 的原因，而数学家黄依依预见到了这个结果，因为她知道敌人新的 密码系统编出的密文是统计独立的。有了信息论后，密码的设计就有了理论基础， 现在通用的公开密钥的方法，包括《暗算》里的“光复一号”密码，就是基于 这个理论。</p>\n<p>公开密钥的原理其实很简单，我们以给上面的单词 Caesar 加解密来说明它的原 理。我们先把它变成一组数，比如它的 Ascii 代码 X=099097101115097114（每 三位代表一个字母）做明码。现在我们来设计一个密码系统，对这个明码加密。</p>\n<p>1，找两个很大的素数（质数）P 和 Q，越大越好，比如 100 位长的, 然后计算 它们的乘积 N=P×Q，M=（P-1）×（Q-1）。</p>\n<p>2，找一个和 M 互素的整数 E，也就是说 M 和 E 除了 1 以外没有公约数。</p>\n<p>3，找一个整数 D，使得 E×D 除以 M 余 1，即 E×D mod M = 1。</p>\n<p>现在世界上先进的、最常用的密码系统就设计好了，其中 E 是公钥谁都可以 用来加密，D 是私钥用于解密，一定要自己保存好。乘积 N 是公开的，即使敌人知道了也没关系。</p>\n<p>现在，我们用下面的公式对 X 加密，得到密码 Y。</p>\n<p>好了，现在没有密钥 D，神仙也无法从 Y 中恢复 X。如果知道 D，根据费尔马 小定理，则只要按下面的公式就可以轻而易举地从 Y 中得到 X。</p>\n<p>这个过程大致可以概况如下：</p>\n<p>公开密钥的好处有：</p>\n<p>1.简单。</p>\n<p>2.可靠。公开密钥方法保证产生的密文是统计独立而分布均匀的。也就是说， 不论给出多少份明文和对应的密文，也无法根据已知的明文和密文的对应来破译 下一份密 文。更重要的是 N,E 可以公开给任何人加密用，但是只有掌握密钥 D 的人才可以解密, 即使加密者自己也是无法解密的。这样，即使加密者被抓住叛 变了，整套密码系统仍然是安全的。而凯撒大帝的加密方法有一个知道密码本的人泄密，整个密码系统就公开了。</p>\n<p>3.灵活，可以产生很多的公开密钥E和私钥D的组合给不同的加密者。</p>\n<p>最后让我们看看破解这种密码的难度。 首先，要声明，世界上没有永远破不了 的密码，关键是它能有多长时间的有效期。要破公开密钥的加密方式，至今的研 究结果表明最好的办法还是对大字 N 进行因数分解，即通过 N 反过来找到 P 和 Q，这样密码就被破了。而找 P 和 Q 目前只有用计算机把所有的数字试一遍 这种笨办法。这实际上是在拼计算机的速度，这也就是为什么 P 和 Q 都需要非 常大。一种加密方法只有保证 50 年计算机破不了也就可以满意了。前几年破解 的 RSA-158 密码是这样因数分解的</p>\n<p>395058745832651445264197678006144819960207764603049364541393760515793 556265294</p>\n<p>506836097278424682195350935443058704902519956553357102097992264849779 49442955603 =</p>\n<p>338849583746672139436839320467218152281583036860499304808492584055528 1177</p>\n<p>×1165882340667125990314837655838327081813101225814639260043952099413 1344334162924536139</p>\n<p>现 在，让我们回到《暗算》中，黄依依第一次找的结果经过一系列计算发现无 法归零，也就是说除不尽，我猜她可能试图将一个大数 N 做分解，没成功。第 二次计算的结果是归零了，说明她找到的 N=P×Q 的分解方法。当然，这件事能 不能用算盘完成，我就不知道了，但我觉得比较夸张。另外我对该电视剧还有一个搞不懂的问题就是里面提到的“光复一号”密码的误 差问题。一个密码是不 能有误差的，否则就是有的密钥也无法解码了。我想可能是指在构造密码时，P 和 Q 之一没找对，其中一个（甚至两个都）不小心找成了合数，这时密码的保密性 就差了很多。如果谁知道电视剧里面讲的“误差”是指什么请告诉我。另外，电 视剧里 提到冯 · 诺依曼，说他是现代密码学的祖宗，我想是弄错了，应该是香农。 冯 · 诺依曼的贡献在发明计算机和提出博弈论（game theory）。</p>\n<p>不管怎么样，我们今天用的所谓最可靠的加密方法的数学原理其实就这么简单， 一点也不神秘，无非是找几个大素数做一些乘除和乘方运算就可以了。</p>\n<h2 id=\"二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\"><a href=\"#二十三、输入一个汉字需要敲多少个键-—-谈谈香农第一定律\" class=\"headerlink\" title=\"二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律\"></a>二十三、输入一个汉字需要敲多少个键 — 谈谈香农第一定律</h2><p>2007 年 12 月 3 日 上午 10:05:00</p>\n<p>发表者：Google（谷歌）研究员 吴军</p>\n<p>今天各种汉字输入法已经很成熟了，随便挑出一种主要的输入法比十几年前最好 的输入法都要快、要准。现在抛开具体的输入法，从理论上分析一下，输入汉字 到底能有多快。</p>\n<p>我 们假定常用的汉字在二级国标里面，一共有 6700 个作用的汉字。如果不考 虑汉字频率的分布，用键盘上的 26 个字母对汉字编码，两个字母的组合只能对 676 个汉字编码，对 6700 个汉字编码需要用三个字母的组合，即编码长度为三。 当然，聪明的读者马上发现了我们可以对常见的字用较短的编码对不常见的字用 较长的编码，这样平均起来每 个汉字的编码长度可以缩短。我们假定每一个汉 字的频率是</p>\n<p>p1, p2, p3, …, p6700 它们编码的长度是</p>\n<p>L1, L2, L3, …, L6700 那么，平均编码长度是</p>\n<p>p1×L1 + p2×L2 + … + p6700×L6700</p>\n<p>香 农第一定理指出：这个编码的长度的最小值是汉字的信息熵，也就是说任何 输入方面不可能突破信息熵给定的极限。当然，香农第一定理是针对所有编码的， 不但是 汉字输入编码的。这里需要指出的是，如果我们将输入法的字库从二级 国标扩展到更大的字库 GBK，由于后面不常见的字频率较短，平均编码长度比针 对 国 标 的 大 不 了 多 少 。 让 我 们 回 忆 一 下 汉 字 的 信 息 熵 （ 见 m/2006/04/4.html ）， H = -p1 * log p1 - … - p6700 log p6700。</p>\n<p>我们如果对每一个字进行统计，而且不考虑上下文相关性，大致可以估算出它的 值在十比特以内，当然这取决于用什么语料库来做估计。如果我们假定输入法只 能用 26 个字母输入，那么每个字母可以代表 log26=</p>\n<p>4.7 比特的信息，也就是说，输入一个汉字平均需要敲 10/4.7= 2.1 次键。</p>\n<p>聪明的读者也许一经发现，如果我们把汉字组成词，再以词为单位统计信息熵， 那么，每个汉字的平均信息熵将会减少。这样，平均输入一个字可以少敲零点几 次键 盘。不考虑词的上下文相关性，以词为单位统计，汉字的信息熵大约是 8 比特作用，也就是说，以词为单位输入一个汉字平均只需要敲 8/4.7=1.7 次键。 这就是现在所有输入法都是基于词输入的内在原因。当然，如果我们再考虑上下 文 的 相 关 性 ， 对 汉 语 建 立 一 个 基 于 词 的 统 计 语 言 模 型 （ 见 m/2006/04/ml ），我们可以将每 个汉字的信息熵降到 6 比特作用，这时，输入一个汉字只要敲 6/4.7=1.3 次键。 如果一种输入方法能做到这一点，那么汉字的输入已经比英文快的多了。</p>\n<p>但是，事实上没有一种输入方法接近这个效率。这里面主要有两个原因。首先， 要接近信息论给的这个极限，就要对汉字的词组根据其词频进行特殊编码。事实 上像王码这类的输入方法就是这么做到，只不过它们第一没有对词组统一编码， 第二没有有效的语言模型。这种编码方法理论上讲有效，实际上不实用。原因有 两个，第一，很难学；第二，从认知科学的角度上讲，人一心无二用，人们在没有稿子边想边写的情况下不太可能在回忆每个词复杂的编码的同时又不中断 思维。我们过去在 研究语言识别时做过很多用户测试，发现使用各种复杂编码 输入法的人在脱稿打字时的速度只有他在看稿打字时的一半到四分之一。因此， 虽然每个字平均敲键次数 少，但是打键盘的速度也慢了很多，总的并不快。这 也就是为什么基于拼音的简单输入法占统治地位的原因。事实上，汉语全拼的平均长度为2.98，只要基于拼音的输入法能利用上下文彻底解决一音多字的问题， 平均每个汉字输入的敲键次数应该在三次左右，每分钟输入 100 个字完全有可能达到。</p>\n<p>另外一个不容易达到信息论极限的输入速度的原因在于，这个理论值是根据一个很多的语言模型计算出来的。在产品中，我 们不可能占有用户太多的内存空间， 因此各种输入方法提供给用户的是一个压缩的很厉害的语音模型，而有的输入方 法为了减小内存占用，根本没有语言模型。拼音 输入法的好坏关键在准确而有 效的语言模型。</p>\n<p>另一方面，由于现有输入方法离信息论给的极限还有很大的差距，汉语输入方法可提升的空间很大，会有越来越好用的输入方法不断涌现。当然，输入速度只是输入法的一项而不是唯一的衡量标准。我们也会努力把谷歌的输入法做的越来越好。大家不妨先试试现在的版本， m/pinyin/ ，半年后再看看我们有没有提高。</p>\n"}],"PostAsset":[{"_id":"source/_posts/How-To-Next/browserstack_logo.png","slug":"browserstack_logo.png","post":"cjp7z0my6001brd4l6phzah9i","modified":0,"renderable":0},{"_id":"source/_posts/How-To-Next/logo.svg","slug":"logo.svg","post":"cjp7z0my6001brd4l6phzah9i","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjp7z0mvg0001rd4l9p985tca","category_id":"cjp7z0mw10005rd4l2plmsksx","_id":"cjp7z0mwg000erd4lzf8r9ecg"},{"post_id":"cjp7z0mvq0003rd4lyu5gu255","category_id":"cjp7z0mw10005rd4l2plmsksx","_id":"cjp7z0mwi000hrd4lhevs3gje"},{"post_id":"cjp7z0mw70008rd4lrywazq9i","category_id":"cjp7z0mwi000ird4lilrmp8yi","_id":"cjp7z0mwk000ord4lwcqqhwo0"},{"post_id":"cjp7z0mw40007rd4l846vvj3c","category_id":"cjp7z0mwg000drd4lbpd8rix5","_id":"cjp7z0mwn000urd4lncx7fwhp"},{"post_id":"cjp7z0mw40007rd4l846vvj3c","category_id":"cjp7z0mwl000prd4le7eynu9s","_id":"cjp7z0mwo000wrd4l6wd155hi"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","category_id":"cjp7z0mwj000krd4l9jpzsrk7","_id":"cjp7z0mwr0012rd4lfebcdn74"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","category_id":"cjp7z0mwm000srd4ll7i7cr0o","_id":"cjp7z0mws0014rd4ldwjyrlzi"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","category_id":"cjp7z0mwo000xrd4lqahux0n5","_id":"cjp7z0mws0016rd4lvthhu6fp"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","category_id":"cjp7z0mwp000zrd4lmwv1v0r6","_id":"cjp7z0mwt0018rd4l6gw7wm3a"},{"post_id":"cjp7z0my6001brd4l6phzah9i","category_id":"cjp7z0my8001erd4l3ytwqi02","_id":"cjp7z0myb001prd4lav6qmq9f"},{"post_id":"cjp7z0my6001brd4l6phzah9i","category_id":"cjp7z0mya001lrd4luvxkaeu2","_id":"cjp7z0myb001qrd4lbjfen8fe"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","category_id":"cjp7z0my7001crd4lyxfa3laq","_id":"cjp7z0myb001rrd4l7pva9hid"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","category_id":"cjp7z0my9001ird4lfa8zha1a","_id":"cjp7z0myb001srd4lbczkhuj7"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","category_id":"cjp7z0mya001ord4l26akqrdg","_id":"cjp7z0myb001trd4lundyzcfn"},{"post_id":"cjp7z0n5k001urd4loqitzkay","category_id":"cjp7z0n5l001vrd4lfoqve4mh","_id":"cjp7z0n5n0020rd4l6l1k4krk"},{"post_id":"cjp7z0n5k001urd4loqitzkay","category_id":"cjp7z0n5m001yrd4lznudc0qv","_id":"cjp7z0n5n0022rd4l2ma5pvm2"},{"post_id":"cjp7z0n5o0025rd4lf41eqdj5","category_id":"cjp7z0n5l001vrd4lfoqve4mh","_id":"cjp7z0n5r0028rd4ld7li20qp"},{"post_id":"cjp7z0n5o0025rd4lf41eqdj5","category_id":"cjp7z0n5m001yrd4lznudc0qv","_id":"cjp7z0n5r002ard4lnbmwvfle"},{"post_id":"cjp7z0n5u002brd4lbc1mfvil","category_id":"cjp7z0n5l001vrd4lfoqve4mh","_id":"cjp7z0n5w002erd4l0ya1033v"},{"post_id":"cjp7z0n5u002brd4lbc1mfvil","category_id":"cjp7z0n5m001yrd4lznudc0qv","_id":"cjp7z0n5w002grd4l67ilnd4s"}],"PostTag":[{"post_id":"cjp7z0mvg0001rd4l9p985tca","tag_id":"cjp7z0mw30006rd4ll9w91798","_id":"cjp7z0mwf000crd4lbjsv4n1f"},{"post_id":"cjp7z0mvq0003rd4lyu5gu255","tag_id":"cjp7z0mw30006rd4ll9w91798","_id":"cjp7z0mwh000grd4ljsatqk6u"},{"post_id":"cjp7z0mw40007rd4l846vvj3c","tag_id":"cjp7z0mwh000frd4l87q1mw6a","_id":"cjp7z0mwk000mrd4lmlev654r"},{"post_id":"cjp7z0mw40007rd4l846vvj3c","tag_id":"cjp7z0mwi000jrd4lz6552tjb","_id":"cjp7z0mwk000nrd4ll6nnbjbw"},{"post_id":"cjp7z0mw70008rd4lrywazq9i","tag_id":"cjp7z0mwj000lrd4lwz7e98ea","_id":"cjp7z0mwm000rrd4l4bfeuwmv"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","tag_id":"cjp7z0mwl000qrd4lzsxyl07z","_id":"cjp7z0mwr0011rd4l52m7kpjc"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","tag_id":"cjp7z0mwm000trd4l6oysk3ot","_id":"cjp7z0mwr0013rd4lqpbz5mqx"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","tag_id":"cjp7z0mwn000vrd4lbqux0ale","_id":"cjp7z0mws0015rd4lypw2nuqc"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","tag_id":"cjp7z0mwp000yrd4lau6jrt2p","_id":"cjp7z0mws0017rd4lr8mvqadg"},{"post_id":"cjp7z0mw90009rd4l4li1dp5s","tag_id":"cjp7z0mwq0010rd4layk0e0w5","_id":"cjp7z0mwt0019rd4lwhxa7gw2"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","tag_id":"cjp7z0my7001drd4lu0qorc5s","_id":"cjp7z0my9001grd4ld6e87lrz"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","tag_id":"cjp7z0mwm000trd4l6oysk3ot","_id":"cjp7z0my9001hrd4ljtmax56v"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","tag_id":"cjp7z0mwq0010rd4layk0e0w5","_id":"cjp7z0mya001jrd4lp8k15ajd"},{"post_id":"cjp7z0mxw001ard4lxq2i0vmu","tag_id":"cjp7z0mwn000vrd4lbqux0ale","_id":"cjp7z0mya001krd4lfdmeskj0"},{"post_id":"cjp7z0my6001brd4l6phzah9i","tag_id":"cjp7z0mwj000lrd4lwz7e98ea","_id":"cjp7z0mya001mrd4ldopkju32"},{"post_id":"cjp7z0my6001brd4l6phzah9i","tag_id":"cjp7z0my8001frd4lphfz02j6","_id":"cjp7z0mya001nrd4l2vo3jnp5"},{"post_id":"cjp7z0n5k001urd4loqitzkay","tag_id":"cjp7z0n5l001wrd4lh1lhu9it","_id":"cjp7z0n5n0021rd4lhcv2oi6v"},{"post_id":"cjp7z0n5k001urd4loqitzkay","tag_id":"cjp7z0n5m001xrd4l74dvx0f7","_id":"cjp7z0n5n0023rd4lni3t1cq4"},{"post_id":"cjp7z0n5k001urd4loqitzkay","tag_id":"cjp7z0n5m001zrd4ltdp05mam","_id":"cjp7z0n5n0024rd4ldm9dzgt9"},{"post_id":"cjp7z0n5o0025rd4lf41eqdj5","tag_id":"cjp7z0n5l001wrd4lh1lhu9it","_id":"cjp7z0n5r0026rd4lk6lsmhgb"},{"post_id":"cjp7z0n5o0025rd4lf41eqdj5","tag_id":"cjp7z0n5m001xrd4l74dvx0f7","_id":"cjp7z0n5r0027rd4lu9xuci0x"},{"post_id":"cjp7z0n5o0025rd4lf41eqdj5","tag_id":"cjp7z0n5m001zrd4ltdp05mam","_id":"cjp7z0n5r0029rd4lyj88ah9w"},{"post_id":"cjp7z0n5u002brd4lbc1mfvil","tag_id":"cjp7z0n5l001wrd4lh1lhu9it","_id":"cjp7z0n5w002crd4ll974klj8"},{"post_id":"cjp7z0n5u002brd4lbc1mfvil","tag_id":"cjp7z0n5m001xrd4l74dvx0f7","_id":"cjp7z0n5w002drd4l8zrfkrkg"},{"post_id":"cjp7z0n5u002brd4lbc1mfvil","tag_id":"cjp7z0n5m001zrd4ltdp05mam","_id":"cjp7z0n5w002frd4la9us1dde"}],"Tag":[{"name":"medical_news","_id":"cjp7z0mw30006rd4ll9w91798"},{"name":"GitHub","_id":"cjp7z0mwh000frd4l87q1mw6a"},{"name":"How-To","_id":"cjp7z0mwi000jrd4lz6552tjb"},{"name":"hexo","_id":"cjp7z0mwj000lrd4lwz7e98ea"},{"name":"日语","_id":"cjp7z0mwl000qrd4lzsxyl07z"},{"name":"分词","_id":"cjp7z0mwm000trd4l6oysk3ot"},{"name":"Java","_id":"cjp7z0mwn000vrd4lbqux0ale"},{"name":"Kuromoji","_id":"cjp7z0mwp000yrd4lau6jrt2p"},{"name":"Word Analyzer","_id":"cjp7z0mwq0010rd4layk0e0w5"},{"name":"AnsjSeq","_id":"cjp7z0my7001drd4lu0qorc5s"},{"name":"next","_id":"cjp7z0my8001frd4lphfz02j6"},{"name":"吴军","_id":"cjp7z0n5l001wrd4lh1lhu9it"},{"name":"算法","_id":"cjp7z0n5m001xrd4l74dvx0f7"},{"name":"数学","_id":"cjp7z0n5m001zrd4ltdp05mam"}]}}